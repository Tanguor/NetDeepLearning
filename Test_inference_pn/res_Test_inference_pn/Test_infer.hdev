<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="22.11.0.0">
<procedure name="main">
<interface/>
<body>
<c>* </c>
<c>* This example is part of a series of examples, which summarizes</c>
<c>* the workflow for DL object detection. It uses the MVTec pill bag dataset.</c>
<c>* </c>
<c>* The four parts are:</c>
<c>* 1. Creation of the model and dataset preprocessing.</c>
<c>* 2. Training of the model.</c>
<c>* 3. Evaluation of the trained model.</c>
<c>* 4. Inference on new images.</c>
<c>* </c>
<c>* This examples covers part 4: 'Inference on new images'</c>
<c>* </c>
<c>* It explains how to apply a trained model on new images and shows</c>
<c>* an application based on the pill bag dataset.</c>
<c>* </c>
<c>* Please note: This script uses a pretrained model. To use the output</c>
<c>* of part 1 and part 2 of this example series, set UsePretrainedModel</c>
<c>* to false below.</c>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<c>* In this example, the inference steps are explained in graphics windows,</c>
<c>* before they are executed. Set the following parameter to false in order to</c>
<c>* skip this visualization.</c>
<l>ShowExampleScreens := false</l>
<c>* </c>
<c>* By default, this example uses a model pretrained by MVTec. To use the model</c>
<c>* which was trained in part 2 of this example series, set the following</c>
<c>* variable to false.</c>
<l>UsePretrainedModel := true</l>
<c>* </c>
<c>* Inference can be done on a GPU or CPU.</c>
<c>* See the respective system requirements in the Installation Guide.</c>
<c>* If possible a GPU is used in this example.</c>
<c>* In case you explicitly wish to run this example on the CPU,</c>
<c>* choose the CPU device instead.</c>
<l>query_available_dl_devices (['runtime', 'runtime'], ['gpu', 'cpu'], DLDeviceHandles)</l>
<l>* if (|DLDeviceHandles| == 0)</l>
<l>*     throw ('No supported device found to continue this example.')</l>
<l>* endif</l>
<c>* Due to the filter used in query_available_dl_devices, the first device is a GPU, if available.</c>
<l>DLDevice := DLDeviceHandles[0]</l>
<c>* </c>
<l>* if (ShowExampleScreens)</l>
<c>    * </c>
<c>    * Initial example windows and parameters etc.</c>
<l>*     dev_example_init (ShowExampleScreens, UsePretrainedModel, ExampleInternals)</l>
<c>    * </c>
<c>    * Introduction text of example series.</c>
<l>*     dev_display_screen_introduction (ExampleInternals)</l>
<l>*     stop ()</l>
<c>    * </c>
<c>    * Show example image.</c>
<l>*     dev_display_screen_example_images (ExampleInternals)</l>
<l>*     stop ()</l>
<c>    * </c>
<c>    * Explain inference steps.</c>
<l>*     dev_display_screen_inference_step_1 (ExampleInternals)</l>
<l>*     stop ()</l>
<l>*     dev_display_screen_inference_step_2_part_1 (ExampleInternals)</l>
<l>*     stop ()</l>
<l>*     dev_display_screen_inference_step_2_part_2 (ExampleInternals)</l>
<l>*     stop ()</l>
<l>*     dev_display_screen_inference_step_3 (ExampleInternals)</l>
<l>*     stop ()</l>
<c>    * </c>
<c>    * Explain parameter 'min_confidence'.</c>
<l>*     dev_display_screen_min_confidence (ExampleInternals)</l>
<l>*     stop ()</l>
<c>    * </c>
<c>    * Explain parameter 'max_overlap'.</c>
<l>*     dev_display_screen_max_overlap (ExampleInternals)</l>
<l>*     stop ()</l>
<c>    * </c>
<c>    * Explain parameter 'max_overlap_class_agnostic'.</c>
<l>*     dev_display_screen_max_overlap_class_agnostic (ExampleInternals)</l>
<l>*     stop ()</l>
<c>    * </c>
<c>    * Mention on which device the deep learning operators will run.</c>
<l>*     dev_display_screen_device (ExampleInternals, DLDevice)</l>
<l>*     stop ()</l>
<c>    * </c>
<c>    * Run the program showing inference by means of an application.</c>
<l>*     dev_display_screen_run_program (ExampleInternals)</l>
<l>*     stop ()</l>
<c>    * </c>
<c>    * Terminate example screens.</c>
<l>*     dev_close_example_windows (ExampleInternals)</l>
<l>* endif</l>
<l>stop()  </l>
<l>Oui (ImageBatch, UsePretrainedModel, DLDevice, ExampleDir, ImageDir, ExampleDataDir, PreprocessParamFileName, RetrainedModelFileName, DataDirectory, BatchSizeInference, MinConfidence, MaxOverlap, MaxOverlapClassAgnostic, DLModelHandle, DLPreprocessParam, WindowHandleDict, DLDataInfo, ClassNames, ClassIDs, GenParam, ImageFiles, BatchIndex, Batch, DLSampleBatch, DLResultBatch, SampleIndex, DLSample, DLResult, DetectedClassIDs, NumberDetectionsPerClass, Index, Text, TextColor, TextBoxColor, WindowHandles)</l>
<l>stop()  </l>
<c>* Close windows used for visualization.</c>
<l>dev_close_window_dict (WindowHandleDict)</l>
<c>* </c>
<c>* </c>
<l>* if (ShowExampleScreens)</l>
<c>    * Final explanations.</c>
<l>*     dev_display_screen_final (ExampleInternals)</l>
<l>*     stop ()</l>
<c>    * Close example windows.</c>
<l>*     dev_close_example_windows (ExampleInternals)</l>
<l>* endif</l>
<c></c>
<c>*Qualibration robot Camera.</c>
<l>* Px :=[1069.274,	599.0974,	127.6324,	831.2632	,362.2693	,1064.568	,593.5743	,123.7327	,825.9352	,355.5892	,1058.612	,587.8631	,117.9697]</l>
<l>* Py :=[462.3172,	456.3231,	451.2802	,646.8602,	641.1147,	836.7188,	830.9728,	824.541,	1022.311	,1014.848,	1210.558,	1204.51,	1197.553]</l>
<l>* Qx :=[-397.797	,-398.197	,-399.497,	-368	,-368.963	,-337.88,	-338.78, -339.38,	-308.362,	-309.162	,-277.798,	-278.799,	-278.698]</l>
<l>* Qy :=[-70.184,	5.251	,80.271,	-32.079,	42.537	,-70.399	,5.377	,80.93,	-32.25	,43.117,	-69.416,	6.077,	81.626]</l>
<c></c>
<l> xobj := DLResult.bbox_row * 1600/256</l>
<l> yobj := DLResult.bbox_col * 1200/256</l>
<c></c>
<l>* vector_to_hom_mat2d(Px,Py ,Qx ,Qy , HomMat2D)</l>
<l>Hom := [[-0.000530974,0.159264,-468.354],[-0.160104,-0.000612368,102.174],[0,0,1]]</l>
<c></c>
<l>affine_trans_point_2d(Hom, xobj, yobj, Qx1, Qy1)</l>
<c>*Création Chaine de charactère:</c>
<l>X :=''</l>
<l>Y :=''</l>
<l>    for Index1 := 0 to |Qx1|-1 by 1</l>
<l>        tuple_string (Qx1[Index1], '.3f', Xi)</l>
<l>        if (X = '')</l>
<l>            X := Xi</l>
<l>        else</l>
<l>            X := X + ';' + Xi</l>
<l>        endif</l>
<l>        tuple_string (Qy1[Index1], '.3f', Yi)</l>
<l>        if (Y = '')</l>
<l>            Y := Yi</l>
<l>        else</l>
<l>            Y := Y + ';' + Yi</l>
<l>        endif</l>
<l>    endfor </l>
<l>open_socket_connect('localhost', 5014, 'protocol', 'TCP', Socket)</l>
<l>send_data(Socket, 'z', |Qx1|+';'+X+';'+Y, [])</l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="dev_example_init">
<interface>
<ic>
<par name="ShowExampleScreens" base_type="ctrl" dimension="0"/>
<par name="UsePretrainedModel" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure initializes the graphic windows that are used for explanations during the example.</c>
<c>* </c>
<c>* A dict that will be used/adapted by other example procedures.</c>
<l>create_dict (ExampleInternals)</l>
<l>set_dict_tuple (ExampleInternals, 'show_example_screens', ShowExampleScreens)</l>
<l>set_dict_tuple (ExampleInternals, 'use_pretrained_model', UsePretrainedModel)</l>
<l>if (not ShowExampleScreens)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<l>dev_close_window ()</l>
<l>dev_open_example_text_window (ExampleInternals)</l>
<c>* </c>
<l>set_dict_tuple (ExampleInternals, 'window_images_needed', false)</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend_needed', false)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_example_init">
<parameters>
<parameter id="ExampleInternals"/>
<parameter id="ShowExampleScreens">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">A boolean that is used to enable/disable explanation screens in this example</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
<value_min>0</value_min>
</parameter>
<parameter id="UsePretrainedModel"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_screen_introduction">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays an overview on the different example parts.</c>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'show_example_screens', ShowExampleScreens)</l>
<l>if (not ShowExampleScreens)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Reset the open windows for a clean display.</c>
<l>set_dict_tuple (ExampleInternals, 'window_images_needed', false)</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend_needed', false)</l>
<l>dev_display_example_reset_windows (ExampleInternals)</l>
<c>* </c>
<c>* Display explanatory text.</c>
<l>get_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>dev_set_window (WindowHandleText)</l>
<c>* </c>
<l>Text := 'This example is part of a series of examples, which summarize '</l>
<l>Text[|Text|] := 'the workflow for DL object detection. It uses the MVTec pill bag dataset.'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := 'The four parts are: '</l>
<l>Text[|Text|] := '1. Creation of the model and dataset preprocessing.'</l>
<l>Text[|Text|] := '2. Training of the model.'</l>
<l>Text[|Text|] := '3. Evaluation of the trained model.'</l>
<l>Text[|Text|] := '4. Inference on new images.'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := 'This example covers part 4: \'Inference on new images\'.'</l>
<c>* </c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_screen_introduction">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_example_reset_windows">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure resets the graphics windows.</c>
<c>* </c>
<c>* Close any windows that are listed in key 'window_handles_to_close'.</c>
<l>try</l>
<l>    get_dict_tuple (ExampleInternals, 'window_handles_to_close', WindowHandlesToClose)</l>
<l>catch (Exception)</l>
<l>    WindowHandlesToClose := []</l>
<l>endtry</l>
<l>for I := 0 to |WindowHandlesToClose| - 1 by 1</l>
<l>    dev_set_window (WindowHandlesToClose[I])</l>
<l>    dev_close_window ()</l>
<l>endfor</l>
<l>set_dict_tuple (ExampleInternals, 'window_handles_to_close', [])</l>
<c>* </c>
<c>* Open image window if needed</c>
<l>get_dict_param (ExampleInternals, 'keys', [], WindowHandleKeys)</l>
<l>tuple_find (WindowHandleKeys, 'window_images', Index)</l>
<l>get_dict_tuple (ExampleInternals, 'window_images_needed', WindowImagesNeeded)</l>
<l>if (WindowImagesNeeded and Index == -1)</l>
<c>    * Open new window for images</c>
<l>    dev_open_example_image_window (ExampleInternals)</l>
<l>elseif (not WindowImagesNeeded and Index != -1)</l>
<c>    * Window for images exists but is not needed -&gt; close it</c>
<l>    dev_close_example_image_window (ExampleInternals)</l>
<l>endif</l>
<c>* </c>
<c>* Open legend window if needed</c>
<l>get_dict_param (ExampleInternals, 'keys', [], WindowHandleKeys)</l>
<l>tuple_find (WindowHandleKeys, 'window_legend', Index)</l>
<l>get_dict_tuple (ExampleInternals, 'window_legend_needed', WindowLegendNeeded)</l>
<l>if (WindowLegendNeeded and Index == -1)</l>
<c>    * Open new window for legend</c>
<l>    dev_open_example_legend_window (ExampleInternals, 280)</l>
<l>elseif (not WindowLegendNeeded and Index != -1)</l>
<c>    * Window for legend exists but is not needed -&gt; close it</c>
<l>    dev_close_example_legend_window (ExampleInternals)</l>
<l>endif</l>
<c>* </c>
<c>* Set the correct area (part) of the image window.</c>
<l>try</l>
<l>    get_dict_tuple (ExampleInternals, 'window_images', WindowHandleImages)</l>
<l>    dev_set_window (WindowHandleImages)</l>
<l>    dev_clear_window ()</l>
<c>    * Set default window extends</c>
<l>    dev_set_window_extents (360, 0, 800, 500)</l>
<l>    dev_set_part (1, 1, -1, -1)</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c>* </c>
<c>* Set the correct area (part) of the legend window.</c>
<l>try</l>
<l>    get_dict_tuple (ExampleInternals, 'window_legend', WindowHandleLegend)</l>
<l>    dev_set_window (WindowHandleLegend)</l>
<l>    dev_clear_window ()</l>
<l>    dev_set_part (1, 1, -1, -1)</l>
<l>catch (Exception)</l>
<l>endtry</l>
<l>get_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>dev_set_window (WindowHandleText)</l>
<l>dev_clear_window ()</l>
<l>return ()</l>
</body>
<docu id="dev_display_example_reset_windows">
<parameters>
<parameter id="ExampleInternals">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_open_example_legend_window">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
<par name="WindowWidth" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure initializes the graphic windows that are used to display a legend.</c>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'window_images_height', WindowImagesHeight)</l>
<l>get_dict_tuple (ExampleInternals, 'window_images_width', WindowImagesWidth)</l>
<l>get_dict_tuple (ExampleInternals, 'window_images_x', WindowImagesX)</l>
<l>get_dict_tuple (ExampleInternals, 'window_images_y', WindowImagesY)</l>
<l>dev_open_window (WindowImagesY, WindowImagesX + WindowImagesWidth + 5, WindowWidth, WindowImagesHeight, 'black', WindowHandleLegend)</l>
<l>set_display_font (WindowHandleLegend, 14, 'mono', 'true', 'false')</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend', WindowHandleLegend)</l>
<l>return ()</l>
</body>
<docu id="dev_open_example_legend_window">
<parameters>
<parameter id="ExampleInternals"/>
<parameter id="WindowWidth"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_open_example_image_window">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure initializes the graphic windows that are used to display example images.</c>
<c>* </c>
<l>WindowHeightText := 300</l>
<l>WindowWidthImage := 800</l>
<l>WindowHeightImages := 500</l>
<l>WindowBGColor := 'gray'</l>
<c>* </c>
<l>WindowYImages := WindowHeightText + 60</l>
<l>WindowXImages := 0</l>
<l>dev_open_window (WindowYImages, WindowXImages, WindowWidthImage, WindowHeightImages, WindowBGColor, WindowHandleImages)</l>
<l>set_display_font (WindowHandleImages, 16, 'mono', 'true', 'false')</l>
<l>set_dict_tuple (ExampleInternals, 'window_images', WindowHandleImages)</l>
<l>set_dict_tuple (ExampleInternals, 'window_images_width', WindowWidthImage)</l>
<l>set_dict_tuple (ExampleInternals, 'window_images_height', WindowHeightImages)</l>
<l>set_dict_tuple (ExampleInternals, 'window_images_x', WindowXImages)</l>
<l>set_dict_tuple (ExampleInternals, 'window_images_y', WindowYImages)</l>
<l>return ()</l>
</body>
<docu id="dev_open_example_image_window">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_screen_example_images">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays an overview on the different example parts.</c>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'show_example_screens', ShowExampleScreens)</l>
<l>if (not ShowExampleScreens)</l>
<l>    return ()</l>
<l>endif</l>
<l>get_dict_tuple (ExampleInternals, 'use_pretrained_model', UsePretrainedModel)</l>
<l>if (UsePretrainedModel)</l>
<c>    * Check if the pretrained model and preprocessing parameters are available.</c>
<c>    * </c>
<c>    * File name of dict containing parameters used for preprocessing.</c>
<l>    PreprocessParamFileName := 'detect_pills_preprocess_param.hdict'</l>
<l>    file_exists (PreprocessParamFileName, PreprocessParamExists)</l>
<c>    * </c>
<c>    * File name of dict containing parameters used for preprocessing.</c>
<l>    RetrainedModelFileName := 'detect_pills.hdl'</l>
<l>    file_exists (RetrainedModelFileName, ModelExists)</l>
<l>else</l>
<c>    * Check if the trained model and preprocessing parameters are available.</c>
<c>    * </c>
<c>    * Example data folder containing the outputs of the previous example series.</c>
<l>    ExampleDataDir := 'detect_pills_data'</l>
<c>    * </c>
<c>    * File name of dict containing parameters used for preprocessing.</c>
<l>    DataDirectory := ExampleDataDir + '/dldataset_pill_bag_512x320'</l>
<l>    PreprocessParamFileName := DataDirectory + '/dl_preprocess_param.hdict'</l>
<l>    file_exists (PreprocessParamFileName, PreprocessParamExists)</l>
<c>    * </c>
<c>    * File name of dict containing parameters used for preprocessing.</c>
<l>    RetrainedModelFileName := ExampleDataDir + '/best_dl_model_detection.hdl'</l>
<l>    file_exists (RetrainedModelFileName, ModelExists)</l>
<l>endif</l>
<c>* Reset the open windows for a clean display.</c>
<l>WindowImageNeeded := PreprocessParamExists and ModelExists</l>
<l>set_dict_tuple (ExampleInternals, 'window_images_needed', WindowImageNeeded)</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend_needed', false)</l>
<l>dev_display_example_reset_windows (ExampleInternals)</l>
<c>* </c>
<c>* Display explanatory text.</c>
<l>get_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>dev_set_window (WindowHandleText)</l>
<c>* </c>
<l>if (not PreprocessParamExists or not ModelExists)</l>
<l>    if (UsePretrainedModel)</l>
<l>        Text := 'The pretrained model and corresponding preprocessing'</l>
<l>        Text[|Text|] := 'parameters could not be found.'</l>
<l>        Text[|Text|] := ''</l>
<l>        Text[|Text|] := 'These files are part of a separate installer. Please'</l>
<l>        Text[|Text|] := 'refer to the Installation Guide for more information on'</l>
<l>        Text[|Text|] := 'this topic!'</l>
<l>    else</l>
<c>        * </c>
<c>        * Part 1 and/or part 2 should be run before continuing this example.</c>
<l>        Text := 'To run this example you need the output of:'</l>
<l>        if (not PreprocessParamExists)</l>
<l>            Text[|Text|] := '- \'detect_pills_deep_learning_1_prepare.hdev\''</l>
<l>        endif</l>
<l>        if (not ModelExists)</l>
<l>            Text[|Text|] := '- \'detect_pills_deep_learning_2_train.hdev\''</l>
<l>        endif</l>
<l>        Text[|Text|] := ''</l>
<l>        if (not PreprocessParamExists and not ModelExists)</l>
<l>            Text[|Text|] := 'Please run these examples first.'</l>
<l>        else</l>
<l>            Text[|Text|] := 'Please run this example first.'</l>
<l>        endif</l>
<l>        Text[|Text|:|Text| + 2] := ['Alternatively, you can set \'UsePretrainedModel := true\' ', 'at the top of the example script to use an already trained', 'model shipped with the HALCON installation.']</l>
<l>    endif</l>
<c>    * </c>
<l>    set_display_font (WindowHandleText, 20, 'mono', 'true', 'false')</l>
<l>    dev_disp_text (Text, 'window', 'top', 'left', 'red', 'box', 'true')</l>
<l>    set_display_font (WindowHandleText, 16, 'mono', 'true', 'false')</l>
<l>else</l>
<c>    * </c>
<c>    * All parts have been run before, hence continue with the example text.</c>
<l>    Text := 'We now have a trained DL object detection model.'</l>
<l>    Text[|Text|] := 'We are ready to apply it to new images.'</l>
<l>    Text[|Text|] := ''</l>
<l>    Text[|Text|] := 'These images are not part of the preprocessed dataset.'</l>
<l>    Text[|Text|] := ''</l>
<l>    Text[|Text|] := 'The images have to be preprocessed in the same way as the DLDataset,'</l>
<l>    Text[|Text|] := 'which was used for training (see example series part 1).'</l>
<l>    Text[|Text|] := ''</l>
<l>    Text[|Text|] := 'Below you see an example image.'</l>
<c>    * </c>
<l>    dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>    dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>    * </c>
<c>    * Display an example image</c>
<l>    ExampleImageFile := '/pill_bag/pill_bag_036.png'</l>
<c>    * Add example image to ExampleInternals reuse it later</c>
<l>    set_dict_tuple (ExampleInternals, 'example_image_file', ExampleImageFile)</l>
<l>    read_image (Image, ExampleImageFile)</l>
<l>    get_dict_tuple (ExampleInternals, 'window_images', WindowHandleImages)</l>
<l>    dev_set_window (WindowHandleImages)</l>
<l>    get_image_size (Image, Width, Height)</l>
<l>    dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>    dev_display (Image)</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_screen_example_images">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_screen_inference_step_1">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the second explanatory part of the inference.</c>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'show_example_screens', ShowExampleScreens)</l>
<l>if (not ShowExampleScreens)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Reset the open windows for a clean display.</c>
<l>set_dict_tuple (ExampleInternals, 'window_images_needed', true)</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend_needed', false)</l>
<l>dev_display_example_reset_windows (ExampleInternals)</l>
<c>* </c>
<c>* Display explanatory text.</c>
<l>get_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>dev_set_window (WindowHandleText)</l>
<c>* </c>
<l>Text := 'Inference steps for one image:'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := '1. Generate a DLSample for the image using'</l>
<l>Text[|Text|] := '   \'gen_dl_samples_from_images\'.'</l>
<c>* </c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>* </c>
<c>* Display example images,</c>
<l>get_dict_tuple (ExampleInternals, 'window_images', WindowHandleImages)</l>
<l>dev_set_window (WindowHandleImages)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'false')</l>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'example_image_file', ExampleImageFile)</l>
<l>read_image (ImageRaw, ExampleImageFile)</l>
<l>get_image_size (ImageRaw, Width, Height)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_display (ImageRaw)</l>
<l>dev_disp_text ('Raw image', 'window', 'top', 'left', 'black', [], [])</l>
<c>* </c>
<l>flush_buffer (WindowHandleImages)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'true')</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_screen_inference_step_1">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_screen_inference_step_2_part_2">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the second explanatory part of the inference.</c>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'show_example_screens', ShowExampleScreens)</l>
<l>if (not ShowExampleScreens)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Reset the open windows for a clean display.</c>
<l>set_dict_tuple (ExampleInternals, 'window_images_needed', true)</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend_needed', false)</l>
<l>dev_display_example_reset_windows (ExampleInternals)</l>
<c>* </c>
<c>* Display explanatory text.</c>
<l>get_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>dev_set_window (WindowHandleText)</l>
<c>* </c>
<l>Text := 'Inference steps for one image:'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := '1. Generate a DLSample for the image using'</l>
<l>Text[|Text|] := '   \'gen_dl_samples_from_images\'.'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := '2. Preprocess the image to suit the trained model'</l>
<l>Text[|Text|] := '   using \'preprocess_dl_samples\'.'</l>
<c>* </c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>* </c>
<c>* Display example images,</c>
<l>get_dict_tuple (ExampleInternals, 'window_images', WindowHandleImages)</l>
<l>dev_set_window (WindowHandleImages)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'false')</l>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'example_image_file', ExampleImageFile)</l>
<l>read_image (ImageRaw, ExampleImageFile)</l>
<l>get_image_size (ImageRaw, RawWidth, RawHeight)</l>
<l>zoom_image_size (ImageRaw, ImageZoomed, 512, 320, 'constant')</l>
<l>get_image_size (ImageZoomed, Width, Height)</l>
<l>ZoomFactor := Height / real(RawHeight)</l>
<c>* </c>
<c>* Create a loupe to see difference of resolution</c>
<l>LoupeZoom := 7.0</l>
<l>LoupeMargin := 30 * ZoomFactor</l>
<l>LoupeWindowSize := 45 * ZoomFactor</l>
<l>LoupeRow1 := 368 * ZoomFactor</l>
<l>LoupeColumn1 := 577 * ZoomFactor</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_color ('light blue')</l>
<l>dev_set_line_width (2)</l>
<c>* Prepare images for loupe</c>
<l>crop_rectangle1 (ImageZoomed, ImagePart, LoupeRow1, LoupeColumn1, LoupeRow1 + LoupeWindowSize - 1, LoupeColumn1 + LoupeWindowSize - 1)</l>
<l>zoom_image_factor (ImagePart, ImagePart2, LoupeZoom, LoupeZoom, 'nearest_neighbor')</l>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_translate (HomMat2DIdentity, Height - LoupeZoom * LoupeWindowSize - LoupeMargin, LoupeMargin, HomMat2DTranslate)</l>
<l>affine_trans_image (ImagePart2, ImageTrans, HomMat2DTranslate, 'constant', 'true')</l>
<c>* Draw loupe rectangles</c>
<l>gen_rectangle1 (Loupe1, LoupeRow1, LoupeColumn1, LoupeRow1 + LoupeWindowSize, LoupeColumn1 + LoupeWindowSize)</l>
<l>gen_rectangle1 (Loupe2, Height - LoupeZoom * LoupeWindowSize - LoupeMargin, LoupeMargin, Height - LoupeMargin - 5, LoupeZoom * LoupeWindowSize + LoupeMargin - 5)</l>
<c>* Draw loupe lines</c>
<l>set_window_param (WindowHandleImages, 'flush', 'false')</l>
<l>gen_region_line (LoupeLine1, Height - LoupeZoom * LoupeWindowSize - LoupeMargin, LoupeMargin, LoupeRow1, LoupeColumn1)</l>
<l>gen_region_line (LoupeLine2, Height - LoupeMargin - 5, LoupeZoom * LoupeWindowSize + LoupeMargin - 5, LoupeRow1 + LoupeWindowSize, LoupeColumn1 + LoupeWindowSize)</l>
<c>* </c>
<l>get_image_size (ImageZoomed, Width, Height)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_display (ImageZoomed)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'false')</l>
<l>dev_display (ImageTrans)</l>
<l>dev_display (Loupe1)</l>
<l>dev_display (Loupe2)</l>
<l>dev_display (LoupeLine1)</l>
<l>dev_display (LoupeLine2)</l>
<l>dev_disp_text ('Preprocessed image for image size 512 x 320', 'window', 'top', 'left', 'black', [], [])</l>
<c>* </c>
<l>get_string_extents (WindowHandleImages, 'test_string', _, _, _, TextHeight)</l>
<l>dev_disp_text ('Reduced resolution', 'image', Height - LoupeZoom * LoupeWindowSize - LoupeMargin - 3 * TextHeight * ZoomFactor, LoupeMargin, 'black', [], [])</l>
<c>* </c>
<l>flush_buffer (WindowHandleImages)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'true')</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_screen_inference_step_2_part_2">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_screen_inference_step_3">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the third explanatory part of the inference.</c>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'show_example_screens', ShowExampleScreens)</l>
<l>if (not ShowExampleScreens)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Reset the open windows for a clean display.</c>
<l>set_dict_tuple (ExampleInternals, 'window_images_needed', true)</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend_needed', true)</l>
<l>dev_display_example_reset_windows (ExampleInternals)</l>
<c>* </c>
<c>* Display explanatory text.</c>
<l>get_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>dev_set_window (WindowHandleText)</l>
<c>* </c>
<l>Text := 'Inference steps for one image:'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := '1. Generate a DLSample for the image using'</l>
<l>Text[|Text|] := '   \'gen_dl_samples_from_images\'.'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := '2. Preprocess the image to fit the trained model'</l>
<l>Text[|Text|] := '   using \'preprocess_dl_samples\'.'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := '3. Apply the model using \'apply_dl_model\'.'</l>
<c>* </c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>* </c>
<c>* Display example images,</c>
<l>get_dict_tuple (ExampleInternals, 'window_images', WindowHandleImages)</l>
<l>dev_set_window (WindowHandleImages)</l>
<c>* </c>
<c>* Read a tiny dataset with a single sample from the pill bag dataset.</c>
<l>create_tiny_example_dataset_with_result (DLDataset, DLResult)</l>
<c>* </c>
<c>* Display a temporary legend.</c>
<l>get_dict_tuple (ExampleInternals, 'window_legend', WindowHandleLegend)</l>
<l>dev_set_window (WindowHandleLegend)</l>
<c>* </c>
<l>create_dict (WindowHandleDict)</l>
<l>get_dict_param (ExampleInternals, 'keys', [], GenParamValue)</l>
<l>get_dict_tuple (ExampleInternals, 'window_images', WindowHandleImages)</l>
<l>dev_set_window (WindowHandleImages)</l>
<c>* To display the Text at the bottom of the image such that the image is undistorted,</c>
<c>* change size of windows.</c>
<l>get_dict_tuple (ExampleInternals, 'window_images_x', WindowImageColumn1)</l>
<l>get_dict_tuple (ExampleInternals, 'window_images_y', WindowImageRow1)</l>
<l>get_dict_tuple (ExampleInternals, 'window_images_width', WindowImageWidth)</l>
<l>get_dict_tuple (ExampleInternals, 'window_images_height', WindowImageHeight)</l>
<l>WindowImageHeight := WindowImageHeight + 39.88</l>
<l>dev_set_window_extents (WindowImageRow1, WindowImageColumn1, WindowImageWidth, WindowImageHeight)</l>
<c>* Same for legend window</c>
<l>get_window_extents (WindowHandleLegend, Row, Column, Width, Height)</l>
<l>dev_set_window (WindowHandleLegend)</l>
<l>dev_set_window_extents (WindowImageRow1, WindowImageColumn1 + WindowImageWidth + 5, 290, WindowImageHeight)</l>
<l>dev_set_window (WindowHandleImages)</l>
<c>* </c>
<l>set_dict_tuple (WindowHandleDict, 'bbox_result', [WindowHandleImages,WindowHandleLegend])</l>
<c>* </c>
<c>* Display the sample contained in tiny dataset.</c>
<l>gen_dl_samples (DLDataset, 0, 'detection', [], DLSample)</l>
<l>dev_display_dl_data (DLSample, DLResult, DLDataset, 'bbox_result', [], WindowHandleDict)</l>
<c>* </c>
<l>dev_set_window (WindowHandleImages)</l>
<l>dev_disp_text ('Output of \'apply_dl_model\'', 'window', 'top', 'left', 'black', [], [])</l>
<l>dev_set_window (WindowHandleText)</l>
<l>dev_set_window (WindowHandleLegend)</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_screen_inference_step_3">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="create_tiny_example_dataset_with_result">
<interface>
<oc>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="DLResult" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure creates a tiny dataset out of the pill bag dataset.</c>
<c>* </c>
<l>get_system ('example_dir', ExampleDir)</l>
<c>* Create DLDataset</c>
<l>create_dict (DLDataset)</l>
<l>set_dict_tuple (DLDataset, 'image_dir', ExampleDir + '/images')</l>
<l>set_dict_tuple (DLDataset, 'class_ids', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</l>
<l>set_dict_tuple (DLDataset, 'class_names', ['Omega-3', 'KMW', 'Stomach tablet', 'Ginko', 'Ginseng', 'Glucosamine', 'Cognivia', 'Capsularum I', 'Iron tablet', 'Vitamin-B'])</l>
<c>* Create Samples</c>
<l>DLSamples := []</l>
<l>create_dict (DLSample)</l>
<l>set_dict_tuple (DLSample, 'image_id', 36)</l>
<l>set_dict_tuple (DLSample, 'image_file_name', 'pill_bag/pill_bag_036.png')</l>
<l>set_dict_tuple (DLSample, 'bbox_row1', [177, 242, 247, 240, 453, 127, 465, 372])</l>
<l>set_dict_tuple (DLSample, 'bbox_col1', [692, 362, 455, 894, 436, 915, 826, 535])</l>
<l>set_dict_tuple (DLSample, 'bbox_row2', [287, 376, 458, 322, 554, 244, 561, 456])</l>
<l>set_dict_tuple (DLSample, 'bbox_col2', [933, 493, 580, 978, 672, 1033, 1037, 618])</l>
<l>set_dict_tuple (DLSample, 'bbox_label_id', [1, 3, 4, 5, 6, 7, 8, 9])</l>
<l>DLSamples := [DLSamples,DLSample]</l>
<c>* </c>
<l>set_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<c>* </c>
<c>* Create a results</c>
<l>create_dict (DLResult)</l>
<l>set_dict_tuple (DLResult, 'bbox_row1', [177, 242, 247, 240, 453, 127, 465, 372])</l>
<l>set_dict_tuple (DLResult, 'bbox_col1', [692, 362, 455, 894, 436, 915, 826, 535])</l>
<l>set_dict_tuple (DLResult, 'bbox_row2', [287, 376, 458, 322, 554, 244, 561, 456])</l>
<l>set_dict_tuple (DLResult, 'bbox_col2', [933, 493, 580, 978, 672, 1033, 1037, 618])</l>
<l>set_dict_tuple (DLResult, 'bbox_class_id', [1, 3, 4, 5, 6, 7, 8, 9])</l>
<l>set_dict_tuple (DLResult, 'bbox_confidence', [0.99871, 1.0, 1.0, 0.97492, 0.96392, 1.0, 1.0, 0.99123])</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="create_tiny_example_dataset_with_result">
<parameters>
<parameter id="DLDataset"/>
<parameter id="DLResult"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_screen_run_program">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure shows a final text before running the program.</c>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'show_example_screens', ShowExampleScreens)</l>
<l>if (not ShowExampleScreens)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Reset the open windows for a clean display.</c>
<l>set_dict_tuple (ExampleInternals, 'window_images_needed', false)</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend_needed', false)</l>
<l>dev_display_example_reset_windows (ExampleInternals)</l>
<c>* </c>
<c>* Display explanatory text.</c>
<l>get_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>dev_set_window (WindowHandleText)</l>
<c>* </c>
<l>Text := 'We will now apply the trained model from example part 2'</l>
<l>Text[|Text|] := '\'detect_pills_deep_learning_2_train.hdev\''</l>
<l>Text[|Text|] := 'to some new images using \'apply_dl_model\'.'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := 'In the consequent example application, it is checked'</l>
<l>Text[|Text|] := 'if the bags have been filled up correctly, which means:'</l>
<l>Text[|Text|] := '- The bag contains all pill types.'</l>
<l>Text[|Text|] := '- There are no duplicates in the bag.'</l>
<c>* </c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_screen_run_program">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_screen_final">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure shows the final message of the example series.</c>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'show_example_screens', ShowExampleScreens)</l>
<l>if (not ShowExampleScreens)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<l>dev_open_example_text_window (ExampleInternals)</l>
<c>* </c>
<c>* Reset the open windows for a clean display.</c>
<l>set_dict_tuple (ExampleInternals, 'window_images_needed', false)</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend_needed', false)</l>
<l>dev_display_example_reset_windows (ExampleInternals)</l>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>dev_set_window (WindowHandleText)</l>
<c>* </c>
<c>* Display instruction text.</c>
<l>Text := 'Congratulations!'</l>
<l>Text[|Text|] := 'You have finished the series of examples for DL object detection.'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := 'You can now train a DL object detection model on your own data.'</l>
<l>Text[|Text|] := ''</l>
<c>* </c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>dev_disp_text ('End of program.', 'window', 'bottom', 'right', 'black', 'box', 'true')</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_screen_final">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="get_example_inference_images">
<interface>
<ic>
<par name="ImageDir" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure creates a list of images used for this example.</c>
<c>* </c>
<l>NumSamples := 1</l>
<l>tuple_gen_const (NumSamples, '', ImageFiles)</l>
<c>* </c>
<c>* bags containing all pills.</c>
<l>ImageFilesIndices := [011] </l>
<c>*, 002, 021,001]</c>
<c>* bags containing only duplicates.</c>
<l>*ImageFilesIndices := [ImageFilesIndices,104, 100]</l>
<c>* bags containing only missing pills.</c>
<l>*ImageFilesIndices := [ImageFilesIndices,016, 024]</l>
<c>* bags containing both, duplicates and missing pills</c>
<l>*ImageFilesIndices := [ImageFilesIndices,066, 054]</l>
<c>* </c>
<l>for Index := 0 to NumSamples - 1 by 1</l>
<l>    ImageFiles[Index] := ImageDir + '/Sombre ' + ImageFilesIndices[Index]$'03' + ' .png'</l>
<l>endfor</l>
<c>* </c>
<l>tuple_shuffle (ImageFiles, ImageFiles)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="get_example_inference_images">
<parameters>
<parameter id="ImageDir"/>
<parameter id="ImageFiles"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_open_example_text_window">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>WindowWidthText := 800</l>
<l>WindowHeightText := 300</l>
<l>WindowBGColor := 'gray'</l>
<l>dev_open_window (0, 0, WindowWidthText, WindowHeightText, WindowBGColor, WindowHandleText)</l>
<l>set_display_font (WindowHandleText, 16, 'mono', 'true', 'false')</l>
<l>set_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>set_dict_tuple (ExampleInternals, 'window_text_width', WindowWidthText)</l>
<l>set_dict_tuple (ExampleInternals, 'window_text_height', WindowHeightText)</l>
<l>return ()</l>
</body>
<docu id="dev_open_example_text_window">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_close_example_windows">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure closes all example windows.</c>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'show_example_screens', ShowExampleScreens)</l>
<l>if (not ShowExampleScreens)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<l>dev_close_example_text_window (ExampleInternals)</l>
<l>dev_close_example_image_window (ExampleInternals)</l>
<l>dev_close_example_legend_window (ExampleInternals)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_close_example_windows">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_close_example_image_window">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure closes the image window.</c>
<c>* </c>
<l>try</l>
<l>    get_dict_tuple (ExampleInternals, 'window_images', WindowHandleImages)</l>
<l>    dev_set_window (WindowHandleImages)</l>
<l>    dev_close_window ()</l>
<c>    * Delete key.</c>
<l>    remove_dict_key (ExampleInternals, 'window_images')</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_close_example_image_window">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_close_example_legend_window">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure closes the legend window.</c>
<c>* </c>
<l>try</l>
<l>    get_dict_tuple (ExampleInternals, 'window_legend', WindowHandleLegend)</l>
<l>    dev_set_window (WindowHandleLegend)</l>
<l>    dev_close_window ()</l>
<c>    * Delete key.</c>
<l>    remove_dict_key (ExampleInternals, 'window_legend')</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_close_example_legend_window">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_close_example_text_window">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure closes the text window.</c>
<c>* </c>
<l>try</l>
<l>    get_dict_tuple (ExampleInternals, 'window_text', WindowHandleImages)</l>
<l>    dev_set_window (WindowHandleImages)</l>
<l>    dev_close_window ()</l>
<c>    * Delete key.</c>
<l>    remove_dict_key (ExampleInternals, 'window_text')</l>
<l>catch (Exception)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="dev_close_example_text_window">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="check_data_availability">
<interface>
<ic>
<par name="ExampleDataDir" base_type="ctrl" dimension="0"/>
<par name="PreprocessParamFileName" base_type="ctrl" dimension="0"/>
<par name="TrainedModelFileName" base_type="ctrl" dimension="0"/>
<par name="UsePretrainedModel" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure checks if all necessary files are available.</c>
<c>* </c>
<l>file_exists (ExampleDataDir, FileExists)</l>
<l>if (not FileExists)</l>
<l>    throw (ExampleDataDir + ' does not exist. Please run part 1 and 2 of example series.')</l>
<l>endif</l>
<c></c>
<l>file_exists (PreprocessParamFileName, FileExists)</l>
<l>if (not FileExists)</l>
<l>    throw (PreprocessParamFileName + ' does not exist. Please run part 1 of example series.')</l>
<l>endif</l>
<c>* </c>
<l>file_exists (TrainedModelFileName, FileExists)</l>
<l>if (not FileExists)</l>
<l>    if (UsePretrainedModel)</l>
<l>        throw (TrainedModelFileName + ' does not exist. Please run the HALCON Deep Learning installer.')</l>
<l>    else</l>
<l>        throw (TrainedModelFileName + ' does not exist. Please run part 2 of example series.')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="check_data_availability">
<parameters>
<parameter id="ExampleDataDir"/>
<parameter id="PreprocessParamFileName"/>
<parameter id="TrainedModelFileName"/>
<parameter id="UsePretrainedModel"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_screen_min_confidence">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure explains the parameter 'min_confidence'.</c>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'show_example_screens', ShowExampleScreens)</l>
<l>if (not ShowExampleScreens)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Reset the open windows for a clean display.</c>
<l>set_dict_tuple (ExampleInternals, 'window_images_needed', true)</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend_needed', false)</l>
<l>dev_display_example_reset_windows (ExampleInternals)</l>
<c>* </c>
<c>* Display explanatory text.</c>
<l>get_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>dev_set_window (WindowHandleText)</l>
<c>* </c>
<l>Text := 'Output optimization:'</l>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := 'The output of \'apply_dl_model\' can be optimized with'</l>
<l>Text[|Text|] := 'some parameters that can be set with \'set_dl_model_param\'.'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := 'To suppress result bounding boxes with a low confidence, use'</l>
<l>Text[|Text|] := 'the parameter \'min_confidence\'.'</l>
<c>* </c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>* </c>
<c>* Display example image.</c>
<l>get_dict_tuple (ExampleInternals, 'window_images', WindowHandleImages)</l>
<l>dev_set_window (WindowHandleImages)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'false')</l>
<c>* </c>
<c>* Create example image.</c>
<l>read_image (Image, 'pill_bag/pill_bag_207.png')</l>
<l>get_image_size (Image, ImageWidth, ImageHeight)</l>
<l>ImageZoomWidth := 512</l>
<l>ZoomedImageToImage := ImageZoomWidth / (1.0 * ImageWidth)</l>
<l>ImageZoomHeight := round(ImageHeight * ZoomedImageToImage)</l>
<l>zoom_image_size (Image, ImageZoomed, ImageZoomWidth, ImageZoomHeight, 'constant')</l>
<c>* </c>
<l>ImageRatio := real(ImageWidth) / real(ImageHeight)</l>
<l>Ratio := ImageWidth / (1.0 * ImageHeight)</l>
<l>CropHeight := 140</l>
<l>CropWidth := Ratio * CropHeight</l>
<l>Row1 := 17</l>
<l>Col1 := 335</l>
<l>Row2 := Row1 + CropHeight</l>
<l>Col2 := Col1 + CropWidth * 0.5</l>
<l>crop_rectangle1 (ImageZoomed, ImagePart, Row1, Col1, Row2, Col2)</l>
<c>* </c>
<l>concat_obj (ImagePart, ImagePart, ObjectsConcat)</l>
<l>tile_images (ObjectsConcat, TiledImage, 2, 'vertical')</l>
<l>get_image_size (TiledImage, Width, Height)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_display (TiledImage)</l>
<c>* </c>
<c>* Make line.</c>
<l>dev_set_color ('gray')</l>
<l>dev_set_draw ('fill')</l>
<l>gen_rectangle1 (Line, 0, Width / 2, Height, Width / 2 + 1)</l>
<c>* </c>
<c>* Create result boxes.</c>
<l>get_distinct_colors (10, false, 0, 200, ColorsRainbow)</l>
<l>tuple_inverse (ColorsRainbow, ColorsRainbow)</l>
<l>make_neighboring_colors_distinguishable (ColorsRainbow, Colors)</l>
<l>ColorGinko := Colors[3]</l>
<l>ColorCapsularumI := Colors[7]</l>
<c>* Result boxes.</c>
<l>gen_rectangle1 (BoxGinko, 30.1, 4.7, 66.2, 91.7)</l>
<l>gen_rectangle1 (BoxCapsularumI, 56.0, 37.0, 119.8, 110.9)</l>
<l>gen_rectangle1 (BoxGinko2, 30.1, 4.7 + Width / 2, 66.2, 91.7 + Width / 2)</l>
<l>gen_rectangle1 (BoxCapsularumI2, 56.0, 37.0 + Width / 2, 119.8, 110.9 + Width / 2)</l>
<c>* </c>
<c>* Generate bad box</c>
<l>gen_rectangle1 (BadBox, 40, 49, 92, 105)</l>
<c>* </c>
<c>* Draw result box.</c>
<l>dev_display (TiledImage)</l>
<l>dev_display (Line)</l>
<l>LineWidth := 2.0</l>
<l>set_window_param (WindowHandleImages, 'flush', 'false')</l>
<l>display_result_box (BoxGinko, LineWidth, ColorGinko, '4 (1.00)')</l>
<l>display_result_box (BoxCapsularumI, LineWidth, ColorCapsularumI, '8 (0.97)')</l>
<l>display_result_box (BoxGinko2, LineWidth, ColorGinko, '4 (1.00)')</l>
<l>display_result_box (BoxCapsularumI2, LineWidth, ColorCapsularumI, '8 (0.97)')</l>
<l>display_result_box (BadBox, LineWidth, ColorGinko, '4 (0.55)')</l>
<c>* </c>
<c>* Add text for image parts</c>
<l>get_window_extents (WindowHandleImages, Row, Column, WindowWidth, WindowHeight)</l>
<l>Text := 'min_confidence = 0.5 (default)'</l>
<l>get_string_extents (WindowHandleImages, Text, _, _, TextWidth, TextHeight)</l>
<l>TextCol := WindowWidth * 0.25 - TextWidth * 0.5</l>
<l>dev_disp_text (Text, 'window', WindowHeight - 2 * TextHeight, TextCol, 'black', [], [])</l>
<l>Text := 'min_confidence = 0.6'</l>
<l>get_string_extents (WindowHandleImages, Text, _, _, TextWidth, TextHeight)</l>
<l>TextCol := WindowWidth * 0.75 - TextWidth * 0.5</l>
<l>dev_disp_text (Text, 'window', WindowHeight - 2 * TextHeight, TextCol, 'black', [], [])</l>
<c>* </c>
<c>* Display.</c>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>flush_buffer (WindowHandleImages)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'true')</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_screen_min_confidence">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="display_result_box">
<interface>
<io>
<par name="Box" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="LineWidth" base_type="ctrl" dimension="0"/>
<par name="Colors" base_type="ctrl" dimension="0"/>
<par name="Text" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This helper procedure displays result bounding boxes.</c>
<c>* </c>
<c>* Draw result box.</c>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (int(LineWidth + 2))</l>
<l>dev_set_color ('black')</l>
<l>dev_display (Box)</l>
<l>dev_set_line_width (int(LineWidth))</l>
<l>dev_set_color (Colors)</l>
<l>dev_display (Box)</l>
<c>* Display text.</c>
<l>smallest_rectangle1 (Box, Row1, Column1, Row2, Column2)</l>
<l>dev_disp_text (Text, 'image', Row1, Column1, 'white', ['box_color', 'shadow', 'border_radius'], ['black', 'false', 0])</l>
<l>return ()</l>
</body>
<docu id="display_result_box">
<parameters>
<parameter id="Box"/>
<parameter id="Colors"/>
<parameter id="LineWidth"/>
<parameter id="Text"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_screen_max_overlap">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure explains the parameter 'max_overlap'.</c>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'show_example_screens', ShowExampleScreens)</l>
<l>if (not ShowExampleScreens)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Reset the open windows for a clean display.</c>
<l>set_dict_tuple (ExampleInternals, 'window_images_needed', true)</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend_needed', false)</l>
<l>dev_display_example_reset_windows (ExampleInternals)</l>
<c>* </c>
<c>* Display explanatory text.</c>
<l>get_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>dev_set_window (WindowHandleText)</l>
<c>* </c>
<l>Text := 'Output optimization:'</l>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := 'Sometimes, the network finds more overlapping bounding'</l>
<l>Text[|Text|] := 'boxes predicting the same class for the same object.'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := 'To remove boxes that overlap with the best predicted'</l>
<l>Text[|Text|] := 'box by a certain intersection over union (IoU), use'</l>
<l>Text[|Text|] := 'the parameter \'max_overlap\'.'</l>
<c>* </c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>* </c>
<c>* Display example image.</c>
<l>get_dict_tuple (ExampleInternals, 'window_images', WindowHandleImages)</l>
<l>dev_set_window (WindowHandleImages)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'false')</l>
<c>* </c>
<c>* Create example image.</c>
<l>read_image (Image, 'pill_bag/pill_bag_207.png')</l>
<l>get_image_size (Image, ImageWidth, ImageHeight)</l>
<l>ImageZoomWidth := 512</l>
<l>ZoomedImageToImage := ImageZoomWidth / (1.0 * ImageWidth)</l>
<l>ImageZoomHeight := round(ImageHeight * ZoomedImageToImage)</l>
<l>zoom_image_size (Image, ImageZoomed, ImageZoomWidth, ImageZoomHeight, 'constant')</l>
<c>* </c>
<l>ImageRatio := real(ImageWidth) / real(ImageHeight)</l>
<l>Ratio := ImageWidth / (1.0 * ImageHeight)</l>
<l>CropHeight := 140</l>
<l>CropWidth := Ratio * CropHeight</l>
<l>Row1 := 17</l>
<l>Col1 := 335</l>
<l>Row2 := Row1 + CropHeight</l>
<l>Col2 := Col1 + CropWidth * 0.5</l>
<l>crop_rectangle1 (ImageZoomed, ImagePart, Row1, Col1, Row2, Col2)</l>
<c>* </c>
<l>concat_obj (ImagePart, ImagePart, ObjectsConcat)</l>
<l>tile_images (ObjectsConcat, TiledImage, 2, 'vertical')</l>
<l>get_image_size (TiledImage, Width, Height)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_display (TiledImage)</l>
<c>* </c>
<c>* Make line.</c>
<l>dev_set_color ('gray')</l>
<l>dev_set_draw ('fill')</l>
<l>gen_rectangle1 (Line, 0, Width / 2, Height, Width / 2 + 1)</l>
<c>* </c>
<c>* Create result boxes.</c>
<l>get_distinct_colors (10, false, 0, 200, ColorsRainbow)</l>
<l>tuple_inverse (ColorsRainbow, ColorsRainbow)</l>
<l>make_neighboring_colors_distinguishable (ColorsRainbow, Colors)</l>
<l>ColorGinko := Colors[3]</l>
<l>ColorCapsularumI := Colors[7]</l>
<c>* Result boxes.</c>
<l>gen_rectangle1 (BoxGinko, 30.1, 4.7, 66.2, 91.7)</l>
<l>gen_rectangle1 (BoxCapsularumI, 56.0, 37.0, 119.8, 110.9)</l>
<l>gen_rectangle1 (BoxGinko2, 30.1, 4.7 + Width / 2, 66.2, 91.7 + Width / 2)</l>
<l>gen_rectangle1 (BoxCapsularumI2, 56.0, 37.0 + Width / 2, 119.8, 110.9 + Width / 2)</l>
<c>* </c>
<c>* Generate bad box</c>
<l>gen_rectangle1 (BadBox1, 68, 26, 101, 102)</l>
<l>gen_rectangle1 (BadBox2, 49, 63, 119, 95)</l>
<c>* </c>
<c>* Draw result box.</c>
<l>dev_display (TiledImage)</l>
<l>dev_display (Line)</l>
<l>LineWidth := 2.0</l>
<l>set_window_param (WindowHandleImages, 'flush', 'false')</l>
<l>display_result_box (BoxGinko, LineWidth, ColorGinko, '4 (1.00)')</l>
<l>display_result_box (BoxCapsularumI, LineWidth, ColorCapsularumI, '8 (0.97)')</l>
<l>display_result_box (BoxGinko2, LineWidth, ColorGinko, '4 (1.00)')</l>
<l>display_result_box (BoxCapsularumI2, LineWidth, ColorCapsularumI, '8 (0.97)')</l>
<l>display_result_box (BadBox1, LineWidth, ColorCapsularumI, '4 (0.77)')</l>
<l>display_result_box (BadBox2, LineWidth, ColorCapsularumI, '4 (0.81)')</l>
<c>* </c>
<c>* Add text for image parts</c>
<l>get_window_extents (WindowHandleImages, Row, Column, WindowWidth, WindowHeight)</l>
<l>Text := 'max_overlap = 0.5 (default)'</l>
<l>get_string_extents (WindowHandleImages, Text, _, _, TextWidth, TextHeight)</l>
<l>TextCol := WindowWidth * 0.25 - TextWidth * 0.5</l>
<l>dev_disp_text (Text, 'window', WindowHeight - 2 * TextHeight, TextCol, 'black', [], [])</l>
<l>Text := 'max_overlap = 0.4'</l>
<l>get_string_extents (WindowHandleImages, Text, _, _, TextWidth, TextHeight)</l>
<l>TextCol := WindowWidth * 0.75 - TextWidth * 0.5</l>
<l>dev_disp_text (Text, 'window', WindowHeight - 2 * TextHeight, TextCol, 'black', [], [])</l>
<c>* </c>
<c>* Display.</c>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>flush_buffer (WindowHandleImages)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'true')</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_screen_max_overlap">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_screen_max_overlap_class_agnostic">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure explains the parameter 'max_overlap_class_agnostic'.</c>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'show_example_screens', ShowExampleScreens)</l>
<l>if (not ShowExampleScreens)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Reset the open windows for a clean display.</c>
<l>set_dict_tuple (ExampleInternals, 'window_images_needed', true)</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend_needed', false)</l>
<l>dev_display_example_reset_windows (ExampleInternals)</l>
<c>* </c>
<c>* Display explanatory text.</c>
<l>get_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>dev_set_window (WindowHandleText)</l>
<c>* </c>
<l>Text := 'Output optimization:'</l>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := 'For the same object, more than one class might be'</l>
<l>Text[|Text|] := 'predicted. In this case, the network outputs several'</l>
<l>Text[|Text|] := 'bounding boxes with different classes for one object.'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := 'To suppress all overlapping bounding boxes other than'</l>
<l>Text[|Text|] := 'the one with the highest confidence,'</l>
<l>Text[|Text|] := '\'max_overlap_class_agnostic\' can be used. As default,'</l>
<l>Text[|Text|] := 'this class agnostic bounding box suppression is not performed.'</l>
<c>* </c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>* </c>
<c>* Display example image.</c>
<l>get_dict_tuple (ExampleInternals, 'window_images', WindowHandleImages)</l>
<l>dev_set_window (WindowHandleImages)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'false')</l>
<c>* </c>
<c>* Create example image.</c>
<l>read_image (Image, 'pill_bag/pill_bag_207.png')</l>
<l>get_image_size (Image, ImageWidth, ImageHeight)</l>
<l>ImageZoomWidth := 512</l>
<l>ZoomedImageToImage := ImageZoomWidth / (1.0 * ImageWidth)</l>
<l>ImageZoomHeight := round(ImageHeight * ZoomedImageToImage)</l>
<l>zoom_image_size (Image, ImageZoomed, ImageZoomWidth, ImageZoomHeight, 'constant')</l>
<c>* </c>
<l>ImageRatio := real(ImageWidth) / real(ImageHeight)</l>
<l>Ratio := ImageWidth / (1.0 * ImageHeight)</l>
<l>CropHeight := 140</l>
<l>CropWidth := Ratio * CropHeight</l>
<l>Row1 := 17</l>
<l>Col1 := 335</l>
<l>Row2 := Row1 + CropHeight</l>
<l>Col2 := Col1 + CropWidth * 0.5</l>
<l>crop_rectangle1 (ImageZoomed, ImagePart, Row1, Col1, Row2, Col2)</l>
<c>* </c>
<l>concat_obj (ImagePart, ImagePart, ObjectsConcat)</l>
<l>tile_images (ObjectsConcat, TiledImage, 2, 'vertical')</l>
<l>get_image_size (TiledImage, Width, Height)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_display (TiledImage)</l>
<c>* </c>
<c>* Make line.</c>
<l>dev_set_color ('gray')</l>
<l>dev_set_draw ('fill')</l>
<l>gen_rectangle1 (Line, 0, Width / 2, Height, Width / 2 + 1)</l>
<c>* </c>
<c>* Create result boxes.</c>
<l>get_distinct_colors (10, false, 0, 200, ColorsRainbow)</l>
<l>tuple_inverse (ColorsRainbow, ColorsRainbow)</l>
<l>make_neighboring_colors_distinguishable (ColorsRainbow, Colors)</l>
<l>ColorGinko := Colors[3]</l>
<l>ColorCapsularumI := Colors[7]</l>
<l>ColorVitaminB := Colors[9]</l>
<c>* Result boxes.</c>
<l>gen_rectangle1 (BoxGinko, 30.1, 4.7, 66.2, 91.7)</l>
<l>gen_rectangle1 (BoxCapsularumI, 56.0, 37.0, 119.8, 110.9)</l>
<l>gen_rectangle1 (BoxGinko2, 30.1, 4.7 + Width / 2, 66.2, 91.7 + Width / 2)</l>
<l>gen_rectangle1 (BoxCapsularumI2, 56.0, 37.0 + Width / 2, 119.8, 110.9 + Width / 2)</l>
<c>* </c>
<c>* Generate bad box</c>
<l>gen_rectangle1 (BadBox1, 25, 3, 61, 88)</l>
<l>gen_rectangle1 (BadBox2, 63, 36, 124, 103)</l>
<c>* </c>
<c>* Draw result box.</c>
<l>dev_display (TiledImage)</l>
<l>dev_display (Line)</l>
<l>LineWidth := 2.0</l>
<l>set_window_param (WindowHandleImages, 'flush', 'false')</l>
<l>display_result_box (BoxGinko, LineWidth, ColorGinko, '4 (1.00)')</l>
<l>display_result_box (BoxCapsularumI, LineWidth, ColorCapsularumI, '8 (0.97)')</l>
<l>display_result_box (BoxGinko2, LineWidth, ColorGinko, '4 (1.00)')</l>
<l>display_result_box (BoxCapsularumI2, LineWidth, ColorCapsularumI, '8 (0.97)')</l>
<l>display_result_box (BadBox1, LineWidth, ColorCapsularumI, '8 (0.82)')</l>
<l>display_result_box (BadBox2, LineWidth, ColorVitaminB, '9 (0.76)')</l>
<c>* </c>
<c>* Add text for image parts</c>
<l>get_window_extents (WindowHandleImages, Row, Column, WindowWidth, WindowHeight)</l>
<l>Text := 'max_overlap_class_agnostic = 1.0 (default)'</l>
<l>get_string_extents (WindowHandleImages, Text, _, _, TextWidth, TextHeight)</l>
<l>TextCol := WindowWidth * 0.25 - TextWidth * 0.5</l>
<l>dev_disp_text (Text, 'window', WindowHeight - 2 * TextHeight, TextCol, 'black', [], [])</l>
<l>Text := 'max_overlap_class_agnostic = 0.7'</l>
<l>get_string_extents (WindowHandleImages, Text, _, _, TextWidth, TextHeight)</l>
<l>TextCol := WindowWidth * 0.75 - TextWidth * 0.5</l>
<l>dev_disp_text (Text, 'window', WindowHeight - 2 * TextHeight, TextCol, 'black', [], [])</l>
<c>* </c>
<c>* Display.</c>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>flush_buffer (WindowHandleImages)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'true')</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_screen_max_overlap_class_agnostic">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="create_counting_result_text">
<interface>
<ic>
<par name="NumberDetectionsPerClass" base_type="ctrl" dimension="0"/>
<par name="ClassNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Text" base_type="ctrl" dimension="0"/>
<par name="TextColor" base_type="ctrl" dimension="0"/>
<par name="TextBoxColor" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure returns a text containing the result of the counting.</c>
<c>* </c>
<l>Text := []</l>
<l>if (max(NumberDetectionsPerClass) &gt; 1)</l>
<c>    * Get names of duplicate pills.</c>
<l>    Indices := find(NumberDetectionsPerClass [&gt;] 1,1)</l>
<l>    PillsDuplicateTuple := ClassNames[Indices]</l>
<l>    PillsDuplicateString := PillsDuplicateTuple[0]</l>
<l>    for Index := 1 to |PillsDuplicateTuple| - 1 by 1</l>
<l>        PillsDuplicateString := PillsDuplicateString + ', ' + PillsDuplicateTuple[Index]</l>
<l>    endfor</l>
<c>    * </c>
<l>    Text[|Text|] := 'Duplicate pills: ' + PillsDuplicateString</l>
<l>    TextBoxColor := 'red'</l>
<l>    TextColor := 'white'</l>
<l>endif</l>
<l>if (min(NumberDetectionsPerClass) == 0)</l>
<c>    * Get names of missing pills.</c>
<l>    Indices := find(NumberDetectionsPerClass,0)</l>
<l>    PillsMissingTuple := ClassNames[Indices]</l>
<l>    PillsMissingString := PillsMissingTuple[0]</l>
<l>    for Index := 1 to |PillsMissingTuple| - 1 by 1</l>
<l>        PillsMissingString := PillsMissingString + ', ' + PillsMissingTuple[Index]</l>
<l>    endfor</l>
<c>    * Add tab for better visualization.</c>
<l>    AddTab := ''</l>
<l>    if (Text != [])</l>
<l>        AddTab := '  '</l>
<l>    endif</l>
<l>    Text[|Text|] := 'Pills missing' + AddTab + ': ' + PillsMissingString</l>
<l>    TextBoxColor := 'red'</l>
<l>    TextColor := 'white'</l>
<l>endif</l>
<l>if (Text == [])</l>
<l>    Text[|Text|] := 'Bag is fine'</l>
<l>    TextBoxColor := 'green'</l>
<l>    TextColor := 'black'</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="create_counting_result_text">
<parameters>
<parameter id="ClassNames"/>
<parameter id="NumberDetectionsPerClass"/>
<parameter id="Text"/>
<parameter id="TextBoxColor"/>
<parameter id="TextColor"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_screen_inference_step_2_part_1">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the second explanatory part of the inference.</c>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'show_example_screens', ShowExampleScreens)</l>
<l>if (not ShowExampleScreens)</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Reset the open windows for a clean display.</c>
<l>set_dict_tuple (ExampleInternals, 'window_images_needed', true)</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend_needed', false)</l>
<l>dev_display_example_reset_windows (ExampleInternals)</l>
<c>* </c>
<c>* Display explanatory text.</c>
<l>get_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>dev_set_window (WindowHandleText)</l>
<c>* </c>
<l>Text := 'Inference steps for one image:'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := '1. Generate a DLSample for the image using'</l>
<l>Text[|Text|] := '   \'gen_dl_samples_from_images\'.'</l>
<l>Text[|Text|] := ''</l>
<l>Text[|Text|] := '2. Preprocess the image to suit the trained model'</l>
<l>Text[|Text|] := '   using \'preprocess_dl_samples\'.'</l>
<c>* </c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>* </c>
<c>* Display example images,</c>
<l>get_dict_tuple (ExampleInternals, 'window_images', WindowHandleImages)</l>
<l>dev_set_window (WindowHandleImages)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'false')</l>
<c>* </c>
<l>get_dict_tuple (ExampleInternals, 'example_image_file', ExampleImageFile)</l>
<l>read_image (ImageRaw, ExampleImageFile)</l>
<l>get_image_size (ImageRaw, Width, Height)</l>
<c>* </c>
<c>* Create a loupe to see difference of resolution</c>
<l>LoupeZoom := 7.0</l>
<l>LoupeMargin := 30</l>
<l>LoupeWindowSize := 45</l>
<l>LoupeRow1 := 368</l>
<l>LoupeColumn1 := 577</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_color ('light blue')</l>
<l>dev_set_line_width (2)</l>
<c>* Prepare images for loupe</c>
<l>crop_rectangle1 (ImageRaw, ImagePart, LoupeRow1, LoupeColumn1, LoupeRow1 + LoupeWindowSize - 1, LoupeColumn1 + LoupeWindowSize - 1)</l>
<l>zoom_image_factor (ImagePart, ImagePart2, LoupeZoom, LoupeZoom, 'nearest_neighbor')</l>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_translate (HomMat2DIdentity, Height - LoupeZoom * LoupeWindowSize - LoupeMargin, LoupeMargin, HomMat2DTranslate)</l>
<l>affine_trans_image (ImagePart2, ImageTrans, HomMat2DTranslate, 'constant', 'true')</l>
<c>* Draw loupe rectangles</c>
<l>gen_rectangle1 (Loupe1, LoupeRow1, LoupeColumn1, LoupeRow1 + LoupeWindowSize, LoupeColumn1 + LoupeWindowSize)</l>
<l>gen_rectangle1 (Loupe2, Height - LoupeZoom * LoupeWindowSize - LoupeMargin, LoupeMargin, Height - LoupeMargin - 1, LoupeZoom * LoupeWindowSize + LoupeMargin - 1)</l>
<c>* Draw loupe lines</c>
<l>set_window_param (WindowHandleImages, 'flush', 'false')</l>
<l>gen_region_line (LoupeLine1, Height - LoupeZoom * LoupeWindowSize - LoupeMargin, LoupeMargin, LoupeRow1, LoupeColumn1)</l>
<l>gen_region_line (LoupeLine2, Height - LoupeMargin - 1, LoupeZoom * LoupeWindowSize + LoupeMargin - 1, LoupeRow1 + LoupeWindowSize, LoupeColumn1 + LoupeWindowSize)</l>
<c>* </c>
<l>get_image_size (ImageRaw, Width, Height)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>dev_display (ImageRaw)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'false')</l>
<l>dev_display (ImageTrans)</l>
<l>dev_display (Loupe1)</l>
<l>dev_display (Loupe2)</l>
<l>dev_display (LoupeLine1)</l>
<l>dev_display (LoupeLine2)</l>
<l>dev_disp_text ('Raw image', 'window', 'top', 'left', 'black', [], [])</l>
<c>* </c>
<l>get_string_extents (WindowHandleImages, 'test_string', _, _, _, TextHeight)</l>
<l>dev_disp_text ('Original resolution', 'image', Height - LoupeZoom * LoupeWindowSize - LoupeMargin - 3 * TextHeight, LoupeMargin, 'black', [], [])</l>
<c>* </c>
<l>flush_buffer (WindowHandleImages)</l>
<l>set_window_param (WindowHandleImages, 'flush', 'true')</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_screen_inference_step_2_part_1">
<parameters>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="get_distinct_colors">
<interface>
<ic>
<par name="NumColors" base_type="ctrl" dimension="0"/>
<par name="Random" base_type="ctrl" dimension="0"/>
<par name="StartColor" base_type="ctrl" dimension="0"/>
<par name="EndColor" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Colors" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* We get distinct color-values first in HLS color-space.</c>
<c>* Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).</c>
<c>* </c>
<c>* Parameter checks.</c>
<c>* NumColors.</c>
<l>if (NumColors &lt; 1)</l>
<l>    throw ('NumColors should be at least 1')</l>
<l>endif</l>
<l>if (not is_int(NumColors))</l>
<l>    throw ('NumColors should be of type int')</l>
<l>endif</l>
<l>if (|NumColors| != 1)</l>
<l>    throw ('NumColors should have length 1')</l>
<l>endif</l>
<c>* Random.</c>
<l>if (Random != 0 and Random != 1)</l>
<l>    tuple_is_string (Random, IsString)</l>
<l>    if (IsString)</l>
<l>        Random := Random == 'true' or 'false'</l>
<l>    else</l>
<l>        throw ('Random should be either true or false')</l>
<l>    endif</l>
<l>endif</l>
<c>* StartColor.</c>
<l>if (|StartColor| != 1)</l>
<l>    throw ('StartColor should have length 1')</l>
<l>endif</l>
<l>if (StartColor &lt; 0 or StartColor &gt; 255)</l>
<l>    throw ('StartColor should be in the range [0, 255]')</l>
<l>endif</l>
<l>if (not is_int(StartColor))</l>
<l>    throw ('StartColor should be of type int')</l>
<l>endif</l>
<c>* EndColor.</c>
<l>if (|EndColor| != 1)</l>
<l>    throw ('EndColor should have length 1')</l>
<l>endif</l>
<l>if (EndColor &lt; 0 or EndColor &gt; 255)</l>
<l>    throw ('EndColor should be in the range [0, 255]')</l>
<l>endif</l>
<l>if (not is_int(EndColor))</l>
<l>    throw ('EndColor should be of type int')</l>
<l>endif</l>
<c>* </c>
<c>* Color generation.</c>
<l>if (StartColor &gt; EndColor)</l>
<l>    EndColor := EndColor + 255</l>
<l>endif</l>
<l>if (NumColors != 1)</l>
<l>    Hue := (StartColor + int((EndColor - StartColor) * real([0:NumColors - 1]) / real(NumColors - 1))) % 255</l>
<l>else</l>
<l>    Hue := mean([StartColor,EndColor])</l>
<l>endif</l>
<l>if (Random)</l>
<l>    Hue := Hue[sort_index(rand(NumColors))]</l>
<l>    Lightness := int((5.0 + rand(NumColors)) * 255.0 / 10.0)</l>
<l>    Saturation := int((9.0 + rand(NumColors)) * 255.0 / 10.0)</l>
<l>else</l>
<l>    Lightness := int(gen_tuple_const(NumColors,0.55) * 255.0)</l>
<l>    Saturation := int(gen_tuple_const(NumColors,0.95) * 255.0)</l>
<l>endif</l>
<c>* </c>
<c>* Write colors to a 3-channel image in order to transform easier.</c>
<l>gen_image_const (HLSImageH, 'byte', 1, NumColors)</l>
<l>gen_image_const (HLSImageL, 'byte', 1, NumColors)</l>
<l>gen_image_const (HLSImageS, 'byte', 1, NumColors)</l>
<l>get_region_points (HLSImageH, Rows, Columns)</l>
<l>set_grayval (HLSImageH, Rows, Columns, Hue)</l>
<l>set_grayval (HLSImageL, Rows, Columns, Lightness)</l>
<l>set_grayval (HLSImageS, Rows, Columns, Saturation)</l>
<c>* </c>
<c>* Convert from HLS to RGB.</c>
<l>trans_to_rgb (HLSImageH, HLSImageL, HLSImageS, ImageR, ImageG, ImageB, 'hls')</l>
<c>* </c>
<c>* Get RGB-values and transform to Hex.</c>
<l>get_grayval (ImageR, Rows, Columns, Red)</l>
<l>get_grayval (ImageG, Rows, Columns, Green)</l>
<l>get_grayval (ImageB, Rows, Columns, Blue)</l>
<l>Colors := '#' + Red$'02x' + Green$'02x' + Blue$'02x'</l>
<l>return ()</l>
<c></c>
</body>
<docu id="get_distinct_colors">
<abstract lang="en_US">Based on the HLS-colorspace, generate NumColors distinct colors.
If Random is true, the returned colors are different with each call to this procedure.
The output is a vector of NumColors [R,G,B] tuples, where the single color values are given as hex-strings.

If Random is set to true, the colors are generated randomly and they differ for each call of get_distinct_colors, except if a random seed is set.

StartColor and EndColor determine the start- and end-angle of the circle sector where the hue-values of the colors are sampled in HLS-colorspace. Both have to be integers in the range [0,255], where 0 corresponds to zero degrees and 255 corresponds to 360 degrees (the full circle). Note that for a StartColor of zero and EndColor close to 255, the first and the last of the generated colors look very similar. As a hint of 0 corresponds approximately to red, 45 to yellow, 80 to green, 130 to cyan, 160 to blue, 200 to violet, 220 to pink and 255 again to red. As 0 and 255 both correspond to the same point on the hue-color-circle, it is also possible to set a StartColor that is larger than EndColor.</abstract>
<short lang="en_US">Generates NumColors distinct colors</short>
<parameters>
<parameter id="Colors">
<default_type>string</default_type>
<description lang="en_US">Tuple of NumColors RGB color values given as hex-strings.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="EndColor">
<default_type>integer</default_type>
<default_value>255</default_value>
<description lang="en_US">Corresponds to the end-angle of the circle sector where the hue-values of the colors are sampled in HLS-color-space. Range [0, 255] corresponds to degrees of [0, 360].</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>255</value_max>
<value_min>1</value_min>
</parameter>
<parameter id="NumColors">
<default_value>NumColors</default_value>
<description lang="en_US">Number of colors to be generated.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
</parameter>
<parameter id="Random">
<default_type>string</default_type>
<default_value>false</default_value>
<description lang="en_US">If true, the colors are generated randomly and they differ for each call of get_distinct_colors, except if a random seed is set.
If false, the colors are generated deterministically.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>true</item>
<item>false</item>
</values>
</parameter>
<parameter id="StartColor">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Corresponds to he start-angle of the circle sector where the hue-values of the colors are sampled in HLS-color-space. Range [0, 255] corresponds to degrees of [0, 360].</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>254</value_max>
<value_min>0</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="make_neighboring_colors_distinguishable">
<interface>
<ic>
<par name="ColorsRainbow" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Colors" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Shuffle the input colors in a deterministic way</c>
<c>* to make adjacent colors more distinguishable.</c>
<c>* Neighboring colors from the input are distributed to every NumChunks</c>
<c>* position in the output.</c>
<c>* Depending on the number of colors, increase NumChunks.</c>
<l>NumColors := |ColorsRainbow|</l>
<l>if (NumColors &gt;= 8)</l>
<l>    NumChunks := 3</l>
<l>    if (NumColors &gt;= 40)</l>
<l>        NumChunks := 6</l>
<l>    elseif (NumColors &gt;= 20)</l>
<l>        NumChunks := 4</l>
<l>    endif</l>
<l>    Colors := gen_tuple_const(NumColors,-1)</l>
<c>    * Check if the Number of Colors is dividable by NumChunks.</c>
<l>    NumLeftOver := NumColors % NumChunks</l>
<l>    ColorsPerChunk := int(NumColors / NumChunks)</l>
<l>    StartIdx := 0</l>
<l>    for S := 0 to NumChunks - 1 by 1</l>
<l>        EndIdx := StartIdx + ColorsPerChunk - 1</l>
<l>        if (S &lt; NumLeftOver)</l>
<l>            EndIdx := EndIdx + 1</l>
<l>        endif</l>
<l>        IdxsLeft := [S:NumChunks:NumColors - 1]</l>
<l>        IdxsRight := [StartIdx:EndIdx]</l>
<l>        Colors[S:NumChunks:NumColors - 1] := ColorsRainbow[StartIdx:EndIdx]</l>
<l>        StartIdx := EndIdx + 1</l>
<l>    endfor</l>
<l>else</l>
<l>    Colors := ColorsRainbow</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="make_neighboring_colors_distinguishable">
<abstract lang="en_US">Shuffles the tuple of input colors ColorsRainbow in a deterministic way such that adjacent colors are more distinguishable.
The method only shuffles the input if the input tuple has at least eight elements.</abstract>
<short lang="en_US">shuffles the input colors in a deterministic way</short>
<parameters>
<parameter id="Colors">
<description lang="en_US">Tuple of shuffled output colors.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
</parameter>
<parameter id="ColorsRainbow">
<default_value>ColorsRainbow</default_value>
<description lang="en_US">Input colors to be shuffled</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_screen_device">
<interface>
<ic>
<par name="ExampleInternals" base_type="ctrl" dimension="0"/>
<par name="DLDevice" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays information about the used device.</c>
<c></c>
<c>* Reset the open windows for a clean display.</c>
<l>set_dict_tuple (ExampleInternals, 'window_images_needed', false)</l>
<l>set_dict_tuple (ExampleInternals, 'window_legend_needed', false)</l>
<l>dev_display_example_reset_windows (ExampleInternals)</l>
<c></c>
<c>* Display the explanatory text.</c>
<l>get_dict_tuple (ExampleInternals, 'window_text', WindowHandleText)</l>
<l>dev_set_window (WindowHandleText)</l>
<c></c>
<l>get_dl_device_param (DLDevice, 'type', DLDeviceType)</l>
<l>get_dl_device_param (DLDevice, 'name', DLDeviceName)</l>
<c></c>
<l>Text := 'This example can be run on any deep learning device.'</l>
<l>Text[|Text|] := ''</l>
<l>if (DLDeviceType != 'gpu')</l>
<l>    Text[|Text|] := 'No GPU with necessary drivers and libraries has been found.'</l>
<l>    Text[|Text|] := ''</l>
<l>endif</l>
<l>Text[|Text|] := 'This example will run the deep learning operators'</l>
<l>Text[|Text|] := 'on the following device:'</l>
<l>Text[|Text|] := 'Device type: ' + DLDeviceType</l>
<l>Text[|Text|] := 'Device name: ' + DLDeviceName</l>
<c></c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c></c>
<l>return ()</l>
</body>
<docu id="dev_display_screen_device">
<abstract lang="en_US">Display a message to mention on which device the deep learning operators will run.</abstract>
<parameters>
<parameter id="DLDevice"/>
<parameter id="ExampleInternals"/>
</parameters>
</docu>
</procedure>
<procedure name="Oui">
<interface>
<oo>
<par name="ImageBatch" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="UsePretrainedModel" base_type="ctrl" dimension="0"/>
<par name="DLDevice" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ExampleDir" base_type="ctrl" dimension="0"/>
<par name="ImageDir" base_type="ctrl" dimension="0"/>
<par name="ExampleDataDir" base_type="ctrl" dimension="0"/>
<par name="PreprocessParamFileName" base_type="ctrl" dimension="0"/>
<par name="RetrainedModelFileName" base_type="ctrl" dimension="0"/>
<par name="DataDirectory" base_type="ctrl" dimension="0"/>
<par name="BatchSizeInference" base_type="ctrl" dimension="0"/>
<par name="MinConfidence" base_type="ctrl" dimension="0"/>
<par name="MaxOverlap" base_type="ctrl" dimension="0"/>
<par name="MaxOverlapClassAgnostic" base_type="ctrl" dimension="0"/>
<par name="DLModelHandle" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
<par name="DLDataInfo" base_type="ctrl" dimension="0"/>
<par name="ClassNames" base_type="ctrl" dimension="0"/>
<par name="ClassIDs" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="BatchIndex" base_type="ctrl" dimension="0"/>
<par name="Batch" base_type="ctrl" dimension="0"/>
<par name="DLSampleBatch" base_type="ctrl" dimension="0"/>
<par name="DLResultBatch" base_type="ctrl" dimension="0"/>
<par name="SampleIndex" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="DLResult" base_type="ctrl" dimension="0"/>
<par name="DetectedClassIDs" base_type="ctrl" dimension="0"/>
<par name="NumberDetectionsPerClass" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
<par name="Text" base_type="ctrl" dimension="0"/>
<par name="TextColor" base_type="ctrl" dimension="0"/>
<par name="TextBoxColor" base_type="ctrl" dimension="0"/>
<par name="WindowHandles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *************************************************</c>
<c>* **   Set paths and parameters for inference   ***</c>
<c>* *************************************************</c>
<c>* </c>
<c>* We will demonstrate the inference on the example images.</c>
<c>* In a real application newly incoming images (not used for training or evaluation)</c>
<c>* would be used here.</c>
<c>* </c>
<c>* In this example, we read the images from file.</c>
<c>* Directory name with the images of the pill bag dataset.</c>
<l>ExampleDir:= 'C:/Users/tanguy.lebret/Documents'</l>
<l>ImageDir := ExampleDir + '/Image/sombre'</l>
<c>* </c>
<c>* Set the paths of the retrained model and the corresponding preprocessing parameters.</c>
<c>* Example data folder containing the outputs of the previous example series.</c>
<l>ExampleDataDir := 'C:/Users/tanguy.lebret/Documents/Image/Sombre/DATASET/70 échantillions.hdict'</l>
<l>if (UsePretrainedModel)</l>
<c>    * Use the pretrained model and preprocessing parameters shipping with HALCON.</c>
<l>    PreprocessParamFileName := 'model_LR_opt_dl_preprocess_params.hdict'</l>
<l>    RetrainedModelFileName := 'model_LR_opt.hdl'</l>
<l>else</l>
<c>    * File name of the dict containing parameters used for preprocessing.</c>
<c>    * Note: Adapt DataDirectory after preprocessing with another image size.</c>
<l>    DataDirectory := ExampleDataDir + '/dldataset_pill_bag_512x320'</l>
<l>    PreprocessParamFileName := DataDirectory + '/dl_preprocess_param.hdict'</l>
<c>    * File name of the finetuned object detection model.</c>
<l>    RetrainedModelFileName := ExampleDataDir + '/best_dl_model_detection.hdl'</l>
<l>endif</l>
<c>* </c>
<c>* Batch Size used during inference.</c>
<l>BatchSizeInference := 1</l>
<c>* </c>
<c>* Postprocessing parameters for the detection model.</c>
<l>MinConfidence := 0.90</l>
<l>MaxOverlap := 0.2</l>
<l>MaxOverlapClassAgnostic := 0.7</l>
<c>* </c>
<c>* ********************</c>
<c>* **   Inference   ***</c>
<c>* ********************</c>
<c>* </c>
<c>* Check if all necessary files exist.</c>
<l>check_data_availability (ExampleDataDir, PreprocessParamFileName, RetrainedModelFileName, UsePretrainedModel)</l>
<c>* </c>
<c>* Read in the retrained model.</c>
<l>read_dl_model (RetrainedModelFileName, DLModelHandle)</l>
<c>* </c>
<c>* Set the batch size.</c>
<l>set_dl_model_param (DLModelHandle, 'batch_size', BatchSizeInference)</l>
<c>* </c>
<c>* Initialize the model for inference.</c>
<l>set_dl_model_param (DLModelHandle, 'device', DLDevice)</l>
<c>* </c>
<c>* Set postprocessing parameters for model.</c>
<l>set_dl_model_param (DLModelHandle, 'min_confidence', MinConfidence)</l>
<l>set_dl_model_param (DLModelHandle, 'max_overlap', MaxOverlap)</l>
<l>set_dl_model_param (DLModelHandle, 'max_overlap_class_agnostic', MaxOverlapClassAgnostic)</l>
<c>* </c>
<c>* Get the parameters used for preprocessing.</c>
<l>read_dict ('C:/Users/tanguy.lebret/Documents/model_LR_opt_dl_preprocess_params.hdict', [], [], DLPreprocessParam)</l>
<c>* </c>
<c>* Create window dictionary for displaying results.</c>
<l>WindowHandleDict := dict{}</l>
<c>* Create dictionary with dataset parameters necessary for displaying.</c>
<l>DLDataInfo := dict{}</l>
<l>get_dl_model_param (DLModelHandle, 'class_names', ClassNames)</l>
<l>DLDataInfo.class_names := ClassNames</l>
<l>get_dl_model_param (DLModelHandle, 'class_ids', ClassIDs)</l>
<l>DLDataInfo.class_ids := ClassIDs</l>
<c>* Set generic parameters for visualization.</c>
<l>GenParam := dict{scale_windows: 1}</l>
<c>* </c>
<c>* List the files, the model should be applied to (e.g., using list_image_files).</c>
<c>* For this example, we select some images manually.</c>
<l>get_example_inference_images (ImageDir, ImageFiles)</l>
<l>ImageFiles:='D:/Tanguy-15052023/INFER/Image00000.BMP'</l>
<c>* Loop over all images in batches of size BatchSizeInference for inference.</c>
<l>for BatchIndex := 0 to floor(|ImageFiles| / real(BatchSizeInference)) - 1 by 1</l>
<c>    * </c>
<c>    * Get the paths to the images of the batch.</c>
<l>    Batch := ImageFiles[BatchIndex * BatchSizeInference:(BatchIndex + 1) * BatchSizeInference - 1]</l>
<c>    * Read the images of the batch.</c>
<l>    read_image (ImageBatch, Batch)</l>
<c>    * </c>
<c>    * Generate the DLSampleBatch.</c>
<l>    gen_dl_samples_from_images (ImageBatch, DLSampleBatch)</l>
<c>    * </c>
<c>    * Preprocess the DLSampleBatch.</c>
<l>    preprocess_dl_samples (DLSampleBatch, DLPreprocessParam)</l>
<c>    </c>
<c>    * </c>
<c>    </c>
<c>    </c>
<c>    * </c>
<c>    * Apply the DL model on the DLSampleBatch.</c>
<l>    apply_dl_model (DLModelHandle, DLSampleBatch, [], DLResultBatch)</l>
<c>    * </c>
<c>    * Postprocessing and visualization.</c>
<c>    * Loop over each sample in the batch.</c>
<l>    for SampleIndex := 0 to BatchSizeInference - 1 by 1</l>
<c>        * </c>
<c>        * Get sample and according results.</c>
<l>        DLSample := DLSampleBatch[SampleIndex]</l>
<l>        DLResult := DLResultBatch[SampleIndex]</l>
<c>        * </c>
<c>        * Count detected pills for each class.</c>
<l>        DetectedClassIDs := DLResult.bbox_class_id</l>
<l>        tuple_gen_const (|ClassIDs|, 0, NumberDetectionsPerClass)</l>
<l>        for Index := 0 to |ClassIDs| - 1 by 1</l>
<l>            NumberDetectionsPerClass[Index] := sum(DetectedClassIDs [==] ClassIDs[Index])</l>
<l>        endfor</l>
<c>        * </c>
<c>        * Create output text based on counted pills.</c>
<l>        create_counting_result_text (NumberDetectionsPerClass, ClassNames, Text, TextColor, TextBoxColor)</l>
<c>        * </c>
<c>        * Display results and text.</c>
<l>        dev_display_dl_data (DLSample, DLResult, DLDataInfo, 'bbox_result', GenParam, WindowHandleDict)</l>
<l>        WindowHandles := WindowHandleDict.bbox_result</l>
<l>        dev_set_window (WindowHandles[0])</l>
<l>        set_display_font (WindowHandles[0], 16, 'mono', 'true', 'false')</l>
<l>        dev_disp_text (Text, 'window', 'top', 'left', TextColor, ['box_color', 'shadow'], [TextBoxColor,'false'])</l>
<l>        dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>        stop ()</l>
<l>    endfor</l>
<l>endfor</l>
<l>return ()</l>
<c></c>
</body>
<docu id="Oui">
<parameters>
<parameter id="Batch"/>
<parameter id="BatchIndex"/>
<parameter id="BatchSizeInference"/>
<parameter id="ClassIDs"/>
<parameter id="ClassNames"/>
<parameter id="DLDataInfo"/>
<parameter id="DLDevice"/>
<parameter id="DLModelHandle"/>
<parameter id="DLPreprocessParam"/>
<parameter id="DLResult"/>
<parameter id="DLResultBatch"/>
<parameter id="DLSample"/>
<parameter id="DLSampleBatch"/>
<parameter id="DataDirectory"/>
<parameter id="DetectedClassIDs"/>
<parameter id="ExampleDataDir"/>
<parameter id="ExampleDir"/>
<parameter id="GenParam"/>
<parameter id="ImageBatch"/>
<parameter id="ImageDir"/>
<parameter id="ImageFiles"/>
<parameter id="Index"/>
<parameter id="MaxOverlap"/>
<parameter id="MaxOverlapClassAgnostic"/>
<parameter id="MinConfidence"/>
<parameter id="NumberDetectionsPerClass"/>
<parameter id="PreprocessParamFileName"/>
<parameter id="RetrainedModelFileName"/>
<parameter id="SampleIndex"/>
<parameter id="Text"/>
<parameter id="TextBoxColor"/>
<parameter id="TextColor"/>
<parameter id="UsePretrainedModel"/>
<parameter id="WindowHandleDict"/>
<parameter id="WindowHandles"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_update_off">
<interface/>
<body>
<c>* This procedure sets different update settings to 'off'.</c>
<c>* This is useful to get the best performance and reduce overhead.</c>
<c>* </c>
<l>dev_update_pc ('off')</l>
<l>dev_update_var ('off')</l>
<l>dev_update_window ('off')</l>
<l>return ()</l>
</body>
<docu id="dev_update_off">
<abstract lang="en_US">This procedure sets the parameter ```DisplayMode``` of &lt;op:dev_update_pc&gt;, &lt;op:dev_update_var&gt; and &lt;op:dev_update_window&gt; to *'off'*.</abstract>
<alternatives>
<item>dev_update_pc</item>
<item>dev_update_var</item>
<item>dev_update_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_update_off ()
* do something
dev_update_on ()</example>
<keywords lang="de_DE">
<item>Aktualisierungsmodus setzen</item>
</keywords>
<keywords lang="en_US">
<item>set update mode</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_update_on</item>
</see_also>
<short lang="en_US">Switch dev_update_pc, dev_update_var, and dev_update_window to 'off'.</short>
<parameters/>
</docu>
</procedure>
<procedure name="dev_close_window_dict">
<interface>
<ic>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure closes all window handles</c>
<c>* that are contained in the dictionary WindowHandleDict.</c>
<c>* </c>
<l>get_dict_param (WindowHandleDict, 'keys', [], WindowHandleKeys)</l>
<l>for Index := 0 to |WindowHandleKeys| - 1 by 1</l>
<l>    try</l>
<l>        get_dict_tuple (WindowHandleDict, WindowHandleKeys[Index], WindowHandles)</l>
<l>    catch (Exception)</l>
<l>        continue</l>
<l>    endtry</l>
<l>    RemovedWindowIndices := []</l>
<l>    for WindowHandleIndex := 0 to |WindowHandles| - 1 by 1</l>
<c>        * Not every entry has to be a window handle, therefore use try-catch.</c>
<l>        try</l>
<c>            * Call set_window_param to check if the handle is a window handle.</c>
<l>            set_window_param (WindowHandles[WindowHandleIndex], 'flush', 'true')</l>
<l>            dev_set_window (WindowHandles[WindowHandleIndex])</l>
<l>            dev_close_window ()</l>
<l>            RemovedWindowIndices := [RemovedWindowIndices,WindowHandleIndex]</l>
<l>        catch (Exception)</l>
<l>        endtry</l>
<l>    endfor</l>
<l>    tuple_remove (WindowHandles, RemovedWindowIndices, WindowHandles)</l>
<c>    * If some entries remained, set reduced tuple. Otherwise, remove whole key entry.</c>
<l>    if (|WindowHandles| &gt; 0)</l>
<l>        set_dict_tuple (WindowHandleDict, WindowHandleKeys[Index], WindowHandles)</l>
<l>    else</l>
<l>        remove_dict_key (WindowHandleDict, WindowHandleKeys[Index])</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_close_window_dict">
<abstract lang="en_US">This procedure closes all windows whose handle is contained in the dictionary WindowHandleDict and removes the entries in the dictionary.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Close all window handles contained in a dictionary.</short>
<parameters>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<default_value>WindowHandleDict</default_value>
<description lang="en_US">Dictionary containing window handles.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="set_display_font">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Size" base_type="ctrl" dimension="0"/>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="Bold" base_type="ctrl" dimension="0"/>
<par name="Slant" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure sets the text font of the current window with</c>
<c>* the specified attributes.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The graphics window for which the font will be set</c>
<c>* Size: The font size. If Size=-1, the default of 16 is used.</c>
<c>* Bold: If set to 'true', a bold font is used</c>
<c>* Slant: If set to 'true', a slanted font is used</c>
<c>* </c>
<l>get_system ('operating_system', OS)</l>
<l>if (Size == [] or Size == -1)</l>
<l>    Size := 16</l>
<l>endif</l>
<l>if (OS{0:2} == 'Win')</l>
<c>    * Restore previous behavior</c>
<l>    Size := int(1.13677 * Size)</l>
<l>else</l>
<l>    Size := int(Size)</l>
<l>endif</l>
<l>if (Font == 'Courier')</l>
<l>    Fonts := ['Courier', 'Courier 10 Pitch', 'Courier New', 'CourierNew', 'Liberation Mono']</l>
<l>elseif (Font == 'mono')</l>
<l>    Fonts := ['Consolas', 'Menlo', 'Courier', 'Courier 10 Pitch', 'FreeMono', 'Liberation Mono']</l>
<l>elseif (Font == 'sans')</l>
<l>    Fonts := ['Luxi Sans', 'DejaVu Sans', 'FreeSans', 'Arial', 'Liberation Sans']</l>
<l>elseif (Font == 'serif')</l>
<l>    Fonts := ['Times New Roman', 'Luxi Serif', 'DejaVu Serif', 'FreeSerif', 'Utopia', 'Liberation Serif']</l>
<l>else</l>
<l>    Fonts := Font</l>
<l>endif</l>
<l>Style := ''</l>
<l>if (Bold == 'true')</l>
<l>    Style := Style + 'Bold'</l>
<l>elseif (Bold != 'false')</l>
<l>    Exception := 'Wrong value of control parameter Bold'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<l>if (Slant == 'true')</l>
<l>    Style := Style + 'Italic'</l>
<l>elseif (Slant != 'false')</l>
<l>    Exception := 'Wrong value of control parameter Slant'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<l>if (Style == '')</l>
<l>    Style := 'Normal'</l>
<l>endif</l>
<l>query_font (WindowHandle, AvailableFonts)</l>
<l>Font := ''</l>
<l>for Fdx := 0 to |Fonts| - 1 by 1</l>
<l>    Indices := find(AvailableFonts,Fonts[Fdx])</l>
<l>    if (|Indices| &gt; 0)</l>
<l>        if (Indices[0] &gt;= 0)</l>
<l>            Font := Fonts[Fdx]</l>
<l>            break</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>if (Font == '')</l>
<l>    throw ('Wrong value of control parameter Font')</l>
<l>endif</l>
<l>Font := Font + '-' + Style + '-' + Size</l>
<l>set_font (WindowHandle, Font)</l>
<l>return ()</l>
</body>
<docu id="set_display_font">
<abstract lang="en_US">This procedure sets the text font of the current window with the specified attributes Size, Bold and Slant. 
As font, the font name or one of the strings *'mono'*, *'sans'*, *'serif'* can be used.</abstract>
<alternatives>
<item>set_font</item>
</alternatives>
<attention lang="en_US">For *'mono'*, *'sans'*, and *'serif'*, it is assumed that at least one of the following fonts is installed on the system:

*'mono'*: 'Consolas'*, *'Menlo'*, *'Courier'*, *'Courier 10 Pitch'*, *'FreeMono'*\
*'sans'*: *'Luxi Sans'*, *'DejaVu Sans'*, *'FreeSans'*, *'Arial'*\
*'serif'*: *'Times New Roman'*, *'Luxi Serif'*, *'DejaVu Serif'*, *'FreeSerif'*, *'Utopia'*</attention>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window_fit_image(Image,0 , 0, 400, 400, WindowHandle)
set_display_font(WindowHandle, 16, 'mono', 'true', 'false')
disp_text (WindowHandle,'Hello World!', 'window', 10, 10, 'black', [], [])</example>
<keywords lang="de_DE">
<item>Schriftart (Font) setzen</item>
</keywords>
<keywords lang="en_US">
<item>set font</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>open_window</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
</predecessor>
<see_also>
<item>set_font</item>
</see_also>
<short>Set font independent of OS</short>
<short lang="en_US">Set font independent of OS</short>
<successor>
<item>disp_text</item>
<item>disp_continue_message</item>
<item>set_tposition</item>
<item>write_string</item>
</successor>
<parameters>
<parameter id="Bold">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', a bold font is used</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="Font">
<default_type>string</default_type>
<default_value>'mono'</default_value>
<description lang="en_US">The font name. Either 'mono', 'sans',  'serif' or a specific font name can be used. 'mono' will be mapped to 'Courier New' on Windows, to 'courier' on Linux, and to 'Menlo' on OS X. 'sans' will be mapped to 'Arial' on Windows and OS X, and to 'helvetica' on Linux. 'serif' will be mapped to 'Times New Roman' on Windows and OS X, and to 'times' on Linux.</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'mono'</item>
<item>'sans'</item>
<item>'serif'</item>
</values>
</parameter>
<parameter id="Size">
<default_type>integer</default_type>
<default_value>16</default_value>
<description lang="en_US">The font size on Windows systems. If Size=-1, the default of 16 is used.
On Linux systems, ALL values are multiplied with 1.25 and then mapped to [11, 14, 17, 20, 25, 34].</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>[9, 11, 14, 16, 20, 27]</item>
</values>
</parameter>
<parameter id="Slant">
<default_type>string</default_type>
<default_value>'false'</default_value>
<description lang="en_US">If set to 'true', a slanted font is used</description>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the window, where the font will be set</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_dl_samples">
<interface>
<ic>
<par name="DLDataset" base_type="ctrl" dimension="0"/>
<par name="SampleIndices" base_type="ctrl" dimension="0"/>
<par name="RestrictKeysDLSample" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DLSampleBatch" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure creates DLSampleBatch, a tuple of DLSample dictionaries, with</c>
<c>* the image data for each DLDataset sample, that was selected through SampleIndices.</c>
<c>* The keys to be transferred can be restricted using RestrictKeysDLSample,</c>
<c>* which is switched off ('off') by default.</c>
<c>* The procedure returns all generated DLSample dictionaries in the tuple</c>
<c>* DLSampleBatch.</c>
<c>* Setting the GenParam 'ignore_missing_labels' controls whether an error is thrown,</c>
<c>* if no ground truth annotation information is available for a given image.</c>
<c>* </c>
<c>* Get the image directory.</c>
<l>get_dict_tuple (DLDataset, 'image_dir', ImageDir)</l>
<c>* </c>
<c>* Get the samples from the DLDataset.</c>
<l>get_dict_tuple (DLDataset, 'samples', DLSamples)</l>
<c>* </c>
<c>* Check the input values.</c>
<c>* </c>
<c>* Check that the given indices are valid.</c>
<l>tuple_min (SampleIndices, MinIndex)</l>
<l>tuple_max (SampleIndices, MaxIndex)</l>
<l>if ((MinIndex &lt; 0) or (MaxIndex &gt; (|DLSamples| - 1)))</l>
<l>    throw ('The given SampleIndices are not within the range of available samples in DLDataset.')</l>
<l>endif</l>
<c>* </c>
<c>* Check if the given method is valid.</c>
<l>if (|RestrictKeysDLSample| == 1)</l>
<l>    if (max(find(['anomaly_detection', 'classification', 'detection', 'gc_anomaly_detection', 'ocr_recognition', 'segmentation', 'image_only', 'off'],RestrictKeysDLSample)) == -1)</l>
<l>        throw ('Unknown RestrictKeysDLSample : ' + RestrictKeysDLSample)</l>
<l>    endif</l>
<l>else</l>
<l>    throw ('RestrictKeysDLSample must be specified by one string.')</l>
<l>endif</l>
<c>* </c>
<c>* Generic Parameters.</c>
<c>* Set default values.</c>
<l>InstanceType := 'rectangle1'</l>
<c>* For missing labels an error is thrown.</c>
<l>if (RestrictKeysDLSample == 'off')</l>
<l>    IgnoreMissing := true</l>
<l>else</l>
<l>    IgnoreMissing := false</l>
<l>endif</l>
<c>* </c>
<c>* Transfer generic parameters.</c>
<l>if (GenParam != [])</l>
<l>    get_dict_param (GenParam, 'keys', [], GenParamName)</l>
<l>    for IndexGenParam := 0 to |GenParamName| - 1 by 1</l>
<l>        if (GenParamName[IndexGenParam] == 'ignore_missing_labels')</l>
<l>            get_dict_tuple (GenParam, 'ignore_missing_labels', IgnoreMissing)</l>
<l>            if (not (IgnoreMissing == 1 or IgnoreMissing == 0))</l>
<l>                throw ('The GenParam ignore_missing_labels must be true or false.')</l>
<l>            endif</l>
<l>        elseif (GenParamName[IndexGenParam] == 'instance_type')</l>
<l>            if (max(find(['detection', 'off'],RestrictKeysDLSample)) == -1)</l>
<l>                throw ('The GenParam instance_type can only be set for RestrictKeysDLSample detection or off.')</l>
<l>            endif</l>
<l>            get_dict_tuple (GenParam, 'instance_type', InstanceType)</l>
<l>            if (max(find(['rectangle1', 'rectangle2', 'mask'],InstanceType)) == -1)</l>
<l>                throw ('The GenParam instance_type must be either \'rectangle1\', \'rectangle2\' or \'mask\'.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('Unknown GenParam key : ' + GenParamName[IndexGenParam])</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Get the samples to be processed.</c>
<l>DLSamplesProc := DLSamples[SampleIndices]</l>
<c>* </c>
<c>* Initialize the tuple for collection the DLSample dictionaries.</c>
<l>DLSampleBatch := gen_tuple_const(|SampleIndices|,HNULL)</l>
<c>* </c>
<c>* Set the BboxKeyList according to the InstanceType.</c>
<l>Rect1BboxKeyList := ['bbox_col1', 'bbox_row1', 'bbox_col2', 'bbox_row2']</l>
<l>Rect2BboxKeyList := ['bbox_row', 'bbox_col', 'bbox_length1', 'bbox_length2', 'bbox_phi']</l>
<l>if (max(find(['detection', 'off'],RestrictKeysDLSample)) != -1)</l>
<l>    BboxKeyList := Rect1BboxKeyList</l>
<l>    if (InstanceType == 'rectangle2')</l>
<l>        BboxKeyList := Rect2BboxKeyList</l>
<l>    elseif (InstanceType == 'mask')</l>
<c>        * Check in the first sample if rectangle2-coordinates are present.</c>
<l>        get_dict_param (DLSamplesProc[0], 'key_exists', Rect2BboxKeyList, KeysExist)</l>
<l>        if (sum(KeysExist) == |Rect2BboxKeyList|)</l>
<l>            BboxKeyList := Rect2BboxKeyList</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* Avoid multiple reads of the same file in adjacent samples,</c>
<c>* we store the last used file name.</c>
<c>* This is most relevant in case of ocr recognition where multiple samples are given on a single image.</c>
<l>LastReadFileName := ''</l>
<c>* Loop over all selected samples and create a DLSample dictionary</c>
<c>* for each dictionary in the DLDataset samples.</c>
<l>for ImageIndex := 0 to |SampleIndices| - 1 by 1</l>
<c>    * </c>
<c>    * Store the sample which is processed.</c>
<l>    DLSampleProc := DLSamplesProc[ImageIndex]</l>
<c>    * </c>
<c>    * Create the DLSample dictionary</c>
<l>    create_dict (DLSample)</l>
<c>    * </c>
<c>    * Set the image key.</c>
<l>    get_dict_tuple (DLSampleProc, 'image_id', ImageID)</l>
<l>    set_dict_tuple (DLSample, 'image_id', ImageID)</l>
<c>    * </c>
<c>    * Read image.</c>
<c>    * The relative file path of the image is specified in image_name.</c>
<l>    get_dict_tuple (DLSampleProc, 'image_file_name', ImageName)</l>
<c>    * </c>
<l>    if (strlen(ImageDir) == 0)</l>
<l>        FileName := ImageName</l>
<l>    else</l>
<l>        FileName := ImageDir + '/' + ImageName</l>
<l>    endif</l>
<l>    try</l>
<l>        if (LastReadFileName != FileName)</l>
<l>            read_image (ImageRaw, FileName)</l>
<l>            LastReadFileName := FileName</l>
<l>        endif</l>
<c>        * Insert image into dictionary.</c>
<l>        set_dict_object (ImageRaw, DLSample, 'image')</l>
<l>    catch (Exception)</l>
<l>        throw ('Error for reading/setting image ' + FileName + ' with ID ' + ImageID + ' : Error code ' + Exception[0])</l>
<l>    endtry</l>
<c>    * </c>
<c>    * Read specific data.</c>
<c>    * </c>
<l>    if (RestrictKeysDLSample != 'image_only')</l>
<c>        * </c>
<c>        * Transfer anomaly detection or</c>
<c>        * Global Context Anomaly Detection relevant data.</c>
<l>        if (max(find(['anomaly_detection', 'gc_anomaly_detection', 'off'],RestrictKeysDLSample)) != -1)</l>
<c>            * Check the existence of the label key.</c>
<l>            get_dict_param (DLSampleProc, 'key_exists', 'anomaly_label', AnomalyLabelExists)</l>
<l>            if (AnomalyLabelExists)</l>
<c>                * Get the image label.</c>
<l>                get_dict_tuple (DLSampleProc, 'anomaly_label', AnomalyLabel)</l>
<c>                * Check the existence of the anomaly file name key. If not found it is just ignored.</c>
<l>                get_dict_param (DLSampleProc, 'key_exists', 'anomaly_file_name', AnomalyFileNameExists)</l>
<l>                if (AnomalyFileNameExists)</l>
<c>                    * Get the ground truth anomaly directory.</c>
<l>                    get_dict_tuple (DLDataset, 'anomaly_dir', AnomalyDir)</l>
<c>                    * Get the image file name.</c>
<l>                    get_dict_tuple (DLSampleProc, 'anomaly_file_name', AnomalyFileName)</l>
<c>                    * Read the ground truth anomaly image.</c>
<l>                    try</l>
<l>                        read_image (ImageAnomaly, AnomalyDir + '/' + AnomalyFileName)</l>
<l>                    catch (ExceptionImageAnomaly)</l>
<c>                        * If the file is not an image, try to read the ground truth anomaly region.</c>
<c>                        * Then, convert this region to a ground truth anomaly image.</c>
<l>                        try</l>
<l>                            read_region (RegionAnomaly, AnomalyDir + '/' + AnomalyFileName)</l>
<l>                        catch (ExceptionRegionAnomaly)</l>
<l>                            throw ('Error: Could not read the anomaly ground truth information of image_id ' + ImageID + ' : Error code ' + ExceptionImageAnomaly[0])</l>
<l>                        endtry</l>
<l>                        get_image_size (ImageRaw, Width, Height)</l>
<l>                        gen_image_const (ImageAnomaly, 'byte', Width, Height)</l>
<l>                        overpaint_region (ImageAnomaly, ImageAnomaly, 0, 'fill')</l>
<l>                        overpaint_region (ImageAnomaly, RegionAnomaly, 1, 'fill')</l>
<l>                    endtry</l>
<c>                    * Insert anomaly image into DLSample dictionary.</c>
<l>                    set_dict_object (ImageAnomaly, DLSample, 'anomaly_ground_truth')</l>
<l>                endif</l>
<c>                * </c>
<c>                * Insert anomaly label into DLSample dictionary.</c>
<l>                set_dict_tuple (DLSample, 'anomaly_label', AnomalyLabel)</l>
<c>                * Insert anomaly label id into DLSample dictionary.</c>
<l>                if (AnomalyLabel == 'nok')</l>
<l>                    set_dict_tuple (DLSample, 'anomaly_label_id', 1)</l>
<l>                else</l>
<l>                    set_dict_tuple (DLSample, 'anomaly_label_id', 0)</l>
<l>                endif</l>
<l>            elseif (not AnomalyLabelExists and not IgnoreMissing)</l>
<l>                throw ('For image_id ' + ImageID + ' the key \'anomaly_label\' is missing. Missing keys can be ignored using the GenParam ignore_missing_labels.')</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<c>        * Transfer classification relevant data.</c>
<l>        if (max(find(['classification', 'off'],RestrictKeysDLSample)) != -1)</l>
<c>            * Check the existence of the required key.</c>
<l>            get_dict_param (DLSampleProc, 'key_exists', 'image_label_id', ImageLabelIdExists)</l>
<l>            if (ImageLabelIdExists)</l>
<c>                * Transfer the image label.</c>
<l>                get_dict_tuple (DLSampleProc, 'image_label_id', ImageLabelID)</l>
<l>                set_dict_tuple (DLSample, 'image_label_id', ImageLabelID)</l>
<l>            elseif (not ImageLabelIdExists and not IgnoreMissing)</l>
<l>                throw ('For image_id ' + ImageID + ' the key \'image_label_id\' is missing. Missing keys can be ignored using the GenParam ignore_missing_labels.')</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<c>        * Transfer detection relevant data.</c>
<l>        if (max(find(['detection', 'off'],RestrictKeysDLSample)) != -1)</l>
<c>            * Check the existence of the required key.</c>
<l>            get_dict_param (DLSampleProc, 'key_exists', 'bbox_label_id', BboxExists)</l>
<l>            if (BboxExists)</l>
<c>                * Transfer the bounding box labels.</c>
<l>                get_dict_tuple (DLSampleProc, 'bbox_label_id', BboxLabels)</l>
<l>                set_dict_tuple (DLSample, 'bbox_label_id', BboxLabels)</l>
<l>                if (InstanceType == 'mask')</l>
<c>                    * Transfer the instance segmentation masks if available.</c>
<l>                    get_dict_param (DLSampleProc, 'key_exists', 'mask', KeyExists)</l>
<l>                    if (not KeyExists)</l>
<l>                        gen_empty_obj (Object)</l>
<l>                        for MIdx := 1 to |BboxLabels| by 1</l>
<l>                            gen_empty_region (EmptyRegion)</l>
<l>                            concat_obj (Object, EmptyRegion, Object)</l>
<l>                        endfor</l>
<l>                    else</l>
<l>                        get_dict_object (Object, DLSampleProc, 'mask')</l>
<l>                    endif</l>
<l>                    set_dict_object (Object, DLSample, 'mask')</l>
<l>                endif</l>
<c>                * Transfer the bounding box coordinates.</c>
<l>                get_dict_param (DLSampleProc, 'key_exists', BboxKeyList, KeysExist)</l>
<l>                if (sum(KeysExist) != |KeysExist| and not IgnoreMissing)</l>
<l>                    MissingKeyIndices := find(KeysExist [==] 0,1)</l>
<l>                    throw ('For image_id ' + ImageID + ', an error has occurred when transferring the key ' + BboxKeyList[MissingKeyIndices])</l>
<l>                else</l>
<l>                    for IndexParam := 0 to |BboxKeyList| - 1 by 1</l>
<l>                        get_dict_tuple (DLSampleProc, BboxKeyList[IndexParam], BboxCoord)</l>
<l>                        set_dict_tuple (DLSample, BboxKeyList[IndexParam], BboxCoord)</l>
<l>                    endfor</l>
<l>                endif</l>
<l>            elseif (not IgnoreMissing)</l>
<l>                throw ('For image_id ' + ImageID + ' there is no key bbox_label_id. Missing keys can be ignored using the GenParam ignore_missing_labels.')</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<c>        * Transfer segmentation relevant data.</c>
<l>        if (max(find(['segmentation', 'off'],RestrictKeysDLSample)) != -1)</l>
<c>            * Check the existence of the required keys.</c>
<l>            get_dict_param (DLSampleProc, 'key_exists', 'segmentation_file_name', SegKeyExists)</l>
<l>            if (SegKeyExists)</l>
<c>                * Get the ground truth segmentation directory.</c>
<l>                get_dict_tuple (DLDataset, 'segmentation_dir', SegmentationDir)</l>
<c>                * Get the image file name.</c>
<l>                get_dict_tuple (DLSampleProc, 'segmentation_file_name', SegmentationName)</l>
<c>                * Read the ground truth segmentation image.</c>
<l>                try</l>
<l>                    read_image (ImageSegmentation, SegmentationDir + '/' + SegmentationName)</l>
<l>                catch (ExceptionSegmentation)</l>
<l>                    throw ('Error for reading segmentation file of image_id ' + ImageID + ' : Error code ' + ExceptionSegmentation[0])</l>
<l>                endtry</l>
<c>                * Insert image into DLSample dictionary.</c>
<l>                set_dict_object (ImageSegmentation, DLSample, 'segmentation_image')</l>
<l>            elseif (not IgnoreMissing)</l>
<l>                throw ('For image_id ' + ImageID + ' there is no key segmentation_file_name. Missing keys can be ignored using the GenParam ignore_missing_labels.')</l>
<l>            endif</l>
<l>        endif</l>
<c>        * Transfer ocr_recognition relevant data.</c>
<l>        if (max(find(['ocr_recognition', 'off'],RestrictKeysDLSample)) != -1)</l>
<l>            get_dict_param (DLSampleProc, 'key_exists', 'word', WordKeyExists)</l>
<l>            if (WordKeyExists)</l>
<c>                * Check if a rectangle2 bounding box exists.</c>
<l>                get_dict_param (DLSampleProc, 'key_exists', ['bbox_row', 'bbox_col', 'bbox_phi', 'bbox_length1', 'bbox_length2'], WordBboxExists)</l>
<l>                WordBboxExists := sum(WordBboxExists) == |WordBboxExists|</l>
<c>                * Reduce the image to the word bounding box.</c>
<l>                if (WordBboxExists)</l>
<l>                    crop_rectangle2 (ImageRaw, DLSample.image, DLSampleProc.bbox_row, DLSampleProc.bbox_col, DLSampleProc.bbox_phi, DLSampleProc.bbox_length1, DLSampleProc.bbox_length2, 'true', 'constant')</l>
<l>                endif</l>
<l>                DLSample.word := DLSampleProc.word</l>
<l>            elseif (not IgnoreMissing)</l>
<l>                throw ('For image_id ' + ImageID + ' there is no key word. Missing keys can be ignored using the GenParam ignore_missing_labels.')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Collect all data dictionaries of all processed indices.</c>
<l>    DLSampleBatch[ImageIndex] := DLSample</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_dl_samples">
<abstract lang="en_US">This procedure returns the dictionaries `DLSample` for samples specified over SampleIndices of the dictionary DLDataset.
Thereby SampleIndices is an index or a tuple of indices.

RestrictKeysDLSample determines, which set of keys is to be processed.

For every selected sample, a dictionary `DLSample` is created. Its entries depend on the model type.

Model of all types `DLSample` comprises the following (initial) keys:
- `'image'`: The image.
- `'image_id'`: A unique image identifier given through DLDataset.

Models of type *'anomaly_detection'* or *'gc_anomaly_detection'* `DLSample` comprises the following (initial) keys:
- `'anomaly_label'`: Label indicating a sample containing an anomaly.
- `'anomaly_label_id'`: ID for the given class of the sample.
- `'anomaly_ground_truth'`: Image with anomaly region.

Models of type *'classification'* `DLSample` comprises the following (initial) keys:
- `'image_label_id'`: ID for the given class of the image.

Models of type *'detection'* `DLSample` comprises the following (initial) keys:
- `'bbox_label_id'` (bounding box label IDs)
- Bounding box parameter for instance type *'rectangle1'*:
   - `'bbox_col1'`: Bounding box parameter: upper left corner, column coordinate.
   - `'bbox_row1'`: Bounding box parameter: upper left corner, row coordinate.
   - `'bbox_col2'`: Bounding box parameter: lower right corner, column coordinate.
   - `'bbox_row2'`: Bounding box parameter: lower right corner, row coordinate.
- Bounding box parameter for instance type *'rectangle2'*:
   - `'bbox_row'`: Bounding box parameter: center point, row coordinate.
   - `'bbox_col'`: Bounding box parameter: center point, column coordinate.
   - `'bbox_phi'`: Bounding box parameter: angle phi.
   - `'bbox_length1'`: Bounding box parameter: half length of edge 1.
   - `'bbox_length2'`: Bounding box parameter: half length of edge 2.

   For the bounding boxes, pixel centered, subpixel accurate coordinates are used.

Models of type *'segmentation'* `DLSample` comprises the following (initial) keys:
- `'segmentation_image'`: The segmentation annotation image.


The parameter RestrictKeysDLSample restricts the set of keys to be processed from the DLDataset sample information to generate the `DLSample` keys.&lt;br/&gt;
It can contain one of the following string values:
- *'off'* (default): All available keys are transferred.
- *'anomaly_detection'*: General and anomaly detection entries are created in DLSample.
- *'classification'*: General and classification entries are created in DLSample.
- *'detection'*: General and detection entries are created in DLSample.
- *'gc_anomaly_detection'*: General and Global Context Anomaly Detection entries are created in DLSample.
- *'segmentation'*: General and segmentation entries are created in DLSample.
- *'image_only'*: Only general entries are created.


GenParam is a dictionary, which can have the following key:
- `'ignore_missing_labels'`: Controls whether missing label keys lead to errors (*'false'*) or not (*'true'*).&lt;br/&gt;
   *Default*: *'true'* if RestrictKeysDLSample has a value *'off'*, otherwise it is *'false'*.
- `'instance_type'`: Specifies for which model instance type the data is prepared.&lt;br/&gt;
   Only applicable for models of type *'detection'*.&lt;br/&gt;
   Supported values:
   - *'rectangle1'* (default)
   - *'rectangle2'*
   - *'mask'*</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Return the DLSample dictionaries for given sample indices of a DLDataset.</short>
<parameters>
<parameter id="DLDataset">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the used dataset and its information.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSampleBatch">
<default_type>integer</default_type>
<description lang="en_US">Tuple of DLSample dictionaries.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary containing the generic parameter. The default is [], in this case default values are used.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RestrictKeysDLSample">
<default_type>string</default_type>
<default_value>'off'</default_value>
<description lang="en_US">A string restricting the set of keys of the sample information, which are to be processed to generate the dictionary DLSample.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'off'</item>
<item>'anomaly_detection'</item>
<item>'classification'</item>
<item>'detection'</item>
<item>'segmentation'</item>
<item>'image_only'</item>
</values>
</parameter>
<parameter id="SampleIndices">
<default_type>integer</default_type>
<description lang="en_US">Tuple with indices of the samples from DLDataset, for which the dictionaries DLSample are to be returned.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_dl_data">
<interface>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="DLResult" base_type="ctrl" dimension="0"/>
<par name="DLDatasetInfo" base_type="ctrl" dimension="0"/>
<par name="KeysForDisplay" base_type="ctrl" dimension="0"/>
<par name="GenParam" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure displays the content of the provided DLSample and/or DLResult</c>
<c>* depending on the input string KeysForDisplay.</c>
<c>* DLDatasetInfo is a dictionary containing the information about the dataset.</c>
<c>* The visualization can be adapted with GenParam.</c>
<c>* </c>
<c>* ** Set the default values: ***</c>
<c>* </c>
<c>* Define the screen width when a new window row is started.</c>
<l>ThresholdWidth := 1024</l>
<c>* Since potentially a lot of windows are opened,</c>
<c>* scale the windows consistently.</c>
<l>ScaleWindows := 0.8</l>
<c>* Set a font and a font size.</c>
<l>Font := 'mono'</l>
<l>FontSize := 14</l>
<c>* </c>
<l>LineWidth := 2</l>
<l>MapTransparency := 'cc'</l>
<l>MapColorBarWidth := 140</l>
<c>* </c>
<c>* Define parameter values specifically for 3d_gripping_point_detection</c>
<l>GrippingPointColor := '#00FF0099'</l>
<l>GrippingPointSize := 6</l>
<l>PointCloudShowNormals := 'false'</l>
<l>SamplePointCloud := 'false'</l>
<l>PointCloudSampleDistance := 10</l>
<l>ArrowThickness := 0.005</l>
<l>ArrowLength := 0.1</l>
<l>PointCloudColor := []</l>
<l>PointCloudColorNormals := []</l>
<l>RegionColor := '#FF000040'</l>
<c>* </c>
<c>* Define parameter values specifically for anomaly detection</c>
<c>* and Global Context Anomaly Detection.</c>
<l>AnomalyRegionThreshold := -1</l>
<l>AnomalyClassificationThreshold := -1</l>
<l>AnomalyRegionLabelColor := '#40e0d0'</l>
<l>AnomalyColorTransparency := '40'</l>
<l>AnomalyRegionResultColor := '#ff0000c0'</l>
<c>* </c>
<c>* Define segmentation-specific parameter values.</c>
<l>SegMaxWeight := 0</l>
<l>SegDraw := 'fill'</l>
<l>SegTransparency := 'aa'</l>
<l>SegExcludeClassIDs := []</l>
<c>* </c>
<c>* Define bounding box-specific parameter values.</c>
<l>BboxLabelColor := '#000000' + '99'</l>
<l>BboxDisplayConfidence := 1</l>
<l>BboxTextColor := '#eeeeee'</l>
<c>* </c>
<c>* By default, display a description on the bottom.</c>
<l>ShowBottomDesc := true</l>
<c>* </c>
<c>* By default, show a legend with class IDs.</c>
<l>ShowLegend := true</l>
<c>* </c>
<c>* By default, show the anomaly ground truth regions.</c>
<l>ShowGroundTruthAnomalyRegions := true</l>
<c>* </c>
<c>* By default, show class IDs and color frames for classification ground truth/results.</c>
<l>ShowClassificationIDs := true</l>
<l>ShowClassificationColorFrame := true</l>
<c>* </c>
<c>* By default, show class labels for detection ground truth/results.</c>
<l>ShowLabels := true</l>
<c>* </c>
<c>* By default, show direction of the ground truth/results instances for detection with instance_type 'rectangle2'.</c>
<l>ShowDirection := true</l>
<c>* </c>
<c>* By default, use color scheme 'Jet' for the heatmap display.</c>
<l>HeatmapColorScheme := 'jet'</l>
<c>* ** Set user defined values: ***</c>
<c>* </c>
<c>* Overwrite default values by given generic parameters.</c>
<l>if (GenParam != [])</l>
<l>    get_dict_param (GenParam, 'keys', [], GenParamNames)</l>
<l>    for ParamIndex := 0 to |GenParamNames| - 1 by 1</l>
<l>        GenParamName := GenParamNames[ParamIndex]</l>
<l>        get_dict_tuple (GenParam, GenParamName, GenParamValue)</l>
<l>        if (GenParamName == 'anomaly_classification_threshold')</l>
<l>            AnomalyClassificationThreshold := GenParamValue</l>
<l>        elseif (GenParamName == 'anomaly_color_transparency')</l>
<l>            AnomalyColorTransparency := GenParamValue</l>
<l>        elseif (GenParamName == 'anomaly_region_label_color')</l>
<l>            AnomalyRegionLabelColor := GenParamValue</l>
<l>        elseif (GenParamName == 'anomaly_region_result_color')</l>
<l>            AnomalyRegionResultColor := GenParamValue</l>
<l>        elseif (GenParamName == 'anomaly_region_threshold')</l>
<l>            AnomalyRegionThreshold := GenParamValue</l>
<l>        elseif (GenParamName == 'arrow_length')</l>
<l>            ArrowLength := GenParamValue</l>
<l>        elseif (GenParamName == 'arrow_thickness')</l>
<l>            ArrowThickness := GenParamValue</l>
<l>        elseif (GenParamName == 'gripping_point_color')</l>
<l>            GrippingPointColor := GenParamValue</l>
<l>        elseif (GenParamName == 'gripping_point_size')</l>
<l>            GrippingPointSize := GenParamValue</l>
<l>        elseif (GenParamName == 'point_cloud_color')</l>
<l>            PointCloudColor := GenParamValue</l>
<l>        elseif (GenParamName == 'normal_color')</l>
<l>            PointCloudColorNormals := GenParamValue</l>
<l>        elseif (GenParamName == 'point_cloud_sample_distance')</l>
<l>            PointCloudSampleDistance := GenParamValue</l>
<l>        elseif (GenParamName == 'region_color')</l>
<l>            RegionColor := GenParamValue</l>
<l>        elseif (GenParamName == 'show_normals')</l>
<l>            PointCloudShowNormals := GenParamValue</l>
<l>        elseif (GenParamName == 'sample_point_cloud')</l>
<l>            SamplePointCloud := GenParamValue</l>
<l>        elseif (GenParamName == 'bbox_display_confidence')</l>
<l>            BboxDisplayConfidence := GenParamValue</l>
<l>        elseif (GenParamName == 'bbox_label_color')</l>
<l>            BboxLabelColor := GenParamValue</l>
<l>        elseif (GenParamName == 'bbox_text_color')</l>
<l>            BboxTextColor := GenParamValue</l>
<l>        elseif (GenParamName == 'display_bottom_desc')</l>
<l>            ShowBottomDesc := GenParamValue</l>
<l>        elseif (GenParamName == 'display_legend')</l>
<l>            ShowLegend := GenParamValue</l>
<l>        elseif (GenParamName == 'display_ground_truth_anomaly_regions')</l>
<l>            ShowGroundTruthAnomalyRegions := GenParamValue</l>
<l>        elseif (GenParamName == 'display_classification_ids')</l>
<l>            ShowClassificationIDs := GenParamValue</l>
<l>        elseif (GenParamName == 'display_classification_color_frame')</l>
<l>            ShowClassificationColorFrame := GenParamValue</l>
<l>        elseif (GenParamName == 'display_labels')</l>
<l>            ShowLabels := GenParamValue</l>
<l>        elseif (GenParamName == 'display_direction')</l>
<l>            ShowDirection := GenParamValue</l>
<l>        elseif (GenParamName == 'font')</l>
<l>            Font := GenParamValue</l>
<l>        elseif (GenParamName == 'font_size')</l>
<l>            FontSize := GenParamValue</l>
<l>        elseif (GenParamName == 'heatmap_color_scheme')</l>
<l>            HeatmapColorScheme := GenParamValue</l>
<l>        elseif (GenParamName == 'line_width')</l>
<l>            LineWidth := GenParamValue</l>
<l>        elseif (GenParamName == 'map_color_bar_width')</l>
<l>            MapColorBarWidth := GenParamValue</l>
<l>        elseif (GenParamName == 'map_transparency')</l>
<l>            MapTransparency := GenParamValue</l>
<l>        elseif (GenParamName == 'scale_windows')</l>
<l>            ScaleWindows := GenParamValue</l>
<l>        elseif (GenParamName == 'segmentation_draw')</l>
<l>            SegDraw := GenParamValue</l>
<l>        elseif (GenParamName == 'segmentation_exclude_class_ids')</l>
<l>            SegExcludeClassIDs := GenParamValue</l>
<l>        elseif (GenParamName == 'segmentation_max_weight')</l>
<l>            SegMaxWeight := GenParamValue</l>
<l>        elseif (GenParamName == 'segmentation_transparency')</l>
<l>            SegTransparency := GenParamValue</l>
<l>        elseif (GenParamName == 'threshold_width')</l>
<l>            ThresholdWidth := GenParamValue</l>
<l>        else</l>
<l>            throw ('Unknown generic parameter: ' + GenParamName + '.')</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<l>if (|DLSample| &gt; 1 or |DLResult| &gt; 1)</l>
<l>    throw ('Only a single dictionary for DLSample and DLResult is allowed')</l>
<l>endif</l>
<c>* </c>
<c>* Get the dictionary keys.</c>
<l>get_dict_param (DLSample, 'keys', [], SampleKeys)</l>
<l>if (DLResult != [])</l>
<l>    get_dict_param (DLResult, 'keys', [], ResultKeys)</l>
<l>endif</l>
<c>* </c>
<c>* Get image ID if it is available.</c>
<l>get_dict_param (DLSample, 'key_exists', 'image_id', ImageIDExists)</l>
<l>if (ImageIDExists)</l>
<l>    get_dict_tuple (DLSample, 'image_id', ImageID)</l>
<l>    ImageIDString := 'image ID ' + ImageID</l>
<l>    ImageIDStringBraces := '(image ID ' + ImageID + ')'</l>
<l>    ImageIDStringCapital := 'Image ID ' + ImageID</l>
<l>else</l>
<l>    ImageIDString := ''</l>
<l>    ImageIDStringBraces := ImageIDString</l>
<l>    ImageIDStringCapital := ImageIDString</l>
<l>endif</l>
<c>* </c>
<c>* Check if DLDatasetInfo is valid.</c>
<c></c>
<l>if (DLDatasetInfo == [])</l>
<l>    dev_display_dl_data_get_max_class_id (DLSample, MaxClassIdSample, EmptySample)</l>
<l>    dev_display_dl_data_get_max_class_id (DLResult, MaxClassIdResult, EmptyResult)</l>
<l>    MaxClassId := max2(MaxClassIdSample,MaxClassIdResult)</l>
<l>    if (EmptySample and EmptyResult)</l>
<l>        MaxClassId := 1</l>
<l>    endif</l>
<l>    if (MaxClassId == -1)</l>
<l>        MaxClassId := 1000</l>
<l>    endif</l>
<l>    tuple_gen_sequence (0, MaxClassId, 1, ClassIDs)</l>
<l>    tuple_gen_const (MaxClassId + 1, 'unknown', ClassNames)</l>
<c>    * Try to get the class names from the result dictionary.</c>
<c>    * This works only for detection and classification results.</c>
<l>    if (DLResult != [])</l>
<l>        tuple_regexp_select (ResultKeys, '.*class_name.*', ClassNameKey)</l>
<l>        tuple_regexp_select (ResultKeys, '.*class_id.*', ClassIdKey)</l>
<l>        if (|ClassNameKey| == 1 and |ClassIdKey| == 1)</l>
<l>            get_dict_tuple (DLResult, ClassNameKey, ResultClassNames)</l>
<l>            get_dict_tuple (DLResult, ClassIdKey, ResultClassIds)</l>
<l>            tuple_sort_index (ResultClassIds, SortIndices)</l>
<l>            tuple_uniq (ResultClassIds[SortIndices], UniqueClassIds)</l>
<l>            tuple_uniq (ResultClassNames[SortIndices], UniqueClassNames)</l>
<l>            ClassNames[UniqueClassIds] := UniqueClassNames</l>
<l>        endif</l>
<l>    endif</l>
<l>    get_dl_class_colors (ClassNames, Colors)</l>
<l>    ClassesLegend := ClassIDs + ' : ' + ClassNames</l>
<l>    InvalidInput := false</l>
<l>else</l>
<c>    * Check if DLDatasetInfo contains necessary keys.</c>
<l>    ClassKeys := ['class_names', 'class_ids']</l>
<l>    get_handle_param (DLDatasetInfo, 'key_exists', ClassKeys, ClassKeysExist)</l>
<l>    if (min(ClassKeysExist) == 0)</l>
<c>        * In that case we expect that the class names and ids are never used.</c>
<l>    else</l>
<l>        get_handle_param (DLDatasetInfo, 'keys', [], DLDatasetInfoKeys)</l>
<l>        for Index := 0 to |ClassKeys| - 1 by 1</l>
<l>            if (find_first(DLDatasetInfoKeys,ClassKeys[Index]) == -1)</l>
<l>                throw ('Key ' + ClassKeys[Index] + ' is missing in DLDatasetInfo.')</l>
<l>            endif</l>
<l>        endfor</l>
<c>        * </c>
<c>        * Get the general dataset information, if available.</c>
<l>        get_handle_tuple (DLDatasetInfo, 'class_names', ClassNames)</l>
<l>        get_handle_tuple (DLDatasetInfo, 'class_ids', ClassIDs)</l>
<c>        * </c>
<c>        * Define distinct colors for the classes.</c>
<l>        get_dl_class_colors (ClassNames, Colors)</l>
<c>        * </c>
<l>        ClassesLegend := ClassIDs + ' : ' + ClassNames</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* ** Set window parameters: ***</c>
<c>* </c>
<c>* Set previous window coordinates.</c>
<l>PrevWindowCoordinates := [0, 0, 0, 0, 1]</l>
<c>* </c>
<c>* Check that the WindowHandleDict is of type dictionary.</c>
<l>try</l>
<l>    get_dict_param (WindowHandleDict, 'keys', [], Keys)</l>
<l>catch (Exception)</l>
<l>    if (Exception[0] == 1401)</l>
<l>        throw ('WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.')</l>
<l>    else</l>
<l>        throw (Exception)</l>
<l>    endif</l>
<l>endtry</l>
<c>* For better usage, add meta information about the window handles in WindowHandleDict.</c>
<l>tuple_find (Keys, 'meta_information', MetaInfoIndex)</l>
<l>if (MetaInfoIndex == -1 or MetaInfoIndex == [])</l>
<l>    create_dict (MetaInfo)</l>
<l>    set_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>endif</l>
<c>* </c>
<c>* For each window, set 'flush' to 'false' to avoid flickering.</c>
<l>FlushValues := []</l>
<l>get_dict_param (WindowHandleDict, 'keys', [], WindowHandleKeys)</l>
<l>for Index := 0 to |WindowHandleKeys| - 1 by 1</l>
<c>    * Only consider the WindowHandleKeys that are needed for the current visualization.</c>
<l>    KeyIndex := find(KeysForDisplay,WindowHandleKeys[Index])</l>
<l>    if (KeyIndex != -1 and KeyIndex != [])</l>
<l>        get_dict_tuple (WindowHandleDict, WindowHandleKeys[Index], WindowHandles)</l>
<l>        for WindowIndex := 0 to |WindowHandles| - 1 by 1</l>
<l>            get_window_param (WindowHandles[WindowIndex], 'flush', FlushValue)</l>
<l>            FlushValues := [FlushValues,FlushValue]</l>
<l>            set_window_param (WindowHandles[WindowIndex], 'flush', 'false')</l>
<l>        endfor</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* ** Display the data: ***</c>
<c>* </c>
<c>* Display data dictionaries.</c>
<l>KeyIndex := 0</l>
<l>while (KeyIndex &lt; |KeysForDisplay|)</l>
<l>    if (KeysForDisplay[KeyIndex] == 'image')</l>
<c>        * </c>
<c>        * Image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, KeysForDisplay[KeyIndex])</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        full_domain (Image, Image)</l>
<l>        dev_display (Image)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'image_with_domain')</l>
<c>        * </c>
<c>        * Image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<l>        get_domain (Image, Domain)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_set_color (RegionColor)</l>
<l>        dev_display (Image)</l>
<l>        dev_display (Domain)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'normals')</l>
<c>        * </c>
<c>        * Normal image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, KeysForDisplay[KeyIndex])</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        full_domain (Image, Image)</l>
<l>        dev_display (Image)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'gripping_confidence')</l>
<c>        * </c>
<c>        * Confidence image.</c>
<l>        if (DLResult == [])</l>
<l>            throw ('DLResult dict is empty.')</l>
<l>        endif</l>
<l>        if (find(ResultKeys,KeysForDisplay[KeyIndex]) != -1)</l>
<l>            get_dict_object (Image, DLResult, KeysForDisplay[KeyIndex])</l>
<l>        else</l>
<l>            throw ('Image with key \'' + KeysForDisplay[KeyIndex] + '\' could not be found in DLResult.')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        full_domain (Image, Image)</l>
<l>        dev_display (Image)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>        dev_disp_text ('Gripping confidence', 'window', 'top', 'left', 'black', 'box', 'true')</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'gripping_map')</l>
<c>        *       *</c>
<c>        * Image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<c>        * </c>
<c>        * Get gripping points</c>
<l>        get_gripping_points_from_dict (DLResult, Rows, Columns)</l>
<c>        * </c>
<c>        * Gripping map.</c>
<l>        if (DLResult == [])</l>
<l>            throw ('DLResult dict is empty.')</l>
<l>        endif</l>
<l>        if (find(ResultKeys,KeysForDisplay[KeyIndex]) != -1)</l>
<l>            get_dict_object (Map, DLResult, KeysForDisplay[KeyIndex])</l>
<l>        else</l>
<l>            throw ('Image with key \'' + KeysForDisplay[KeyIndex] + '\' could not be found in DLResult.')</l>
<l>        endif</l>
<l>        add_colormap_to_image (Map, Image, HeatmapScene, HeatmapColorScheme)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_display (HeatmapScene)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>        dev_disp_text ('Gripping map', 'window', 'top', 'left', 'black', 'box', 'true')</l>
<c>        * </c>
<l>        gen_cross_contour_xld (Cross, Rows, Columns, GrippingPointSize, 0.785398)</l>
<l>        dev_set_line_width (LineWidth)</l>
<l>        dev_set_color (GrippingPointColor)</l>
<l>        dev_display (Cross)</l>
<c>        * </c>
<l>    elseif (KeysForDisplay[KeyIndex] == 'x')</l>
<c>        * </c>
<c>        * X.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, KeysForDisplay[KeyIndex])</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        full_domain (Image, Image)</l>
<l>        dev_display (Image)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'xyz')</l>
<c>        * </c>
<c>        * XYZ.</c>
<l>        get_dl_sample_image (X, SampleKeys, DLSample, 'x')</l>
<l>        get_dl_sample_image (Y, SampleKeys, DLSample, 'y')</l>
<l>        get_dl_sample_image (Z, SampleKeys, DLSample, 'z')</l>
<l>        compose3 (X, Y, Z, Image)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        full_domain (Image, Image)</l>
<l>        dev_display (Image)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'y')</l>
<c>        * </c>
<c>        * Y.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, KeysForDisplay[KeyIndex])</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        full_domain (Image, Image)</l>
<l>        dev_display (Image)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'z')</l>
<c>        * </c>
<c>        * Z.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, KeysForDisplay[KeyIndex])</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        full_domain (Image, Image)</l>
<l>        dev_display (Image)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'anomaly_both' or KeysForDisplay[KeyIndex] == 'anomaly_both_local' or KeysForDisplay[KeyIndex] == 'anomaly_both_global')</l>
<c>        * </c>
<c>        * In case of 'anomaly_both', also plot 'anomaly_both_local'</c>
<c>        * and 'anomaly_both_global', if available.</c>
<l>        tuple_regexp_select (ResultKeys, '.*anomaly_image.*', AnomalyImages)</l>
<l>        if (KeysForDisplay[KeyIndex] == 'anomaly_both')</l>
<l>            tuple_regexp_replace (AnomalyImages, 'image', 'both', PossibleKeysForDisplay)</l>
<l>            AddDisplayKey := false</l>
<l>            for Index := 0 to |PossibleKeysForDisplay| - 1 by 1</l>
<l>                if (find_first(KeysForDisplay,PossibleKeysForDisplay[Index]) == -1)</l>
<l>                    KeysForDisplay := [KeysForDisplay,PossibleKeysForDisplay[Index]]</l>
<l>                    AddDisplayKey := true</l>
<l>                endif</l>
<l>            endfor</l>
<c>            * </c>
<c>            * Display not possible for 'anomaly_both' if key 'anomaly_image' is missing.</c>
<l>            if (find_first(PossibleKeysForDisplay,KeysForDisplay[KeyIndex]) == -1 and AddDisplayKey)</l>
<l>                KeyIndex := KeyIndex + 1</l>
<l>                continue</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<c>        * Get image and ground truth.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<l>        get_anomaly_ground_truth_label (SampleKeys, DLSample, AnomalyLabelGroundTruth, AnomalyLabelIDGroundTruth)</l>
<c>        * </c>
<c>        * Get the anomaly results either by applying the specified thresholds or out of DLResult.</c>
<l>        tuple_regexp_match (KeysForDisplay[KeyIndex], 'anomaly_both(.*)', AnomalyResultPostfix)</l>
<l>        get_anomaly_result (AnomalyImage, AnomalyRegion, DLResult, AnomalyClassificationThreshold, AnomalyRegionThreshold, AnomalyResultPostfix, AnomalyScore, AnomalyClassID, AnomalyClassThresholdDisplay, AnomalyRegionThresholdDisplay)</l>
<c>        * </c>
<c>        * Get open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        WindowHandleName := KeysForDisplay[KeyIndex]</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, WindowHandleName, CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualize image, ground truth (if available), and result regions.</c>
<l>        dev_display (Image)</l>
<l>        AnomalyRegionGroundTruthExists := 'false'</l>
<l>        if (ShowGroundTruthAnomalyRegions)</l>
<l>            dev_display_ground_truth_anomaly_regions (SampleKeys, DLSample, CurrentWindowHandle, LineWidth, AnomalyRegionLabelColor, AnomalyColorTransparency, AnomalyRegionGroundTruthExists)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display anomaly regions defined by the specified threshold or out of DLResult.</c>
<l>        if (AnomalyRegionThreshold != -1 or find(ResultKeys,'anomaly_region' + AnomalyResultPostfix) != -1)</l>
<l>            dev_display_result_anomaly_regions (AnomalyRegion, CurrentWindowHandle, LineWidth, AnomalyRegionResultColor)</l>
<l>        endif</l>
<c>        * </c>
<l>        Text := 'GT and detected anomalies ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Get prediction color.</c>
<l>        PredictionColor := 'white'</l>
<l>        if (AnomalyLabelIDGroundTruth == AnomalyClassID)</l>
<l>            PredictionColor := 'green'</l>
<l>        elseif (AnomalyClassID != -1)</l>
<l>            PredictionColor := 'red'</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := '---------------'</l>
<l>            Text[|Text|] := 'Ground truth '</l>
<l>            Text[|Text|] := '---------------'</l>
<l>            Text[|Text|] := AnomalyLabelIDGroundTruth + ' : \'' + AnomalyLabelGroundTruth + '\''</l>
<l>            if (AnomalyRegionGroundTruthExists == 'false' and AnomalyLabelIDGroundTruth == 1 and ShowGroundTruthAnomalyRegions)</l>
<l>                Text[|Text|] := ''</l>
<l>                Text[|Text|] := 'No segmentation ground truth found'</l>
<l>            endif</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := '---------------'</l>
<l>            Text[|Text|] := 'Results '</l>
<l>            Text[|Text|] := '---------------'</l>
<l>            if (AnomalyClassID == 1)</l>
<l>                Text[|Text|] := AnomalyClassID + ' : \'nok\''</l>
<l>            elseif (AnomalyClassID == 0)</l>
<l>                Text[|Text|] := AnomalyClassID + ' : \'ok\''</l>
<l>            else</l>
<l>                Text[|Text|] := 'No classification result found'</l>
<l>            endif</l>
<l>            if (AnomalyRegionThreshold == -1 and find(ResultKeys,'anomaly_region' + AnomalyResultPostfix) == -1)</l>
<l>                Text[|Text|] := ''</l>
<l>                Text[|Text|] := 'No segmentation result found'</l>
<l>            endif</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := 'anomaly_score' + AnomalyResultPostfix + ': ' + AnomalyScore$'.3f'</l>
<l>            Text[|Text|] := ''</l>
<l>            if (AnomalyClassThresholdDisplay != -1 or AnomalyRegionThresholdDisplay != -1)</l>
<l>                Text[|Text|] := '---------------'</l>
<l>                Text[|Text|] := 'Thresholds '</l>
<l>                Text[|Text|] := '---------------'</l>
<l>            endif</l>
<c>            * </c>
<l>            if (AnomalyClassThresholdDisplay != -1)</l>
<l>                Text[|Text|] := 'Classification: ' + AnomalyClassThresholdDisplay$'.3f'</l>
<l>                Text[|Text|] := ''</l>
<l>            endif</l>
<l>            if (AnomalyRegionThresholdDisplay != -1)</l>
<l>                Text[|Text|] := 'Segmentation: ' + AnomalyRegionThresholdDisplay$'.3f'</l>
<l>                Text[|Text|] := ''</l>
<l>            endif</l>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, WindowHandleName, WindowImageRatio, PrevWindowCoordinates)</l>
<l>            tuple_gen_const (|Text|, 'white', LineColors)</l>
<l>            ResultColorOffset := 10</l>
<l>            if (AnomalyRegionGroundTruthExists == 'false' and AnomalyLabelIDGroundTruth == 1 and ShowGroundTruthAnomalyRegions)</l>
<l>                ResultColorOffset := ResultColorOffset + 2</l>
<l>            endif</l>
<l>            LineColors[ResultColorOffset] := PredictionColor</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', LineColors, 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<l>    elseif (KeysForDisplay[KeyIndex] == 'anomaly_ground_truth')</l>
<c>        * Image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<l>        get_anomaly_ground_truth_label (SampleKeys, DLSample, AnomalyLabelGroundTruth, AnomalyLabelIDGroundTruth)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<l>        AnomalyRegionExists := 'false'</l>
<l>        if (ShowGroundTruthAnomalyRegions)</l>
<c>            * Show the ground truth region.</c>
<l>            dev_display_ground_truth_anomaly_regions (SampleKeys, DLSample, CurrentWindowHandle, LineWidth, AnomalyRegionLabelColor, AnomalyColorTransparency, AnomalyRegionExists)</l>
<l>        endif</l>
<c>        * </c>
<l>        Text := 'Ground truth anomalies ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := AnomalyLabelIDGroundTruth + ' : \'' + AnomalyLabelGroundTruth + '\''</l>
<l>            if (AnomalyRegionExists == 'false' and AnomalyLabelIDGroundTruth == 1 and ShowGroundTruthAnomalyRegions)</l>
<l>                Text[|Text|] := ''</l>
<l>                Text[|Text|] := 'No \'anomaly_ground_truth\' exists!'</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'anomaly_image' or KeysForDisplay[KeyIndex] == 'anomaly_image_local' or KeysForDisplay[KeyIndex] == 'anomaly_image_global')</l>
<c>        * </c>
<c>        * Image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<c>        * </c>
<c>        * Get the anomaly results either by applying the specified thresholds or out of DLResult.</c>
<l>        AnomalyImageKey := KeysForDisplay[KeyIndex]</l>
<l>        tuple_regexp_match (AnomalyImageKey, 'anomaly_image(.*)', AnomalyResultPostfix)</l>
<l>        get_anomaly_result (AnomalyImage, AnomalyRegion, DLResult, AnomalyClassificationThreshold, AnomalyRegionThreshold, AnomalyResultPostfix, AnomalyScore, AnomalyClassID, AnomalyClassThresholdDisplay, AnomalyRegionThresholdDisplay)</l>
<c>        * </c>
<c>        * Read in input image.</c>
<l>        get_dict_object (Image, DLSample, 'image')</l>
<c>        * Add the anomaly image to the input image.</c>
<l>        add_colormap_to_image (AnomalyImage, Image, AnomalyImage, HeatmapColorScheme)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_display (AnomalyImage)</l>
<l>        Text := AnomalyImageKey</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<l>        tuple_regexp_replace (AnomalyImageKey, 'image', 'score', AnomalyScoreKey)</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text[|Text|] := ''</l>
<l>            if (AnomalyClassID == 1)</l>
<l>                Text[|Text|] := AnomalyClassID + ' : \'nok\''</l>
<l>            elseif (AnomalyClassID == 0)</l>
<l>                Text[|Text|] := AnomalyClassID + ' : \'ok\''</l>
<l>            else</l>
<l>                Text[|Text|] := 'No classification result found'</l>
<l>            endif</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := AnomalyScoreKey + ': ' + AnomalyScore$'.3f'</l>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'anomaly_result' or KeysForDisplay[KeyIndex] == 'anomaly_result_local' or KeysForDisplay[KeyIndex] == 'anomaly_result_global')</l>
<c>        * </c>
<c>        * Get image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<c>        * </c>
<c>        * Get the anomaly results either by applying the specified thresholds or out of DLResult.</c>
<l>        AnomalyResultKey := KeysForDisplay[KeyIndex]</l>
<l>        tuple_regexp_match (AnomalyResultKey, 'anomaly_result(.*)', AnomalyResultPostfix)</l>
<l>        get_anomaly_result (AnomalyImage, AnomalyRegion, DLResult, AnomalyClassificationThreshold, AnomalyRegionThreshold, AnomalyResultPostfix, AnomalyScore, AnomalyClassID, AnomalyClassThresholdDisplay, AnomalyRegionThresholdDisplay)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<c>        * Display anomaly regions defined by the specified threshold or out of DLResult.</c>
<l>        tuple_regexp_replace (AnomalyResultKey, 'result', 'region', AnomalyRegionKey)</l>
<l>        if (AnomalyRegionThreshold != -1 or find(ResultKeys,AnomalyRegionKey) != -1)</l>
<l>            dev_display_result_anomaly_regions (AnomalyRegion, CurrentWindowHandle, LineWidth, AnomalyRegionResultColor)</l>
<l>        endif</l>
<c>        * </c>
<l>        tuple_regexp_replace (AnomalyResultKey, 'result', 'score', AnomalyScoreKey)</l>
<c>        * </c>
<l>        Text := 'Detected anomalies ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := '---------------'</l>
<l>            Text[|Text|] := 'Results '</l>
<l>            Text[|Text|] := '---------------'</l>
<l>            if (AnomalyClassID == 1)</l>
<l>                Text[|Text|] := AnomalyClassID + ' : \'nok\''</l>
<l>            elseif (AnomalyClassID == 0)</l>
<l>                Text[|Text|] := AnomalyClassID + ' : \'ok\''</l>
<l>            else</l>
<l>                Text[|Text|] := 'No classification result found'</l>
<l>            endif</l>
<l>            if (AnomalyRegionThreshold == -1 and find(ResultKeys,AnomalyRegionKey) == -1)</l>
<l>                Text[|Text|] := ''</l>
<l>                Text[|Text|] := 'No segmentation result found'</l>
<l>            endif</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := AnomalyScoreKey + ': ' + AnomalyScore$'.3f'</l>
<l>            Text[|Text|] := ''</l>
<l>            if (AnomalyClassThresholdDisplay != -1 or AnomalyRegionThresholdDisplay != -1)</l>
<l>                Text[|Text|] := '---------------'</l>
<l>                Text[|Text|] := 'Thresholds '</l>
<l>                Text[|Text|] := '---------------'</l>
<l>            endif</l>
<c>            * </c>
<l>            if (AnomalyClassThresholdDisplay != -1)</l>
<l>                Text[|Text|] := 'Classification: ' + AnomalyClassThresholdDisplay$'.3f'</l>
<l>                Text[|Text|] := ''</l>
<l>            endif</l>
<l>            if (AnomalyRegionThresholdDisplay != -1)</l>
<l>                Text[|Text|] := 'Segmentation: ' + AnomalyRegionThresholdDisplay$'.3f'</l>
<l>                Text[|Text|] := ''</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<l>    elseif (KeysForDisplay[KeyIndex] == 'gripping_heatmap')</l>
<c>        * </c>
<c>        * Image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<c>        * </c>
<c>        * Get gripping points</c>
<l>        get_gripping_points_from_dict (DLResult, Rows, Columns)</l>
<c>        * </c>
<c>        * Confidence image.</c>
<l>        if (find(ResultKeys,'gripping_confidence') != -1)</l>
<l>            get_dict_object (ConfidenceImage, DLResult, 'gripping_confidence')</l>
<l>        else</l>
<l>            throw ('Image with key \'gripping_confidence\' could not be found in DLResult.')</l>
<l>        endif</l>
<l>        add_colormap_to_image (ConfidenceImage, Image, HeatmapScene, HeatmapColorScheme)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_display (HeatmapScene)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>        dev_disp_text ('Gripping heatmap', 'window', 'top', 'left', 'black', 'box', 'true')</l>
<c>        * </c>
<l>        gen_cross_contour_xld (Cross, Rows, Columns, GrippingPointSize, 0.785398)</l>
<l>        dev_set_line_width (LineWidth)</l>
<l>        dev_set_color (GrippingPointColor)</l>
<l>        dev_display (Cross)</l>
<c>        * </c>
<l>    elseif (KeysForDisplay[KeyIndex] == 'gripping_points')</l>
<c>        * </c>
<c>        * Image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<c>        * </c>
<c>        * Get gripping points</c>
<l>        get_gripping_points_from_dict (DLResult, Rows, Columns)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        full_domain (Image, Image)</l>
<l>        dev_display (Image)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (ImageIDStringCapital, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>        dev_disp_text ('Gripping points', 'window', 'top', 'left', 'black', 'box', 'true')</l>
<c>        * </c>
<l>        gen_cross_contour_xld (Cross, Rows, Columns, GrippingPointSize, 0.785398)</l>
<l>        dev_set_line_width (LineWidth)</l>
<l>        dev_set_color (GrippingPointColor)</l>
<l>        dev_display (Cross)</l>
<c>        * </c>
<l>    elseif (KeysForDisplay[KeyIndex] == 'point_cloud')</l>
<c>        * Check if all information to display the object model are present</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<l>        get_dl_sample_image (Dummy, SampleKeys, DLSample, 'x')</l>
<l>        get_dl_sample_image (Dummy, SampleKeys, DLSample, 'y')</l>
<l>        get_dl_sample_image (Dummy, SampleKeys, DLSample, 'z')</l>
<l>        if (PointCloudShowNormals == 'true')</l>
<l>            get_dl_sample_image (Dummy, SampleKeys, DLSample, 'normals')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Do nothing here and draw later</c>
<c>        * </c>
<l>    elseif (KeysForDisplay[KeyIndex] == 'bbox_both')</l>
<c>        * </c>
<c>        * Ground truth and result bounding boxes on image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_display (Image)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display_ground_truth_detection (DLSample, SampleKeys, LineWidth, ClassIDs, Colors, BboxLabelColor, WindowImageRatio, BboxTextColor, ShowLabels, ShowDirection, CurrentWindowHandle, BboxLabelIndex)</l>
<l>        if (find(ResultKeys,'bbox_confidence') != -1)</l>
<l>            get_dict_tuple (DLResult, 'bbox_confidence', BboxConfidences)</l>
<l>        else</l>
<l>            throw ('Result data could not be found in DLResult.')</l>
<l>        endif</l>
<l>        if (BboxDisplayConfidence)</l>
<l>            TextConf := ' (' + BboxConfidences$'.2f' + ')'</l>
<l>        else</l>
<l>            TextConf := gen_tuple_const(|BboxConfidences|,'')</l>
<l>        endif</l>
<l>        dev_display_result_detection (DLResult, ResultKeys, LineWidth, ClassIDs, TextConf, Colors, BboxLabelColor, WindowImageRatio, 'bottom', BboxTextColor, ShowLabels, ShowDirection, CurrentWindowHandle, BboxClassIndex)</l>
<l>        Text := 'Ground truth and results ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>        Text := 'Ground truth and'</l>
<l>        Text[|Text|] := 'results ' + ImageIDStringBraces</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            BboxColorsBoth := ['white', 'white']</l>
<l>            if (|BboxClassIndex| + |BboxLabelIndex| &gt; 0)</l>
<l>                BboxClassLabelIndexUniq := uniq(sort([BboxClassIndex,BboxLabelIndex]))</l>
<l>                Text := [Text,ClassesLegend[BboxClassLabelIndexUniq]]</l>
<l>                BboxColorsBoth := [BboxColorsBoth,Colors[BboxClassLabelIndexUniq]]</l>
<l>            else</l>
<l>                Text := [Text,'No ground truth nor results present.']</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window.</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', BboxColorsBoth, 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'bbox_ground_truth')</l>
<c>        * </c>
<c>        * Sample bounding boxes on image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<l>        dev_display_ground_truth_detection (DLSample, SampleKeys, LineWidth, ClassIDs, Colors, BboxLabelColor, WindowImageRatio, BboxTextColor, ShowLabels, ShowDirection, CurrentWindowHandle, BboxIDs)</l>
<l>        Text := 'Ground truth ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            BboxColors := 'white'</l>
<l>            if (|BboxIDs|)</l>
<l>                BboxIDsUniq := uniq(sort(BboxIDs))</l>
<l>                Text := [Text,ClassesLegend[BboxIDsUniq]]</l>
<l>                BboxColors := [BboxColors,Colors[BboxIDsUniq]]</l>
<l>            else</l>
<l>                Text := [Text,'No ground truth present.']</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window.</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', BboxColors, 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'bbox_result')</l>
<c>        * </c>
<c>        * Result bounding boxes on image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<l>        if (find(ResultKeys,'bbox_confidence') != -1)</l>
<l>            get_dict_tuple (DLResult, 'bbox_confidence', BboxConfidences)</l>
<l>        else</l>
<l>            throw ('Result data could not be found in DLResult.')</l>
<l>        endif</l>
<l>        if (BboxDisplayConfidence)</l>
<l>            TextConf := ' (' + BboxConfidences$'.2f' + ')'</l>
<l>        else</l>
<l>            TextConf := gen_tuple_const(|BboxConfidences|,'')</l>
<l>        endif</l>
<l>        dev_display_result_detection (DLResult, ResultKeys, LineWidth, ClassIDs, TextConf, Colors, BboxLabelColor, WindowImageRatio, 'top', BboxTextColor, ShowLabels, ShowDirection, CurrentWindowHandle, BboxClassIndex)</l>
<l>        Text := 'Result ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            BboxColorsResults := 'white'</l>
<l>            if (|BboxClassIndex| &gt; 0)</l>
<l>                BboxClassIndexUniq := uniq(sort(BboxClassIndex))</l>
<l>                Text := [Text,ClassesLegend[BboxClassIndexUniq]]</l>
<l>                BboxColorsResults := [BboxColorsResults,Colors[BboxClassIndexUniq]]</l>
<l>            else</l>
<l>                Text := [Text,'No results present.']</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window.</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', BboxColorsResults, 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'classification_both')</l>
<c>        * </c>
<c>        * Ground truth and result classification image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<c>        * </c>
<l>        get_classification_ground_truth (SampleKeys, DLSample, ClassificationLabelIDGroundTruth)</l>
<l>        get_classification_result (ResultKeys, DLResult, ClassificationLabelIDResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Get prediction color.</c>
<l>        PredictionColor := 'white'</l>
<l>        if (ClassificationLabelIDGroundTruth == ClassificationLabelIDResult)</l>
<l>            PredictionText := 'Correct'</l>
<l>            PredictionColor := 'green'</l>
<l>        else</l>
<l>            PredictionText := 'Wrong'</l>
<l>            PredictionColor := 'red'</l>
<l>        endif</l>
<c>        * </c>
<c>        * Generate prediction color frame and show image.</c>
<l>        if (ShowClassificationColorFrame)</l>
<c>            * Create a frame with line width 7 that is completely displayed in the window.</c>
<l>            BoarderOffset := 7 / 2.</l>
<l>            get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>            get_dict_tuple (MetaInfo, 'classification_both_window_image_ratio_height', WindowImageRatioHeight)</l>
<l>            get_dict_tuple (MetaInfo, 'classification_both_window_image_ratio_width', WindowImageRatioWidth)</l>
<l>            BoarderOffsetRow := BoarderOffset / WindowImageRatioHeight</l>
<l>            BoarderOffsetCol := BoarderOffset / WindowImageRatioWidth</l>
<l>            gen_contour_polygon_xld (PredictionColorFrame, [BoarderOffsetRow - 0.5,BoarderOffsetRow - 0.5,HeightImage + 0.5 - BoarderOffsetRow,HeightImage + 0.5 - BoarderOffsetRow,BoarderOffsetRow - 0.5], [BoarderOffsetCol - 0.5,WidthImage + 0.5 - BoarderOffsetCol,WidthImage + 0.5 - BoarderOffsetCol,BoarderOffsetCol - 0.5,BoarderOffsetCol - 0.5])</l>
<l>            dev_set_line_width (7)</l>
<l>            dev_set_color (PredictionColor)</l>
<l>            dev_display (Image)</l>
<l>            dev_display (PredictionColorFrame)</l>
<l>        else</l>
<l>            dev_display (Image)</l>
<l>        endif</l>
<c>        * </c>
<l>        if (ShowClassificationIDs)</l>
<l>            get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>            get_dict_tuple (MetaInfo, KeysForDisplay[KeyIndex] + '_margin_bottom', MarginBottom)</l>
<l>            get_dict_tuple (MetaInfo, KeysForDisplay[KeyIndex] + '_window_coordinates', WindowCoordinates)</l>
<l>            CurrentWindowHeight := WindowCoordinates[3] - WindowCoordinates[0]</l>
<l>            get_font_extents (CurrentWindowHandle, _, _, _, MaxHeight)</l>
<l>            Text := 'GT label ID: ' + ClassificationLabelIDGroundTruth</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>            Text := 'Result class ID: ' + ClassificationLabelIDResult</l>
<l>            if (ShowBottomDesc)</l>
<l>                dev_disp_text (Text, 'window', CurrentWindowHeight - (MarginBottom + MaxHeight + 10), 'left', 'white', 'box', 'false')</l>
<l>            else</l>
<l>                dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<l>        if (ShowBottomDesc)</l>
<l>            Text := 'Result/GT classification ' + ImageIDStringBraces</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text := 'Ground truth class ID ' + ImageIDStringBraces</l>
<l>            Text[|Text|] := ClassesLegend[ClassificationLabelIDGroundTruth]</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := 'Result class ID'</l>
<l>            if (ClassificationLabelIDResult == [])</l>
<l>                Text[|Text|] := 'No classification result is given!'</l>
<l>            else</l>
<l>                Text[|Text|] := ClassesLegend[ClassificationLabelIDResult]</l>
<l>                Text[|Text|] := ''</l>
<l>                Text[|Text|] := ''</l>
<l>                Text[|Text|] := 'Prediction '</l>
<l>                Text[|Text|] := PredictionText</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window.</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            tuple_gen_const (|Text|, 'white', LineColors)</l>
<l>            LineColors[1] := Colors[ClassificationLabelIDGroundTruth]</l>
<l>            if (ClassificationLabelIDResult != [])</l>
<l>                LineColors[5] := Colors[ClassificationLabelIDResult]</l>
<l>                LineColors[9] := PredictionColor</l>
<l>            endif</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', LineColors, 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'classification_ground_truth')</l>
<c>        * </c>
<c>        * Ground truth classification image and class label.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<c>        * </c>
<l>        get_classification_ground_truth (SampleKeys, DLSample, ClassificationLabelIDGroundTruth)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<l>        if (ShowClassificationIDs)</l>
<l>            Text := 'GT label ID: ' + ClassificationLabelIDGroundTruth</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<l>        if (ShowBottomDesc)</l>
<l>            Text := 'Ground truth classification ' + ImageIDStringBraces</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text := 'Ground truth class ID ' + ImageIDStringBraces</l>
<l>            Text := [Text,ClassesLegend[ClassificationLabelIDGroundTruth]]</l>
<c>            * </c>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[ClassificationLabelIDGroundTruth]], 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'classification_result')</l>
<c>        * </c>
<c>        * Ground truth classification image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<c>        * </c>
<l>        get_classification_result (ResultKeys, DLResult, ClassificationLabelIDResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<c>        * Display the class IDs.</c>
<l>        if (ShowClassificationIDs)</l>
<l>            get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>            get_dict_tuple (MetaInfo, 'classification_result_margin_bottom', MarginBottom)</l>
<l>            get_dict_tuple (MetaInfo, 'classification_result_window_coordinates', WindowCoordinates)</l>
<l>            CurrentWindowHeight := WindowCoordinates[3] - WindowCoordinates[0]</l>
<l>            get_font_extents (CurrentWindowHandle, _, _, _, MaxHeight)</l>
<l>            Text := 'Result class ID: ' + ClassificationLabelIDResult</l>
<l>            if (ShowBottomDesc)</l>
<l>                dev_disp_text (Text, 'window', CurrentWindowHeight - (MarginBottom + MaxHeight + 10), 'left', 'white', 'box', 'false')</l>
<l>            else</l>
<l>                dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>            endif</l>
<l>        endif</l>
<c>        * </c>
<l>        if (ShowBottomDesc)</l>
<l>            Text := 'Result classification ' + ImageIDStringBraces</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            Text := 'Result class ID ' + ImageIDStringBraces</l>
<l>            if (ClassificationLabelIDResult == [])</l>
<l>                Text[|Text|] := 'No classification result is given!'</l>
<l>            else</l>
<l>                Text := [Text,ClassesLegend[ClassificationLabelIDResult]]</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[ClassificationLabelIDResult]], 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'heatmap_grad_cam' or KeysForDisplay[KeyIndex] == 'heatmap_guided_grad_cam' or KeysForDisplay[KeyIndex] == 'heatmap_confidence_based')</l>
<c>        * </c>
<c>        * Display the heatmap image (method 'heatmap_grad_cam', 'heatmap_guided_grad_cam',</c>
<c>        * or 'heatmap_confidence_based') in the selected color scheme.</c>
<c>        * Retrieve heatmap image, inferred image, and inference results.</c>
<l>        SelectedHeatmapMethod := KeysForDisplay[KeyIndex]</l>
<l>        if ((find(ResultKeys,'heatmap_grad_cam') != -1) or (find(ResultKeys,'heatmap_guided_grad_cam') != -1) or (find(ResultKeys,'heatmap_confidence_based') != -1))</l>
<l>            if (SelectedHeatmapMethod == 'heatmap_grad_cam')</l>
<l>                get_dict_tuple (DLResult, 'heatmap_grad_cam', DictHeatmap)</l>
<l>                MethodName := 'Grad-CAM'</l>
<l>            elseif (SelectedHeatmapMethod == 'heatmap_guided_grad_cam')</l>
<l>                get_dict_tuple (DLResult, 'heatmap_guided_grad_cam', DictHeatmap)</l>
<l>                MethodName := 'Guided-Grad-CAM'</l>
<l>            else</l>
<l>                get_dict_tuple (DLResult, 'heatmap_confidence_based', DictHeatmap)</l>
<l>                MethodName := 'Confidence based'</l>
<l>            endif</l>
<l>            get_dict_param (DictHeatmap, 'keys', [], HeatmapKeys)</l>
<c>            * </c>
<l>            if (SelectedHeatmapMethod == 'heatmap_guided_grad_cam')</l>
<l>                HeatmapImageName := regexp_select(HeatmapKeys,'guided_grad_cam_image_class_[0-9]*')</l>
<l>                TargetClassID := regexp_match(HeatmapImageName,'guided_grad_cam_image_class_([0-9]+)$')</l>
<l>            else</l>
<l>                HeatmapImageName := regexp_select(HeatmapKeys,'heatmap_image_class_[0-9]*')</l>
<l>                TargetClassID := regexp_match(HeatmapImageName,'heatmap_image_class_([0-9]+)$')</l>
<l>            endif</l>
<l>            get_dict_object (ImageHeatmap, DictHeatmap, HeatmapImageName)</l>
<l>        else</l>
<l>            throw ('Heatmap image could not be found in DLResult.')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Only for the Grad-Cam heatmap the input image is shown.</c>
<l>        if (SelectedHeatmapMethod == 'heatmap_grad_cam')</l>
<c>            * Read in input image.</c>
<l>            get_dict_object (Image, DLSample, 'image')</l>
<c>            * Add the heatmap to the input image.</c>
<l>            add_colormap_to_image (ImageHeatmap, Image, ImageHeatmap, HeatmapColorScheme)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (ImageHeatmap, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_display (ImageHeatmap)</l>
<l>        if (ShowBottomDesc)</l>
<l>            Text := 'Classification heatmap ' + ImageIDStringBraces</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            get_dict_tuple (DLResult, 'classification_class_names', ClassNames)</l>
<l>            get_dict_tuple (DLResult, 'classification_class_ids', ClassIDs)</l>
<l>            get_dict_tuple (DLResult, 'classification_confidences', Confidences)</l>
<l>            if (SelectedHeatmapMethod == 'heatmap_confidence_based')</l>
<l>                get_dict_tuple (DictHeatmap, 'classification_heatmap_maxdeviation', MaxDeviation)</l>
<l>            endif</l>
<l>            ClassificationLabelNameResult := ClassNames[0]</l>
<l>            ClassificationLabelIDResult := ClassIDs[0]</l>
<l>            TargetClassConfidence := Confidences[find(ClassIDs,number(TargetClassID))]</l>
<l>            Text := '--------- '</l>
<l>            Text[|Text|] := 'Image '</l>
<l>            Text[|Text|] := '--------- '</l>
<l>            Text[|Text|] := ''</l>
<l>            if (find(SampleKeys,'image_label_id') != -1)</l>
<l>                get_dict_tuple (DLSample, 'image_label_id', ClassificationLabelIDGroundTruth)</l>
<l>                get_dict_tuple (DLDatasetInfo, 'class_names', ClassificationLabelNamesGroundTruth)</l>
<c>                * Get prediction color.</c>
<l>                if (ClassificationLabelIDGroundTruth == ClassificationLabelIDResult)</l>
<l>                    PredictionColor := 'green'</l>
<l>                else</l>
<l>                    PredictionColor := 'red'</l>
<l>                endif</l>
<l>                Text[|Text|] := 'Ground truth class: '</l>
<l>                Text[|Text|] := ClassificationLabelNamesGroundTruth[ClassificationLabelIDGroundTruth]</l>
<l>                Text[|Text|] := ''</l>
<l>            endif</l>
<l>            Text[|Text|] := 'Predicted class: '</l>
<l>            Text[|Text|] := ClassificationLabelNameResult</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := 'Confidence: ' + Confidences[0]$'.2f'</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := '--------- '</l>
<l>            Text[|Text|] := 'Heatmap '</l>
<l>            Text[|Text|] := '--------- '</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := 'Method: ' + MethodName</l>
<l>            Text[|Text|] := 'Target class: ' + TargetClassID</l>
<l>            Text[|Text|] := ''</l>
<l>            Text[|Text|] := 'Target class confidence: ' + TargetClassConfidence$'.2f'</l>
<l>            if (SelectedHeatmapMethod == 'heatmap_confidence_based')</l>
<l>                Text[|Text|] := 'Maximum deviation: ' + MaxDeviation$'.2f'</l>
<l>            endif</l>
<c>            * </c>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            tuple_gen_const (|Text|, 'white', LineColors)</l>
<l>            if (find(SampleKeys,'image_label_id') != -1)</l>
<l>                LineColors[8] := PredictionColor</l>
<l>            endif</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', LineColors, 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'ocr_recognition_ground_truth' or KeysForDisplay[KeyIndex] == 'ocr_recognition_result' or KeysForDisplay[KeyIndex] == 'ocr_recognition_both')</l>
<c>        * </c>
<c>        * OCR Recognition.</c>
<l>        ShowGT := KeysForDisplay[KeyIndex] == 'ocr_recognition_both' or KeysForDisplay[KeyIndex] == 'ocr_recognition_ground_truth'</l>
<l>        ShowResult := KeysForDisplay[KeyIndex] == 'ocr_recognition_both' or KeysForDisplay[KeyIndex] == 'ocr_recognition_result'</l>
<l>        NumLines := ShowGT + ShowResult</l>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, NumLines * ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        full_domain (Image, Image)</l>
<l>        get_image_type (Image, Type)</l>
<l>        if (Type == 'real')</l>
<c>            * We assume that real images have been preprocessed</c>
<c>            * to the range -1,1 already. Hence, we need to rescale</c>
<c>            * them back to a visible range in byte.</c>
<l>            scale_image (Image, Image, 255.0 / 2, 127)</l>
<l>            convert_image_type (Image, Image, 'byte')</l>
<l>        endif</l>
<l>        dev_display (Image)</l>
<l>        if (ShowBottomDesc)</l>
<l>            Text := []</l>
<c>            * Ground truth.</c>
<l>            if (ShowGT)</l>
<l>                Text[|Text|] := 'Ground truth: "' + DLSample.word + '" ' + ImageIDStringBraces</l>
<l>            endif</l>
<c>            * Result.</c>
<l>            if (ShowResult)</l>
<l>                get_dict_param (DLSample, 'key_exists', 'word', GTWordKeyExists)</l>
<l>                if (GTWordKeyExists)</l>
<l>                    get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>                    get_dict_tuple (MetaInfo, KeysForDisplay[KeyIndex] + '_window_coordinates', WindowCoordinates)</l>
<l>                    get_dict_tuple (MetaInfo, KeysForDisplay[KeyIndex] + '_margin_bottom', MarginBottom)</l>
<l>                    HeightWindow := WindowCoordinates[3]</l>
<l>                    HeightMarginBottom := HeightImage * MarginBottom / (HeightWindow - MarginBottom)</l>
<l>                    Size := HeightMarginBottom / 2</l>
<l>                    Length := Size / 2</l>
<l>                    Row := HeightImage + HeightMarginBottom / 2</l>
<l>                    Column := WidthImage - 1.5 * Size</l>
<l>                    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>                    hom_mat2d_rotate (HomMat2DIdentity, rad(45), 0, 0, HomMat2DRotate)</l>
<l>                    hom_mat2d_translate (HomMat2DRotate, Row, Column, HomMat2DCompose)</l>
<l>                    if (DLResult.word == DLSample.word)</l>
<l>                        PredictionForegroundColor := 'green'</l>
<l>                        PredictionBackgroundColor := '#008000'</l>
<l>                        gen_contour_polygon_xld (PredictionSymbol, [-0.75 * Length,0, 0], [-Length,-Length,Length])</l>
<l>                    else</l>
<l>                        PredictionForegroundColor := 'red'</l>
<l>                        PredictionBackgroundColor := '#800000'</l>
<l>                        gen_contour_polygon_xld (CrossLineH, [0, 0], [-Length,Length])</l>
<l>                        gen_contour_polygon_xld (CrossLineV, [-Length,Length], [0, 0])</l>
<l>                        concat_obj (CrossLineH, CrossLineV, PredictionSymbol)</l>
<l>                    endif</l>
<l>                    affine_trans_contour_xld (PredictionSymbol, PredictionSymbol, HomMat2DCompose)</l>
<l>                    set_window_param (CurrentWindowHandle, 'background_color', PredictionBackgroundColor)</l>
<l>                    dev_clear_window ()</l>
<l>                    dev_display (Image)</l>
<l>                    dev_set_line_width (5)</l>
<l>                    dev_set_color (PredictionForegroundColor)</l>
<l>                    dev_display (PredictionSymbol)</l>
<l>                else</l>
<l>                    PredictionForegroundColor := 'white'</l>
<l>                endif</l>
<l>                if (ShowGT)</l>
<l>                    Spaces := '    '</l>
<l>                else</l>
<l>                    Spaces := ''</l>
<l>                endif</l>
<l>                Text[|Text|] := 'Deep OCR:' + Spaces + ' "' + DLResult.word + '"'</l>
<l>            endif</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_confidence')</l>
<c>        * </c>
<c>        * Segmentation confidences.</c>
<l>        get_confidence_image (ImageConfidence, ResultKeys, DLResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (ImageConfidence, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_display (ImageConfidence)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text ('Confidence image ' + ImageIDStringBraces, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_confidence_map')</l>
<c>        * </c>
<c>        * Segmentation confidence map on image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<l>        get_confidence_image (ImageConfidence, ResultKeys, DLResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, MapColorBarWidth, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<l>        dev_display_confidence_regions (ImageConfidence, MapTransparency, ConfidenceColors)</l>
<l>        dev_display_map_color_bar (WidthImage, HeightImage, MapColorBarWidth, ConfidenceColors, 1.0, WindowImageRatio, CurrentWindowHandle)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text ('Confidence map ' + ImageIDStringBraces, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_image_both')</l>
<c>        * </c>
<c>        * Ground truth and result segmentation on image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<l>        get_segmentation_image_ground_truth (SegmentationImagGroundTruth, SampleKeys, DLSample)</l>
<l>        get_segmentation_image_result (SegmentationImageResult, ResultKeys, DLResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<c>        * Display regions.</c>
<l>        ColorsResults := Colors + SegTransparency</l>
<l>        dev_set_draw ('margin')</l>
<l>        dev_set_line_width (2)</l>
<l>        dev_display_segmentation_regions (SegmentationImagGroundTruth, ClassIDs, ColorsResults, SegExcludeClassIDs, GroundTruthIDs)</l>
<l>        dev_set_line_width (6)</l>
<l>        dev_display_segmentation_regions (SegmentationImageResult, ClassIDs, ColorsResults, SegExcludeClassIDs, ResultIDs)</l>
<l>        dev_set_draw ('fill')</l>
<l>        Text := 'Ground truth and result segmentation ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            ImageClassIDsUniq := uniq(sort([GroundTruthIDs,ResultIDs]))</l>
<c>            * Get Indices according to image class IDs.</c>
<l>            tuple_gen_const (|ImageClassIDsUniq|, 0, ImageClassIDsIndices)</l>
<l>            for ImageClassIDsIndex := 0 to |ImageClassIDsUniq| - 1 by 1</l>
<l>                ImageClassIDsIndices[ImageClassIDsIndex] := find_first(ClassIDs,ImageClassIDsUniq[ImageClassIDsIndex])</l>
<l>            endfor</l>
<l>            Text := [Text,ClassesLegend[ImageClassIDsIndices]]</l>
<l>            Text[|Text| + 1] := '- thicker line: result, thinner lines: ground truth'</l>
<l>            Text[|Text|] := '  (you may have to zoom in for a more detailed view)'</l>
<l>            StringSegExcludeClassIDs := ''</l>
<l>            for StringIndex := 0 to |SegExcludeClassIDs| - 1 by 1</l>
<l>                if (StringIndex == |SegExcludeClassIDs| - 1)</l>
<l>                    StringSegExcludeClassIDs := StringSegExcludeClassIDs + SegExcludeClassIDs[StringIndex]</l>
<l>                else</l>
<l>                    StringSegExcludeClassIDs := StringSegExcludeClassIDs + SegExcludeClassIDs[StringIndex] + ', '</l>
<l>                endif</l>
<l>            endfor</l>
<l>            if (SegExcludeClassIDs != [])</l>
<l>                Text[|Text|] := '- (excluded classID(s) ' + StringSegExcludeClassIDs + ' from visualization)'</l>
<l>            endif</l>
<c>            * </c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[ImageClassIDsIndices],'white', 'white', 'white'], 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_image_diff')</l>
<c>        * </c>
<c>        * Difference of ground truth and result segmentation on image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<l>        get_segmentation_image_ground_truth (SegmentationImagGroundTruth, SampleKeys, DLSample)</l>
<l>        get_segmentation_image_result (SegmentationImageResult, ResultKeys, DLResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<l>        abs_diff_image (SegmentationImagGroundTruth, SegmentationImageResult, ImageAbsDiff, 1)</l>
<l>        min_max_gray (SegmentationImageResult, ImageAbsDiff, 0, Min, Max, Range)</l>
<l>        if (Min != Max)</l>
<l>            threshold (ImageAbsDiff, DiffRegion, 0.00001, Max)</l>
<l>            dev_set_color ('#ff0000' + SegTransparency)</l>
<l>            dev_display (DiffRegion)</l>
<l>        else</l>
<l>            dev_disp_text ('No difference found.', 'window', 'top', 'left', 'black', [], [])</l>
<l>        endif</l>
<l>        if (ShowBottomDesc)</l>
<l>            Text := 'Difference of ground truth and result segmentation ' + ImageIDStringBraces</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_image_ground_truth')</l>
<c>        * </c>
<c>        * Ground truth segmentation image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<l>        get_segmentation_image_ground_truth (SegmentationImagGroundTruth, SampleKeys, DLSample)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<c>        * Display segmentation regions.</c>
<l>        ColorsSegmentation := Colors + SegTransparency</l>
<l>        get_draw (CurrentWindowHandle, DrawMode)</l>
<l>        dev_set_draw (SegDraw)</l>
<l>        get_line_width (CurrentWindowHandle, Width)</l>
<l>        dev_set_line_width (LineWidth)</l>
<l>        dev_display_segmentation_regions (SegmentationImagGroundTruth, ClassIDs, ColorsSegmentation, SegExcludeClassIDs, ImageClassIDs)</l>
<l>        dev_set_draw (DrawMode)</l>
<l>        dev_set_line_width (int(Width))</l>
<l>        Text := 'Ground truth segmentation ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            ImageClassIDsUniq := uniq(sort(ImageClassIDs))</l>
<c>            * Get Indices according to image class IDs.</c>
<l>            tuple_gen_const (|ImageClassIDsUniq|, 0, ImageClassIDsIndices)</l>
<l>            for ImageClassIDsIndex := 0 to |ImageClassIDsUniq| - 1 by 1</l>
<l>                ImageClassIDsIndices[ImageClassIDsIndex] := find_first(ClassIDs,ImageClassIDsUniq[ImageClassIDsIndex])</l>
<l>            endfor</l>
<l>            Text := [Text,ClassesLegend[ImageClassIDsIndices]]</l>
<c>            * </c>
<c>            * Get or open next child window</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[ImageClassIDsIndices]], 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_image_result')</l>
<c>        * </c>
<c>        * Result segmentation on image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<l>        get_segmentation_image_result (SegmentationImageResult, ResultKeys, DLResult)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<c>        * </c>
<c>        * Display result segmentation regions.</c>
<l>        ColorsResults := Colors + SegTransparency</l>
<l>        get_draw (CurrentWindowHandle, DrawMode)</l>
<l>        dev_set_draw (SegDraw)</l>
<l>        get_line_width (CurrentWindowHandle, Width)</l>
<l>        dev_set_line_width (LineWidth)</l>
<l>        dev_display_segmentation_regions (SegmentationImageResult, ClassIDs, ColorsResults, SegExcludeClassIDs, ImageClassIDs)</l>
<l>        dev_set_draw (DrawMode)</l>
<l>        dev_set_line_width (int(Width))</l>
<l>        Text := 'Result segmentation ' + ImageIDStringBraces</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text (Text, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Display the legend.</c>
<l>        if (ShowLegend)</l>
<l>            ImageClassIDsUniq := uniq(sort(ImageClassIDs))</l>
<c>            * Get Indices according to image class IDs.</c>
<l>            tuple_gen_const (|ImageClassIDsUniq|, 0, ImageClassIDsIndices)</l>
<l>            for ImageClassIDsIndex := 0 to |ImageClassIDsUniq| - 1 by 1</l>
<l>                ImageClassIDsIndices[ImageClassIDsIndex] := find_first(ClassIDs,ImageClassIDsUniq[ImageClassIDsIndex])</l>
<l>            endfor</l>
<l>            Text := [Text,ClassesLegend[ImageClassIDsIndices]]</l>
<c>            * </c>
<c>            * Get or open next child window.</c>
<l>            get_child_window (HeightImage, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], WindowImageRatio, PrevWindowCoordinates)</l>
<l>            dev_disp_text (Text, 'window', 'top', 'left', ['white',Colors[ImageClassIDsIndices]], 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_weight')</l>
<c>        * </c>
<c>        * Weight image.</c>
<l>        get_weight_image (ImageWeight, SampleKeys, DLSample)</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (ImageWeight, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, 0, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<l>        dev_display (ImageWeight)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text ('Weight image ' + ImageIDStringBraces, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    elseif (KeysForDisplay[KeyIndex] == 'segmentation_weight_map')</l>
<c>        * </c>
<c>        * Weight map on image.</c>
<l>        get_dl_sample_image (Image, SampleKeys, DLSample, 'image')</l>
<l>        get_weight_image (ImageWeight, SampleKeys, DLSample)</l>
<c>        * </c>
<l>        if (SegMaxWeight == 0)</l>
<c>            * Calculate SegMaxWeight if not given in GenParam.</c>
<l>            min_max_gray (ImageWeight, ImageWeight, 0, MinWeight, SegMaxWeight, Range)</l>
<l>        endif</l>
<c>        * </c>
<c>        * Get or open next window.</c>
<l>        get_image_size (Image, WidthImage, HeightImage)</l>
<l>        get_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, MapColorBarWidth, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, KeysForDisplay[KeyIndex], CurrentWindowHandle, WindowImageRatio, PrevWindowCoordinates)</l>
<c>        * </c>
<c>        * Visualization.</c>
<l>        dev_display (Image)</l>
<l>        dev_display_weight_regions (ImageWeight, MapTransparency, SegMaxWeight, WeightsColors)</l>
<l>        dev_display_map_color_bar (WidthImage, HeightImage, MapColorBarWidth, WeightsColors, SegMaxWeight, WindowImageRatio, CurrentWindowHandle)</l>
<l>        if (ShowBottomDesc)</l>
<l>            dev_disp_text ('Weight map ' + ImageIDStringBraces, 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>        endif</l>
<l>    else</l>
<c>        * Reset flush buffer of existing windows before throwing an exception.</c>
<l>        get_dict_param (WindowHandleDict, 'keys', [], WindowHandleKeys)</l>
<l>        for Index := 0 to |WindowHandleKeys| - 1 by 1</l>
<c>            * Only consider the WindowHandleKeys that are needed for the current visualization.</c>
<l>            Indices := find(KeysForDisplay,WindowHandleKeys[Index])</l>
<l>            if (Indices != -1 and Indices != [])</l>
<l>                get_dict_tuple (WindowHandleDict, WindowHandleKeys[Index], WindowHandles)</l>
<l>                for WindowIndex := 0 to |WindowHandles| - 1 by 1</l>
<c>                    * Reset values of windows that have been changed temporarily.</c>
<l>                    set_window_param (WindowHandles[WindowIndex], 'flush', FlushValues[Index])</l>
<l>                endfor</l>
<l>            endif</l>
<l>        endfor</l>
<l>        throw ('Key for display unknown: ' + KeysForDisplay[KeyIndex])</l>
<l>    endif</l>
<c>    * </c>
<l>    KeyIndex := KeyIndex + 1</l>
<l>endwhile</l>
<c>* </c>
<c>* Display results.</c>
<l>get_dict_param (WindowHandleDict, 'keys', [], WindowHandleKeysNew)</l>
<l>for Index := 0 to |WindowHandleKeysNew| - 1 by 1</l>
<c>    * Only consider the WindowHandleKeys that are needed for the current visualization.</c>
<l>    KeyIndex := find(KeysForDisplay,WindowHandleKeysNew[Index])</l>
<l>    if (KeyIndex != -1 and KeyIndex != [])</l>
<l>        get_dict_tuple (WindowHandleDict, WindowHandleKeysNew[Index], WindowHandles)</l>
<l>        for WindowIndex := 0 to |WindowHandles| - 1 by 1</l>
<c>            * Display content of window handle.</c>
<l>            if (|WindowHandleKeys| == |WindowHandleKeysNew|)</l>
<c>                * Reset values of windows that have been changed temporarily.</c>
<l>                if (FlushValues[WindowIndex] == 'true')</l>
<l>                    flush_buffer (WindowHandles[WindowIndex])</l>
<l>                endif</l>
<l>                set_window_param (WindowHandles[WindowIndex], 'flush', FlushValues[WindowIndex])</l>
<l>            else</l>
<c>                * Per default, 'flush' of new windows should be set to 'true'.</c>
<l>                flush_buffer (WindowHandles[WindowIndex])</l>
<l>                set_window_param (WindowHandles[WindowIndex], 'flush', 'true')</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Display the point cloud together with the 3D gripping pose.</c>
<c>* Please note that a blocking window is opened showing a 3D point cloud.</c>
<c>* The window has a continue button that has to be pressed to end the blocking.</c>
<l>get_dict_param (WindowHandleDict, 'keys', [], WindowHandleKeysNew)</l>
<l>for Index := 0 to |WindowHandleKeysNew| - 1 by 1</l>
<l>    if (WindowHandleKeysNew[Index] == 'point_cloud')</l>
<c>        * Only consider the WindowHandleKeys that are needed for the current visualization.</c>
<l>        KeyIndex := find(KeysForDisplay,WindowHandleKeysNew[Index])</l>
<l>        if (KeyIndex != -1 and KeyIndex != [])</l>
<l>            get_dict_tuple (WindowHandleDict, 'point_cloud', WindowHandle)</l>
<l>            PointCloudDict := dict{arrow_length: ArrowLength, arrow_thickness: ArrowThickness, sample_point_cloud: SamplePointCloud, point_cloud_sample_distance: PointCloudSampleDistance, show_normals: PointCloudShowNormals, point_cloud_color: PointCloudColor, normal_color: PointCloudColorNormals}</l>
<l>            visualize_point_cloud_and_gripping_pose (DLSample, DLResult, PointCloudDict, WindowHandle)</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_dl_data">
<abstract lang="en_US">This procedure displays the content of the provided DLSample and/or DLResult depending on the input string KeysForDisplay.

DLDatasetInfo is either a dictionary containing the information about the dataset or the deep learning model handle which contains the class IDs and class names.

WindowHandleDict gives the handles of the windows used for the display.

The dictionary GenParam allows you to customize the display.

The dictionary WindowHandleDict can specify the handles of the windows in which the images are to be shown or it can be an empty dictionary.
In the latter case, the required windows are opened and their handles are stored here.

### Options for data display

KeysForDisplay determines, what is shown in the image. Thereby, the following values are possible depending on the model type:
- for all model types:
   - *'image'*: Input image.
- for models of type *'3d_gripping_point_detection'*:
   - *'image_with_domain'*: Input image with its domain.
   - *'normals'*: Image triple that contains the normals.
   - *'gripping_confidence'*: Image with the raw uncalibrated softmax values.
   - *'gripping_map'*: Input image with two different, colored regions indicating for each pixel whether the model predicted a gripping point or not.
   - *'xyz'*: Image triple that contains the X, Y and Z coordinates of 3D points.
   - *'x'*: Image that contains the X coordinates of 3D points.
   - *'y'*: Image that contains the Y coordinates of 3D points.
   - *'z'*: Image that contains the Z coordinates of 3D points.
   - *'gripping_heatmap'*: Heatmap image based on the *'gripping_confidence'* with the model predicted gripping points.
   - *'gripping_points'*: Input image with the model predicted gripping points.
   - *'point_cloud'*: Texturized 3D point cloud of the scene with the model predicted gripping points.
- for models of type *'anomaly_detection'* or *'gc_anomaly_detection'*:
   - *'anomaly_ground_truth'*: Image with ground truth label, if one exists.
   - *'anomaly_result'*: Image with predicted anomaly regions: the regions in anomaly_image with values larger *'anomaly_region_threshold'*.
   - *'anomaly_both'*: Image with ground truth label (if one exists) and predicted anomaly regions. For models of type *'gc_anomaly_detection'* which predicted anomaly regions are shown depends on the available keys in DLResult (local, global, or both).
   - *'anomaly_image'*: Image with the predicted *'anomaly_image'*, whose values are transformed into an RGB-image.
- for models of type *'gc_anomaly_detection'*:
   - *'anomaly_image_local'*: Image with the predicted *'anomaly_image_local'*, whose values are transformed into an RGB-image.
   - *'anomaly_image_global'*: Image with the predicted *'anomaly_image_global'*, whose values are transformed into an RGB-image.
   - *'anomaly_result_local'*: Image with predicted anomaly regions: the regions in anomaly_image_local with values larger *'anomaly_region_threshold'*.
   - *'anomaly_result_global'*: Image with predicted anomaly regions: the regions in anomaly_image_global with values larger *'anomaly_region_threshold'*.
- for models of type *'classification'*:
   - *'classification_ground_truth'*: Image with ground truth label.
   - *'classification_result'*: Image with the predicted class.
   - *'classification_both'*: Image with both, its ground truth label and the predicted class.
   - *'heatmap_confidence_based'*: Heatmap image and prediction information. The heatmap must be generated using the procedure &lt;proc:gen_dl_model_classification_heatmap&gt;.
   - *'heatmap_grad_cam'*: Heatmap image and prediction information for method 'grad_cam'. The heatmap must be generated before using the operator &lt;op:gen_dl_model_heatmap&gt; with *'grad_cam'*.
   - *'heatmap_guided_grad_cam'*: Heatmap image and prediction information for method *'guided_grad_cam'*. The heatmap must be generated before using the operator &lt;op:gen_dl_model_heatmap&gt; with *'guided_grad_cam'*.
- for models of type *'detection'*:
   - *'bbox_ground_truth'*: Image with the ground truth bounding boxes.
   - *'bbox_result'*: Image with the detected objects.
   - *'bbox_both'*: Image with both, the ground truth bounding boxes and the detected objects.
- for models of type *'segmentation'*:
   - *'segmentation_image_ground_truth'*: Input image, where the ground truth classes are displayed according to the defined style.
   - *'segmentation_image_result'*: Input image, where the inferred classes are displayed according to the defined style.
   - *'segmentation_image_both'*: Input image with the inferred classes and the ground truth classes marked by surrounding lines of different widths.
   - *'segmentation_image_diff'*: Input image with regions, showing the difference between the inferred and ground truth classes.&lt;br/&gt;
      In case no difference is found, this is mentioned.
   - *'segmentation_confidence'*: Confidence image, where the confidence values are displayed as gray values.
   - *'segmentation_confidence_map'*: RGB image, where the confidence values are displayed as semi-transparent regions over the input image.
   - *'segmentation_weight'*: Weight image, where the weights are displayed as gray values.
   - *'segmentation_weight_map'*: RGB image, where the weights are displayed as semi-transparent regions over the input image.
- for Deep OCR recognition models:
   - *'ocr_recognition_ground_truth'*: Image with ground truth word.
   - *'ocr_recognition_result'*: Image with the predicted word.
   - *'ocr_recognition_both'*: Image with both, its ground truth word and the predicted word.

For all models except Deep OCR models and the 3D gripping point detection, the relevant entries in DLDatasetInfo are: *'class_names'*, *'class_ids'*. The tuples should represent all class ids that are given in the input sample or result. We recommend to use DLDataset, if available. As DLDatasetInfo also a deep learning model handle can be given, from which the *'class_names'* and *'class_ids'* can be retrieved.
If DLDatasetInfo is given as an empty tuple, the class names are shown as *'unknown'* and the class ids are automatically determined by the input sample and result.

For models of type *'detection'*, if the DLSample and/or DLResult contains instance regions under the key 'mask', they will be visualized. If box-annotations (rectangle1 or rectangle2) are also given, they are visualized additionally. If both box-types are present, rectangle2 will be shown.

### Options for the display customization

The display can be customized through specifications in GenParam. The entries available depend on the model type.

#### Models of all types.
Following specifications in GenParam are possible:
- `'threshold_width'`: Define when a new row of windows is started.&lt;br/&gt;
   The value is given in pixels.&lt;br/&gt;
   Note, if one KeysForDisplay opens multiple windows, these windows are placed next to each other.
   *Default*: *1024*.
- `'scale_windows'` : Determine the size of the windows.&lt;br/&gt;
  The value has to be &gt;0, adapt it according to your screen resolution and desired visualization.&lt;br/&gt;
  *Default*: *0.8*.
- `'font'`: Set the font style used in &lt;proc:set_display_font&gt;.&lt;br/&gt;
  *Default*: *'mono'*.
- `'font_size'`: Set the font size used in &lt;proc:set_display_font&gt;.&lt;br/&gt;
  *Default*: *14*.
- `'line_width'`: Set the width of all displayed lines.&lt;br/&gt;
  The value has to be an integer.&lt;br/&gt;
  *Default*: *2*.
- `'display_legend'`: Determine, whether to display the legend in an additional window next to the image window or not.
  *Default*: *true*.
- `'display_bottom_desc'`: Determine, whether to display image description at the bottom of the graphics window or not.
  *Default*: *true*.

#### Models of *'type'* *'3d_gripping_point_detection'*
Following specifications in GenParam are additionally possible:
- `'arrow_length'`: Set the length [m] of the arrows of the 3D object model that represents the 3D gripping points.&lt;br/&gt;
   *Default*: *0.1*.
- `'arrow_thickness'`: Set the thickness [m] of the arrows of the 3D object model that represents the 3D gripping points.&lt;br/&gt;
   *Default*: *0.005*.
- `'gripping_point_color'`: Set the color and alpha value of the crosses of the predicted gripping points as hexadecimal RGBA quadruplet.&lt;br/&gt;
   *Default*: *'#00FF0099'*.
- `'gripping_point_size'`: Set the size [pixel] of the crosses of the model predicted gripping points.&lt;br/&gt;
   *Default*: *6*.
- `'region_color'`: Set the color and the alpha value of the domain that is displayed for *'gripping_map'* as hexadecimal RGBA quadruplet.&lt;br/&gt;
   *Default*: *'#FF000040'*.
- `'point_cloud_color'`: Set the color of the points of the 3D point cloud.&lt;br/&gt;
   For possible values see the operator &lt;op:disp_object_model_3d&gt; .&lt;br/&gt;
   *Default*: *No color set*.
- `'normal_color'`: Set the color of the normals of the 3D point cloud. This has only an effect if *'show_normals'* has been set to *'true'*.&lt;br/&gt;
   For possible values see the operator &lt;op:disp_object_model_3d&gt; .&lt;br/&gt;
   *Default*: *No color set*.
- `'show_normals'`: Determine, whether the 3D point cloud should be visualized with normals.&lt;br/&gt;
   *Default*: *false*.
- `'sample_point_cloud'`: Determine, whether the 3D point cloud should be sampled.&lt;br/&gt;
   *Default*: *false*.
- `'point_cloud_sample_distance'`: Set the sampling distance [pixel] for the sampling of the 3D point cloud. This has only an effect if *'sample_point_cloud'* has been set to *'true'*.&lt;br/&gt;
   *Default*: *10*.
- `'heatmap_color_scheme'`: Determine the color scheme used for the display of the *'gripping_heatmap'* and the *'gripping_map'*.&lt;br/&gt;
   For possible values see the procedure &lt;proc:apply_colorscheme_on_gray_value_image&gt; .&lt;br/&gt;
   *Default*: *'jet'*.

#### Models of *'type'* *'anomaly_detection'*
Following specifications in GenParam are additionally possible:
- `'anomaly_region_threshold'`: Set the threshold for values in anomaly_image to be displayed as anomaly region.&lt;br/&gt;
   If not specified, the anomaly region in DLResult is displayed (if given).&lt;br/&gt;
   In case an anomaly region is available in DLResult and a threshold is provided, the latter will be used for display.
   *Default*: *-1*, which means that no threshold value is specified.
- `'anomaly_classification_threshold'`: Set the threshold to classify the anomaly score as *'ok'* or *'nok'*.&lt;br/&gt;
   If not specified, the anomaly class ID in DLResult is displayed (if given).&lt;br/&gt;
   In case a class ID is available in DLResult and a threshold is provided, the latter will be used for display.
   *Default*: *-1*, which means that no threshold value is specified.
- `'anomaly_region_label_color'`: Set the color and alpha value of the labeled regions as hexadecimal RGBA quadruplet.&lt;br/&gt;
   *Default*: *'#ff0000c0'*.
- `'anomaly_region_result_color'`: Set the color of the label of the predicted regions as hexadecimal RGB triplet.&lt;br/&gt;
   *Default*: *'#ff4500'*.
- `'anomaly_color_transparency'`: Set the alpha value used as hexadecimal number within an RGBA quadruplet for the predicted anomaly regions.&lt;br/&gt;
   *Default*: *'80'*.
- `'display_ground_truth_anomaly_regions'`: Determine, whether to display the ground truth labeled regions if they are present.&lt;br/&gt;
   *Default*: *true*.

#### Models of *'type'* *'classification'*
Following specifications in GenParam are additionally possible:
- `'display_classification_ids'`: Determine, whether to display the classification class IDs (ground truth/result) or not.&lt;br/&gt;
   *Default*: *true*.
- `'display_classification_color_frame'`: Determine, whether to display a frame which shows the prediction through a color (green: prediction is correct, red: prediction is wrong).&lt;br/&gt;
   *Default*: *true*.
- `'heatmap_color_scheme'`: Determine the color scheme used for the display of the model heatmap (only applicable for method 'grad_cam').&lt;br/&gt;
   For possible values see the procedure &lt;proc:apply_colorscheme_on_gray_value_image&gt; .&lt;br/&gt;
   *Default*: *'jet'*.

#### Models of *'type'* *'detection'*
Following specifications in GenParam are additionally possible:
- `'bbox_label_color'`: Set the color and alpha value of the label as hexadecimal RGBA quadruplet.&lt;br/&gt;
   *Default*: *'#00000099'*.
- `'bbox_display_confidence'`: Specify, if the confidence values are displayed in the label.&lt;br/&gt;
   *Default*: *true*.
- `'bbox_text_color'`: Define the color of the text within the bounding boxes.&lt;br/&gt;
   *Default*: *'white'*.
- `'display_labels'` : Determine, whether to display the bounding box labels or not.&lt;br/&gt;
   *Default*: *true*.
- `'display_direction'`: Determine, whether to indicate the direction of the instance within the bounding box by an arrow or not.&lt;br/&gt;
   Only for *'instance_type'* *'rectangle2'*.&lt;br/&gt;
   *Default*: *true*.

#### Models of *'type'* *'segmentation'*
Following specifications in GenParam are additionally possible:
- `'map_transparency'`: Set the alpha value used as hexadecimal number within an RGBA quadruplet
       when drawing a map (*'segmentation_weight_map'*, *'segmentation_confidence_map'*).&lt;br/&gt;
   Range: *00* to *ff*.&lt;br/&gt;
   *Default*: *'cc'*.
- `'map_color_bar_width'`: Determine the width of the color bar for a map (*'segmentation_weight_map'*, *'segmentation_confidence_map'*).&lt;br/&gt;
   *Default*: *140*.
- `'segmentation_max_weight'`: Set the maximum weight value for the color bar range.&lt;br/&gt;
    For a value of *0*, it is computed automatically for each image individually, while else the value has to be at least the largest weight occurring for all samples displayed.&lt;br/&gt;
   *Default*: *0.0*.
- `'segmentation_draw'`: Set the drawing style.&lt;br/&gt;
   Following values are possible:
   - *'fill'* (default): The regions are marked by colored areas.
   - *'margin'*: The regions are marked by surrounding lines.
- `'segmentation_transparency'`: Set the alpha value used as hexadecimal number within an RGBA quadruplet for the drawn segmentation regions.&lt;br/&gt;
    Range: *00* to *ff*.
   *Default*: *'aa'*.
- `'segmentation_exclude_class_ids'` : Set the IDs of classes which will not be displayed.&lt;br/&gt;
   *Default*: *[]*.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Visualize different images, annotations and inference results for a sample.</short>
<parameters>
<parameter id="DLDatasetInfo">
<description lang="en_US">Dictionary containing information about the dataset or a deep learning model handle which was used to get DLResult.

This parameter can be an empty tuple []. If that is the case, it is tried to infer the existing class ids from the given DLSample or DLResult. If a DLResult from a classification or detection model is given, also the class names are inferred from the DLResult. Otherwise the class names are given as 'unknown'.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLResult">
<default_value>[]</default_value>
<description lang="en_US">Dictionary containing the results obtained for the specified sample.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_value>[]</default_value>
<description lang="en_US">Dictionary of the sample to be visualized.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary containing the generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="KeysForDisplay">
<default_type>string</default_type>
<description lang="en_US">Determines the requested visualizations.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'image'</item>
<item>'classification_ground_truth'</item>
<item>'classification_result'</item>
<item>'classification_both'</item>
<item>'segmentation_weight'</item>
<item>'segmentation_weight_map'</item>
<item>'segmentation_confidence'</item>
<item>'segmentation_confidence_map'</item>
<item>'bbox_ground_truth'</item>
<item>'bbox_result'</item>
<item>'bbox_both'</item>
<item>'segmentation_image_ground_truth'</item>
<item>'segmentation_image_result'</item>
<item>'segmentation_image_both'</item>
<item>'segmentation_image_diff'</item>
</values>
</parameter>
<parameter id="WindowHandleDict">
<description lang="en_US">Dictionary containing the window handles to be used.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_dl_samples_from_images">
<interface>
<io>
<par name="Images" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="DLSampleBatch" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure creates DLSampleBatch, a tuple</c>
<c>* containing a dictionary DLSample</c>
<c>* for every image given in Images.</c>
<c>* </c>
<c>* Initialize output tuple.</c>
<l>count_obj (Images, NumImages)</l>
<l>DLSampleBatch := gen_tuple_const(NumImages,-1)</l>
<c>* </c>
<c>* Loop through all given images.</c>
<l>for ImageIndex := 0 to NumImages - 1 by 1</l>
<l>    select_obj (Images, Image, ImageIndex + 1)</l>
<c>    * Create DLSample from image.</c>
<l>    create_dict (DLSample)</l>
<l>    set_dict_object (Image, DLSample, 'image')</l>
<c>    * </c>
<c>    * Collect the DLSamples.</c>
<l>    DLSampleBatch[ImageIndex] := DLSample</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_dl_samples_from_images">
<abstract lang="en_US">This procedure creates DLSampleBatch, a tuple containing a dictionary DLSample for every image given in Images.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Store the given images in a tuple of dictionaries DLSamples.</short>
<parameters>
<parameter id="DLSampleBatch">
<default_type>integer</default_type>
<description lang="en_US">Tuple of DLSample dictionaries.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Images">
<description lang="en_US">Images to be stored as DLSamples in the output dictionary DLSampleBatch.</description>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_samples">
<interface>
<ic>
<par name="DLSampleBatch" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure preprocesses all images of the sample dictionaries</c>
<c>* in the tuple DLSampleBatch.</c>
<c>* The images are preprocessed according to the parameters provided</c>
<c>* in DLPreprocessParam.</c>
<c>* </c>
<c>* Check the validity of the preprocessing parameters.</c>
<c>* The procedure check_dl_preprocess_param might change DLPreprocessParam.</c>
<c>* To avoid race conditions when preprocess_dl_samples is used from</c>
<c>* multiple threads with the same DLPreprocessParam dictionary,</c>
<c>* work on a copy.</c>
<l>copy_dict (DLPreprocessParam, [], [], DLPreprocessParam)</l>
<l>* check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* </c>
<c>* </c>
<c>* Preprocess the sample entries.</c>
<c>* </c>
<l>for SampleIndex := 0 to |DLSampleBatch| - 1 by 1</l>
<l>    DLSample := DLSampleBatch[SampleIndex]</l>
<c>    * </c>
<c>    * Preprocess augmentation data.</c>
<c>    * </c>
<c>    * </c>
<c>    * Preprocess the images.</c>
<c>        * </c>
<c>        * Get the image.</c>
<l>        get_dict_object (ImageRaw, DLSample, 'image')</l>
<c>        * </c>
<c>        * Preprocess the image.</c>
<l>        preprocess_dl_model_images (ImageRaw, ImagePreprocessed, DLPreprocessParam)</l>
<c>        * </c>
<c>        * Replace the image in the dictionary.</c>
<l>        set_dict_object (ImagePreprocessed, DLSample, 'image')</l>
<c>        * </c>
<c>        * Check existence of model specific sample keys:</c>
<c>        * - 'anomaly_ground_truth':</c>
<c>        *   For model 'type' = 'anomaly_detection' and</c>
<c>        *   model 'type' = 'gc_anomaly_detection'</c>
<c>        * - 'bbox_row1':</c>
<c>        *   For 'instance_type' = 'rectangle1' and</c>
<c>        *   model 'type' = 'detection'</c>
<c>        * - 'bbox_phi':</c>
<c>        *   For 'instance_type' = 'rectangle2' and</c>
<c>        *   model 'type' = 'detection'</c>
<c>        * - 'mask':</c>
<c>        *   For 'instance_type' = 'rectangle1',</c>
<c>        *   model 'type' = 'detection', and</c>
<c>        *   'instance_segmentation' = true</c>
<c>        * - 'segmentation_image':</c>
<c>        *   For model 'type' = 'segmentation'</c>
<l>        get_dict_param (DLSample, 'key_exists', ['anomaly_ground_truth', 'bbox_row1', 'bbox_phi', 'mask', 'segmentation_image'], KeysExists)</l>
<l>        AnomalyParamExist := KeysExists[0]</l>
<l>        Rectangle1ParamExist := KeysExists[1]</l>
<l>        Rectangle2ParamExist := KeysExists[2]</l>
<l>        InstanceMaskParamExist := KeysExists[3]</l>
<l>        SegmentationParamExist := KeysExists[4]</l>
<c></c>
<l>endfor</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="preprocess_dl_samples">
<abstract lang="en_US">This procedure preprocesses all images of the sample dictionaries in the tuple DLSampleBatch.

The images are preprocessed according to the parameters provided in DLPreprocessParam.

The preprocessing results overwrite the entries in the according sample dictionary `DLSample`.

If 3D information is given in `DLSample` as 'x','y','z' or 'normals', those images are also preprocessed. Please refer to &lt;proc:preprocess_dl_model_3d_data&gt; for details.

The following model parameters influence the preprocessing:
- *'image_height'*, *'image_width'*: See the documentation of &lt;op:get_dl_model_param&gt;.
- *'image_range_min'*, *'image_range_max'*: See the documentation of &lt;op:get_dl_model_param&gt;.
- *'image_num_channels'*: See the documentation of &lt;op:get_dl_model_param&gt;.
- *'domain_handling'*: The following values are possible:
   - *'full_domain'* (default): Reduced domains of images are ignored and the complete image is preprocessed. If 3D information is given in `DLSample` as 'x','y','z' or 'normals' those images keep their domain.
   - *'crop_domain'*: The image and all corresponding data are cropped to the domain that is specified in the input DLSample.image, e.g., by using &lt;op:reduce_domain&gt;. For DL models of *'type'* = *'3d_gripping_point_detection'*, image pixels outside of the cropped domains are preserved and preprocessed as well.&lt;br/&gt;
   If 'crop_domain' is chosen, all other data in the DLSample that has the same coordinate system as DLSample.image is cropped to the same smallest rectangle of the domain of DLSample.image. This can be e.g., a segmentation image, the weight image, bounding box coordinates or any present 3D information ('x','y','z' and 'normals').&lt;br/&gt;
   - *'keep_domain'*: The preprocessed images have the same domain as the original images.&lt;br/&gt;
   If the image size is changed during the preprocessing, the domains are zoomed accordingly.&lt;br/&gt;
   If a sample contains the key *'anomaly_ground_truth'*, the stored anomaly ground truth also keeps its domain.&lt;br/&gt;
   The option *'keep_domain'* is only available for preprocessing parameters corresponding to DL models of *'type'* = *'anomaly_detection'* or *'3d_gripping_point_detection'*. For models of *'type'* = *'3d_gripping_point_detection'*, image pixels outside of the defined domains are preserved and preprocessed as well.
- *'normalization_type'*: Depending on the images, it can be beneficial to apply a normalization.&lt;br/&gt;
   The following types are available:
   - *'none'* (default value): No normalization is applied on the images.
   - *'all_channels'*: The gray values of every image are scaled to the maximum value range.&lt;br/&gt;
      During this scaling, the image is converted temporarily to a 'byte' image.
   - *'first_channel'*: The gray values of the first channel of every image are scaled to the maximum value range.&lt;br/&gt;
      During this scaling, the image is converted temporarily to a 'byte' image.
   - *'constant_values'*: The gray values of every image are scaled with constant values, namely for every channel i the pixel value p_i gets the mean value m(i) subtracted and the result divided by the standard deviation d(i).&lt;br/&gt;
      Note, the mean and standard deviation values need to be tuples with lengths equal to the number of image channels.&lt;br/&gt;
      If you do not want to use the default values, you can set the values (which have to be in the gray value range of the input images) by setting the following keys in the dictionary with the preprocessing parameters:
      - `'mean_values_normalization'`: Tuple with the mean values to be subtracted, denoted above with m.
      - `'deviation_values_normalization'`: Tuple with the standard deviations used as divisor, denoted above with d.
- *'set_background_id'*: In case of a segmentation model, it might be wanted to set indices of certain classes to the ID of a given background class, given through this parameter.&lt;br/&gt;
   Possible values:
   - empty tuple *[]* (default): No changes will be applied.
   - class ID: Note, this class ID is not part of the *'class_ids_background'*.
- *'class_ids_background'*: Class IDs that should be additionally set to the Background Class ID given through *'set_background_id'*, thus, the ID given in *'set_background_id'* is not to be included.&lt;br/&gt;
   *Default*: *[]*.
- *'min_z'*: If a depth image is given in a DLSample as key *'z'*, the domain is reduced to include only pixels greater or equal to the parameter value (c.f. &lt;proc:preprocess_dl_model_3d_data&gt;).&lt;br/&gt;
   *Default*: not set.
- *'max_z'*: If a depth image is given in a DLSample as key *'z'*, the domain is reduced to include only pixels less or equal to the parameter value (c.f. &lt;proc:preprocess_dl_model_3d_data&gt;).&lt;br/&gt;
   *Default*: not set.
- *'normal_image_width'*: If 3D data is given in a DLSample as keys *'x'*, *'y'* and *'z'*, the computation of normals is done at the given resolution. (c.f. &lt;proc:preprocess_dl_model_3d_data&gt;).&lt;br/&gt;
   *Default*: 1.5 * *'image_width'*.
- *'normal_image_height'*: If 3D data is given in a DLSample as keys *'x'*, *'y'* and *'z'*, the computation of normals is done at the given resolution. (c.f. &lt;proc:preprocess_dl_model_3d_data&gt;).&lt;br/&gt;
   *Default*: 1.5 * *'image_height'*.

The dictionary DLPreprocessParam can be created using e.g., &lt;proc:create_dl_preprocess_param&gt; or &lt;proc:create_dl_preprocess_param_from_model&gt;.

It is recommended to check the output images of this procedure in order to verify that they are suitable for a successful training of a model. For example, if defects on the images are no longer discernible after zooming, it might help to increase the image dimensions.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess given DLSamples according to the preprocessing parameters given in DLPreprocessParam.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the necessary preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSampleBatch">
<default_type>integer</default_type>
<default_value>DLSampleBatch</default_value>
<description lang="en_US">Tuple of DLSample dictionaries.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_dl_data_get_max_class_id" access="local">
<interface>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MaxClassId" base_type="ctrl" dimension="0"/>
<par name="Empty" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>MaxClassId := -1</l>
<l>Empty := false</l>
<l>try</l>
<l>    get_dict_param (DLSample, 'keys', [], Keys)</l>
<c>    * Find keys that end on '_id'. (They contain ids!)</c>
<l>    tuple_regexp_match (Keys, '_id', Matches)</l>
<l>    tuple_strlen (Matches, Length)</l>
<l>    tuple_greater_equal_elem (Length, 1, Greatereq)</l>
<l>    tuple_find (Greatereq, 1, Indices)</l>
<l>    if (Indices &gt; -1)</l>
<c>        * Find the maximum given class id.</c>
<l>        LengthAll := 0</l>
<l>        for KeyIndex := 0 to |Indices| - 1 by 1</l>
<l>            Key := Keys[Indices[KeyIndex]]</l>
<c>            * Skip image_id.</c>
<l>            if (Key == 'image_id')</l>
<l>                continue</l>
<l>            endif</l>
<l>            get_dict_param (DLSample, 'key_data_type', Key, KeyType)</l>
<l>            if (KeyType != 'tuple')</l>
<l>                continue</l>
<l>            endif</l>
<l>            get_dict_tuple (DLSample, Key, Tuple)</l>
<l>            LengthAll := LengthAll + |Tuple|</l>
<l>            if (|Tuple| == 0)</l>
<l>                continue</l>
<l>            endif</l>
<l>            tuple_max (Tuple, MaxTuple)</l>
<l>            if (MaxTuple &gt; MaxClassId)</l>
<l>                MaxClassId := MaxTuple</l>
<l>            endif</l>
<l>        endfor</l>
<l>        if (LengthAll == 0)</l>
<l>            Empty := true</l>
<l>        endif</l>
<l>    endif</l>
<l>catch (Exception)</l>
<c>    * Ignore any exception.</c>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="dev_display_dl_data_get_max_class_id">
<abstract lang="en_US">Try to guess the maximum class id based on the given sample/result.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Try to guess the maximum class id based on the given sample/result.</short>
<parameters>
<parameter id="DLSample">
<default_type>integer</default_type>
<description lang="en_US">Input sample or result.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Empty">
<default_type>integer</default_type>
<description lang="en_US">Returns true if the input DLSample contains no ground-truth or result.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
<value_min>0</value_min>
<values>
<item>0</item>
<item>1</item>
</values>
</parameter>
<parameter id="MaxClassId">
<default_type>integer</default_type>
<description lang="en_US">Maximum class id used in the parameter DLSample.
If no class id can be found this output parameter is -1.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>-1</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_dl_class_colors" access="local">
<interface>
<ic>
<par name="ClassNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Colors" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns for each class a certain color.</c>
<c>* </c>
<c>* Define distinct colors for the classes.</c>
<l>NumColors := |ClassNames|</l>
<c>* Get distinct colors without randomness makes neighboring colors look very similar.</c>
<c>* We use a workaround to get deterministic colors where subsequent colors are distinguishable.</c>
<l>get_distinct_colors (NumColors, false, 0, 200, ColorsRainbow)</l>
<l>tuple_inverse (ColorsRainbow, ColorsRainbow)</l>
<l>make_neighboring_colors_distinguishable (ColorsRainbow, Colors)</l>
<c>* If a class 'OK','ok', 'good' or 'GOOD' is present set this class to green.</c>
<c>* Only the first occurrence found is set to a green shade.</c>
<l>ClassNamesGood := ['good', 'GOOD', 'ok', 'OK']</l>
<l>for IndexFind := 0 to |ClassNamesGood| - 1 by 1</l>
<l>    GoodIdx := find_first(ClassNames,ClassNamesGood[IndexFind])</l>
<l>    if (GoodIdx != -1 and |ClassNames| &lt;= 8)</l>
<c>        * If number of classes is &lt;= 8, swap color with a green color.</c>
<l>        CurrentColor := Colors[GoodIdx]</l>
<l>        GreenIdx := floor(|ClassNames| / 2.0)</l>
<c>        * Set to pure green.</c>
<l>        Colors[GoodIdx] := '#00ff00'</l>
<c>        * Write original color to a green entry.</c>
<l>        Colors[GreenIdx] := CurrentColor</l>
<l>        break</l>
<l>    elseif (GoodIdx != -1 and |ClassNames| &gt; 8)</l>
<c>        * If number of classes is larger than 8, set the respective color to green.</c>
<l>        Colors[GoodIdx] := '#00ff00'</l>
<l>        break</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_dl_class_colors">
<abstract lang="en_US">Compute a color for each class in ClassNames that is distinguishable from neighboring entries in ClassNames.
If the ClassNames include 'good', GOOD', 'ok' or 'OK', the color is set to green.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate certain colors for different ClassNames</short>
<parameters>
<parameter id="ClassNames"/>
<parameter id="Colors"/>
</parameters>
</docu>
</procedure>
<procedure name="get_dl_sample_image">
<interface>
<oo>
<par name="Image" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="Key" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure returns an image with key Key of a sample.</c>
<c>* </c>
<l>if (find(SampleKeys,Key) != -1)</l>
<l>    get_dict_object (Image, DLSample, Key)</l>
<l>else</l>
<l>    throw ('Image with key \'' + Key + '\' could not be found in DLSample.')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_dl_sample_image">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<short lang="de_DE">Gibt ein Bild eines bestimmten Keys aus einem Sample zurück.</short>
<short lang="en_US">Get an image of a sample with a certain key.</short>
<parameters>
<parameter id="DLSample">
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Image">
<sem_type>image</sem_type>
</parameter>
<parameter id="Key">
<sem_type>string</sem_type>
</parameter>
<parameter id="SampleKeys">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_next_window" access="local">
<interface>
<ic>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="FontSize" base_type="ctrl" dimension="0"/>
<par name="ShowBottomDesc" base_type="ctrl" dimension="0"/>
<par name="WidthImage" base_type="ctrl" dimension="0"/>
<par name="HeightImage" base_type="ctrl" dimension="0"/>
<par name="MapColorBarWidth" base_type="ctrl" dimension="0"/>
<par name="ScaleWindows" base_type="ctrl" dimension="0"/>
<par name="ThresholdWidth" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinates" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
<par name="WindowHandleKey" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CurrentWindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowImageRatioHeight" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinatesOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the next window that</c>
<c>* is used for visualization. If ReuseWindows is true</c>
<c>* and WindowHandleList is suitable, the window handles</c>
<c>* that are passed over are used. Else, this procedure</c>
<c>* opens a new window, either next to the last ones, or</c>
<c>* in a new row.</c>
<c>* </c>
<c>* First, check if the requested window is already available.</c>
<l>OpenNewWindow := false</l>
<l>try</l>
<l>    get_dict_tuple (WindowHandleDict, WindowHandleKey, WindowHandles)</l>
<l>    CurrentWindowHandle := WindowHandles[0]</l>
<c>    * Check if window handle is valid.</c>
<l>    try</l>
<l>        get_window_param (CurrentWindowHandle, 'flush', Value)</l>
<l>    catch (Exception)</l>
<c>        * If there is something wrong with the current window, create a new one.</c>
<l>        OpenNewWindow := true</l>
<l>        remove_dict_key (WindowHandleDict, WindowHandleKey)</l>
<l>    endtry</l>
<l>catch (Exception)</l>
<l>    OpenNewWindow := true</l>
<l>endtry</l>
<c>* </c>
<c>* Get next window.</c>
<l>if (not OpenNewWindow)</l>
<c>    * </c>
<c>    * If possible, reuse existing window handles.</c>
<l>    dev_set_window (CurrentWindowHandle)</l>
<l>    dev_clear_window ()</l>
<l>    set_display_font (CurrentWindowHandle, FontSize, Font, 'true', 'false')</l>
<c>    * </c>
<c>    * Calculate MarginBottom.</c>
<l>    if (ShowBottomDesc)</l>
<l>        get_string_extents (CurrentWindowHandle, 'test_string', Ascent, Descent, _, _)</l>
<l>        NumLines := ShowBottomDesc</l>
<l>        MarginBottom := NumLines * (Ascent + Descent) + 2 * 12</l>
<l>    else</l>
<l>        MarginBottom := 0</l>
<l>    endif</l>
<c>    * </c>
<c>    * Get and set meta information for current window.</c>
<l>    update_window_meta_information (CurrentWindowHandle, WidthImage, HeightImage, 0, 0, MapColorBarWidth, MarginBottom, WindowImageRatioHeight, WindowImageRatioWidth, SetPartRow2, SetPartColumn2, PrevWindowCoordinatesOut)</l>
<c>    * </c>
<c>    * Update meta information.</c>
<l>    get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_height', WindowImageRatioHeight)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_width', WindowImageRatioWidth)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_set_part_row2', SetPartRow2)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_set_part_column2', SetPartColumn2)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_margin_bottom', MarginBottom)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_map_color_bar_with', MapColorBarWidth)</l>
<l>    set_dict_tuple (MetaInfo, WindowHandleKey + '_window_coordinates', PrevWindowCoordinatesOut)</l>
<l>else</l>
<c>    * </c>
<c>    * Open a new window.</c>
<l>    open_next_window (Font, FontSize, ShowBottomDesc, WidthImage, HeightImage, MapColorBarWidth, ScaleWindows, ThresholdWidth, PrevWindowCoordinates, WindowHandleDict, WindowHandleKey, CurrentWindowHandle, WindowImageRatioHeight, PrevWindowCoordinatesOut)</l>
<l>    set_window_param (CurrentWindowHandle, 'flush', 'false')</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="get_next_window">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the next window that can be used for visualization.</short>
<parameters>
<parameter id="CurrentWindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Font">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="FontSize">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="HeightImage">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MapColorBarWidth">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinates">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinatesOut">
<default_type>integer</default_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
</values>
</parameter>
<parameter id="ScaleWindows">
<default_type>real</default_type>
<default_value>0</default_value>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ShowBottomDesc"/>
<parameter id="ThresholdWidth">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="WidthImage">
<default_type>integer</default_type>
<sem_type>extent.x</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleKey">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowImageRatioHeight">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_gripping_points_from_dict" access="local">
<interface>
<ic>
<par name="DLResult" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Rows" base_type="ctrl" dimension="0"/>
<par name="Columns" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>if (DLResult == [])</l>
<l>    throw ('DLResult dict is empty.')</l>
<l>endif</l>
<l>get_dict_param (DLResult, 'key_exists', 'gripping_points', KeyExists)</l>
<l>if (KeyExists)</l>
<l>    get_dict_tuple (DLResult, 'gripping_points', GrippingPoints)</l>
<l>else</l>
<l>    throw ('Result data could not be found in DLResult.')</l>
<l>endif</l>
<l>NumberOfResults := |GrippingPoints|</l>
<l>tuple_gen_const (NumberOfResults, 0, Rows)</l>
<l>tuple_gen_const (NumberOfResults, 0, Columns)</l>
<l>for IndexGrippingPointsPoint := 0 to |GrippingPoints| - 1 by 1</l>
<l>    GrippingPointCoordDict := GrippingPoints[IndexGrippingPointsPoint]</l>
<l>    Rows[IndexGrippingPointsPoint] := GrippingPointCoordDict.row</l>
<l>    Columns[IndexGrippingPointsPoint] := GrippingPointCoordDict.column</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_gripping_points_from_dict">
<abstract lang="en_US">This procedure extracts gripping points of the dictionary DLResult.

DLResult is the result dictionary of the 3D Gripping Point Detection. If the dictionary contains gripping points, the coordinates are returned in the tuples Rows and Columns.</abstract>
<chapters lang="de_DE">
<item>3D-Matching</item>
<item>3D Gripping Point Detection</item>
</chapters>
<chapters lang="en_US">
<item>3D Matching</item>
<item>3D Gripping Point Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Extract gripping points from a dictionary.</short>
<parameters>
<parameter id="Columns">
<description lang="en_US">Column coordinates of the gripping points.</description>
<sem_type>coordinates</sem_type>
</parameter>
<parameter id="DLResult">
<default_type>integer</default_type>
<description lang="en_US">Resulting dictionary.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Rows">
<description lang="en_US">Row coordinates of the gripping points.</description>
<sem_type>coordinates</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="add_colormap_to_image" access="local">
<interface>
<io>
<par name="GrayValueImage" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ColoredImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="HeatmapColorScheme" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure adds a gray-value image to a RGB image with a chosen color map.</c>
<c>* </c>
<l>get_image_type (GrayValueImage, Type)</l>
<c>* The image LUT needs a byte image. Rescale real images.</c>
<l>if (Type == 'real')</l>
<l>    scale_image_range (GrayValueImage, GrayValueImage, 0, 1)</l>
<l>    convert_image_type (GrayValueImage, GrayValueImage, 'byte')</l>
<l>elseif (Type != 'byte')</l>
<l>    throw ('For this transformation, a byte or real image is needed!')</l>
<l>endif</l>
<c>* </c>
<c>* Apply the chosen color scheme on the gray value.</c>
<l>apply_colorscheme_on_gray_value_image (GrayValueImage, RGBValueImage, HeatmapColorScheme)</l>
<c>* </c>
<c>* Convert input image to byte image for visualization.</c>
<l>image_to_channels (Image, Channels)</l>
<l>count_channels (Image, NumChannels)</l>
<l>gen_empty_obj (ChannelsScaled)</l>
<l>for ChannelIndex := 1 to NumChannels by 1</l>
<l>    select_obj (Channels, Channel, ChannelIndex)</l>
<l>    min_max_gray (Channel, Channel, 0, ChannelMin, ChannelMax, _)</l>
<l>    scale_image_range (Channel, ChannelScaled, ChannelMin, ChannelMax)</l>
<l>    convert_image_type (ChannelScaled, ChannelScaledByte, 'byte')</l>
<l>    concat_obj (ChannelsScaled, ChannelScaledByte, ChannelsScaled)</l>
<l>endfor</l>
<l>channels_to_image (ChannelsScaled, ImageByte)</l>
<c>* </c>
<c>* Note that ImageByte needs to have the same number of channels as</c>
<c>* RGBValueImage to display color map image correctly.</c>
<l>count_channels (ImageByte, NumChannels)</l>
<l>if (NumChannels != 3)</l>
<c>    * Just take the first channel and use this to generate</c>
<c>    * an image with 3 channels for visualization.</c>
<l>    access_channel (ImageByte, ImageByteR, 1)</l>
<l>    copy_image (ImageByteR, ImageByteG)</l>
<l>    copy_image (ImageByteR, ImageByteB)</l>
<l>    compose3 (ImageByteR, ImageByteG, ImageByteB, ImageByte)</l>
<l>endif</l>
<c>* </c>
<l>add_image (ImageByte, RGBValueImage, RGBValueImage, 0.5, 0)</l>
<l>ColoredImage := RGBValueImage</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="add_colormap_to_image">
<chapters lang="de_DE">
<item>Bild</item>
<item>Kanal</item>
</chapters>
<chapters lang="en_US">
<item>Image</item>
<item>Channel</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="ColoredImage"/>
<parameter id="GrayValueImage"/>
<parameter id="HeatmapColorScheme"/>
<parameter id="Image"/>
</parameters>
</docu>
</procedure>
<procedure name="get_anomaly_ground_truth_label" access="local">
<interface>
<ic>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="AnomalyLabelGroundTruth" base_type="ctrl" dimension="0"/>
<par name="AnomalyLabelIDGroundTruth" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the anomaly ground truth label.</c>
<c>* </c>
<l>if (find(SampleKeys,'anomaly_label') != -1)</l>
<l>    get_dict_tuple (DLSample, 'anomaly_label', AnomalyLabelGroundTruth)</l>
<l>else</l>
<l>    throw ('Ground truth class label cannot be found in DLSample.')</l>
<l>endif</l>
<l>if (find(SampleKeys,'anomaly_label_id') != -1)</l>
<l>    get_dict_tuple (DLSample, 'anomaly_label_id', AnomalyLabelIDGroundTruth)</l>
<l>else</l>
<l>    throw ('Ground truth class label id cannot be found in DLSample.')</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="get_anomaly_ground_truth_label">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Anomalieerkennung und Global Context Anomaly Detection</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection and Global Context Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the ground truth anomaly label and label ID.</short>
<parameters>
<parameter id="AnomalyLabelGroundTruth"/>
<parameter id="AnomalyLabelIDGroundTruth"/>
<parameter id="DLSample"/>
<parameter id="SampleKeys"/>
</parameters>
</docu>
</procedure>
<procedure name="get_anomaly_result" access="local">
<interface>
<oo>
<par name="AnomalyImage" base_type="iconic" dimension="0"/>
<par name="AnomalyRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DLResult" base_type="ctrl" dimension="0"/>
<par name="AnomalyClassThreshold" base_type="ctrl" dimension="0"/>
<par name="AnomalyRegionThreshold" base_type="ctrl" dimension="0"/>
<par name="AnomalyResultPostfix" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="AnomalyScore" base_type="ctrl" dimension="0"/>
<par name="AnomalyClassID" base_type="ctrl" dimension="0"/>
<par name="AnomalyClassThresholdDisplay" base_type="ctrl" dimension="0"/>
<par name="AnomalyRegionThresholdDisplay" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the inference results in DLResult which are</c>
<c>* the anomaly image and the anomaly score. It also returns the</c>
<c>* classification of the anomaly score and segmentation of anomalous</c>
<c>* pixels in the anomaly image by applying the specified thresholds if</c>
<c>* given. Otherwise the results from DLResult are used.</c>
<c>* </c>
<c>* </c>
<l>AnomalyImageKey := 'anomaly_image' + AnomalyResultPostfix</l>
<l>AnomalyScoreKey := 'anomaly_score' + AnomalyResultPostfix</l>
<l>AnomalyRegionKey := 'anomaly_region' + AnomalyResultPostfix</l>
<l>AnomalyClassIdKey := 'anomaly_class_id' + AnomalyResultPostfix</l>
<c>* </c>
<l>tuple_regexp_replace (AnomalyResultPostfix, '_', ' ', ErrorMsgPostfix)</l>
<c>* </c>
<l>get_dict_param (DLResult, 'keys', [], ResultKeys)</l>
<l>if (ResultKeys == [])</l>
<l>    throw ('Result anomaly image' + ErrorMsgPostfix + ' could not be found in DLResult.')</l>
<l>endif</l>
<c>* </c>
<l>if (find_first(ResultKeys,AnomalyImageKey) != -1)</l>
<l>    get_dict_object (AnomalyImage, DLResult, AnomalyImageKey)</l>
<l>else</l>
<l>    throw ('Result anomaly image' + ErrorMsgPostfix + ' could not be found in DLResult.')</l>
<l>endif</l>
<c>* </c>
<l>if (find_first(ResultKeys,AnomalyScoreKey) != -1)</l>
<l>    get_dict_tuple (DLResult, AnomalyScoreKey, AnomalyScore)</l>
<l>else</l>
<l>    throw ('Result anomaly score' + ErrorMsgPostfix + ' could not be found in DLResult.')</l>
<l>endif</l>
<c>* </c>
<l>AnomalyRegionThresholdDisplay := -1</l>
<l>if (AnomalyRegionThreshold != -1)</l>
<c>    * Apply threshold for segmentation result.</c>
<l>    if (|AnomalyRegionThreshold| != 1)</l>
<l>        throw ('Selected \'anomaly_region_threshold\' must be specified by exactly one value.')</l>
<l>    endif</l>
<l>    threshold (AnomalyImage, AnomalyRegion, AnomalyRegionThreshold, 1)</l>
<l>    AnomalyRegionThresholdDisplay := AnomalyRegionThreshold</l>
<l>else</l>
<c>    * If no threshold is given, use the threshold and resulting anomaly region out of DLResult.</c>
<l>    if (find_first(ResultKeys,AnomalyRegionKey) != -1)</l>
<l>        get_dict_object (AnomalyRegion, DLResult, AnomalyRegionKey)</l>
<l>    else</l>
<l>        gen_empty_obj (AnomalyRegion)</l>
<l>    endif</l>
<l>    if (find(ResultKeys,'anomaly_segmentation_threshold') != -1)</l>
<l>        get_dict_tuple (DLResult, 'anomaly_segmentation_threshold', AnomalyRegionThresholdDisplay)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>AnomalyClassThresholdDisplay := -1</l>
<l>AnomalyClassID := -1</l>
<l>if (AnomalyClassThreshold != -1)</l>
<c>    * Apply threshold for classification result.</c>
<l>    if (|AnomalyClassThreshold| != 1)</l>
<l>        throw ('Selected \'anomaly_classification_threshold\' must be specified by exactly one value.')</l>
<l>    endif</l>
<l>    if (AnomalyScore &lt; AnomalyClassThreshold)</l>
<l>        AnomalyClassID := 0</l>
<l>    else</l>
<l>        AnomalyClassID := 1</l>
<l>    endif</l>
<l>    AnomalyClassThresholdDisplay := AnomalyClassThreshold</l>
<l>else</l>
<c>    * If no threshold is given, use the threshold and resulting class id out of DLResult.</c>
<l>    if (find_first(ResultKeys,AnomalyClassIdKey) != -1)</l>
<l>        get_dict_tuple (DLResult, AnomalyClassIdKey, AnomalyClassID)</l>
<l>    else</l>
<l>        AnomalyClassID := -1</l>
<l>    endif</l>
<l>    if (find(ResultKeys,'anomaly_classification_threshold') != -1)</l>
<l>        get_dict_tuple (DLResult, 'anomaly_classification_threshold', AnomalyClassThresholdDisplay)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="get_anomaly_result">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Anomalieerkennung und Global Context Anomaly Detection</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection and Global Context Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the anomaly results out of DLResult and apply thresholds (if specified).</short>
<parameters>
<parameter id="AnomalyClassID">
<sem_type>integer</sem_type>
</parameter>
<parameter id="AnomalyClassThreshold">
<default_type>real</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="AnomalyClassThresholdDisplay"/>
<parameter id="AnomalyImage">
<multivalue>false</multivalue>
<sem_type>object</sem_type>
</parameter>
<parameter id="AnomalyRegion">
<multivalue>false</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="AnomalyRegionThreshold">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="AnomalyRegionThresholdDisplay"/>
<parameter id="AnomalyResultPostfix">
<default_type>string</default_type>
<default_value>''</default_value>
<description lang="en_US">Postfix for requested GC-AD network type.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>''</item>
<item>'_global'</item>
<item>'_local'</item>
</values>
</parameter>
<parameter id="AnomalyScore">
<sem_type>integer</sem_type>
</parameter>
<parameter id="DLResult">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_ground_truth_anomaly_regions" access="local">
<interface>
<ic>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="CurrentWindowHandle" base_type="ctrl" dimension="0"/>
<par name="LineWidth" base_type="ctrl" dimension="0"/>
<par name="AnomalyRegionLabelColor" base_type="ctrl" dimension="0"/>
<par name="AnomalyColorTransparency" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="AnomalyRegionExists" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure visualizes the ground truth anomalies</c>
<c>* if there is an anomaly_ground_truth in DLSample.</c>
<c>* </c>
<c>* Get current set color.</c>
<l>get_rgba (CurrentWindowHandle, Red, Green, Blue, Alpha)</l>
<l>InitialColor := []</l>
<l>for IndexColor := 0 to |Red| - 1 by 1</l>
<l>    Color_RGBA := '#' + Red[IndexColor]$'2x' + Green[IndexColor]$'2x' + Blue[IndexColor]$'2x' + Alpha[IndexColor]$'2x'</l>
<l>    tuple_regexp_replace (Color_RGBA, [' ', 'replace_all'], '0', Color_RGBA)</l>
<l>    InitialColor := [InitialColor,Color_RGBA]</l>
<l>endfor</l>
<c>* </c>
<l>if (find(SampleKeys,'anomaly_ground_truth') != -1)</l>
<l>    get_dict_object (AnomalyImage, DLSample, 'anomaly_ground_truth')</l>
<l>    threshold (AnomalyImage, AnomalyRegion, 1, 255)</l>
<c>    * Get non-empty regions.</c>
<l>    region_features (AnomalyRegion, 'area', Area)</l>
<l>    if (Area &gt; 0)</l>
<l>        dev_set_color (AnomalyRegionLabelColor + AnomalyColorTransparency)</l>
<c>        * Display the anomaly region.</c>
<l>        dev_set_draw ('fill')</l>
<l>        dev_display (AnomalyRegion)</l>
<l>    endif</l>
<l>    AnomalyRegionExists := 'true'</l>
<l>else</l>
<l>    AnomalyRegionExists := 'false'</l>
<l>endif</l>
<c>* </c>
<c>* Reset colors.</c>
<l>dev_set_color (InitialColor)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_ground_truth_anomaly_regions">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Anomalieerkennung und Global Context Anomaly Detection</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection and Global Context Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display the ground truth anomaly regions of the given DLSample.</short>
<parameters>
<parameter id="AnomalyColorTransparency"/>
<parameter id="AnomalyRegionExists">
<sem_type>string</sem_type>
</parameter>
<parameter id="AnomalyRegionLabelColor"/>
<parameter id="CurrentWindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="LineWidth">
<sem_type>number</sem_type>
</parameter>
<parameter id="SampleKeys">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_result_anomaly_regions" access="local">
<interface>
<io>
<par name="AnomalyRegion" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CurrentWindowHandle" base_type="ctrl" dimension="0"/>
<par name="LineWidth" base_type="ctrl" dimension="0"/>
<par name="AnomalyRegionResultColor" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure displays the result anomaly regions.</c>
<c>* </c>
<c>* Get current set color.</c>
<l>get_rgba (CurrentWindowHandle, Red, Green, Blue, Alpha)</l>
<l>InitialColor := []</l>
<l>for IndexColor := 0 to |Red| - 1 by 1</l>
<l>    Color_RGBA := '#' + Red[IndexColor]$'2x' + Green[IndexColor]$'2x' + Blue[IndexColor]$'2x' + Alpha[IndexColor]$'2x'</l>
<l>    tuple_regexp_replace (Color_RGBA, [' ', 'replace_all'], '0', Color_RGBA)</l>
<l>    InitialColor := [InitialColor,Color_RGBA]</l>
<l>endfor</l>
<c>* </c>
<c>* Display anomaly regions.</c>
<c>* Get non-empty regions.</c>
<l>region_features (AnomalyRegion, 'area', Area)</l>
<c>* </c>
<c>* Display all non-empty class regions in distinct colors.</c>
<l>if (Area &gt; 0)</l>
<l>    dev_set_color (AnomalyRegionResultColor)</l>
<l>    dev_set_line_width (LineWidth)</l>
<l>    dev_set_draw ('margin')</l>
<l>    dev_display (AnomalyRegion)</l>
<l>endif</l>
<c>* </c>
<c>* Reset colors.</c>
<l>dev_set_color (InitialColor)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_result_anomaly_regions">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Anomalieerkennung und Global Context Anomaly Detection</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Anomaly Detection and Global Context Anomaly Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display the detected anomaly regions.</short>
<parameters>
<parameter id="AnomalyRegion"/>
<parameter id="AnomalyRegionResultColor">
<sem_type>string</sem_type>
</parameter>
<parameter id="CurrentWindowHandle"/>
<parameter id="LineWidth"/>
</parameters>
</docu>
</procedure>
<procedure name="get_child_window" access="local">
<interface>
<ic>
<par name="HeightImage" base_type="ctrl" dimension="0"/>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="FontSize" base_type="ctrl" dimension="0"/>
<par name="Text" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinates" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
<par name="WindowHandleKey" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowImageRatio" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinatesOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the next child window that</c>
<c>* is used for visualization. If ReuseWindows is true</c>
<c>* and WindowHandleList is suitable, the window handles</c>
<c>* that are passed over are used. Else, this procedure</c>
<c>* opens a new window, either next to the last ones, or</c>
<c>* in a new row.</c>
<c>* </c>
<c>* First, check if the requested window is already available.</c>
<l>OpenNewWindow := false</l>
<l>try</l>
<l>    get_dict_tuple (WindowHandleDict, WindowHandleKey, WindowHandles)</l>
<l>    ParentWindowHandle := WindowHandles[0]</l>
<l>    ChildWindowHandle := WindowHandles[1]</l>
<c>    * Check if window handle is valid.</c>
<l>    try</l>
<l>        flush_buffer (ChildWindowHandle)</l>
<l>    catch (Exception)</l>
<c>        * Since there is something wrong with the current window, create a new one.</c>
<l>        OpenNewWindow := true</l>
<l>    endtry</l>
<l>catch (Exception)</l>
<l>    OpenNewWindow := true</l>
<l>endtry</l>
<c>* </c>
<c>* Get next child window.</c>
<l>if (not OpenNewWindow)</l>
<c>    * </c>
<c>    * If possible, reuse existing window handles.</c>
<l>    dev_set_window (ChildWindowHandle)</l>
<l>    dev_clear_window ()</l>
<l>    set_display_font (ChildWindowHandle, FontSize, Font, 'true', 'false')</l>
<c>    * </c>
<l>    get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<c>    * </c>
<c>    * Get previous window coordinates.</c>
<l>    get_window_extents (ParentWindowHandle, WindowRow, WindowColumn, WindowWidth, WindowHeight)</l>
<l>    WindowImageRatio := WindowHeight / (HeightImage * 1.0)</l>
<c>    * </c>
<l>    try</l>
<c>        * </c>
<c>        * Get WindowImageRatio from parent window.</c>
<l>        get_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_height', WindowImageRatio)</l>
<c>        * </c>
<c>        * Get previous window coordinates.</c>
<l>        get_dict_tuple (MetaInfo, WindowHandleKey + '_child_window_coordinates', PrevWindowCoordinatesOut)</l>
<l>    catch (Exception)</l>
<c>        * </c>
<c>        * Set WindowImageRatio from parent window.</c>
<l>        get_window_extents (ParentWindowHandle, WindowRow, WindowColumn, WindowWidth, WindowHeight)</l>
<l>        WindowImageRatio := WindowHeight / (HeightImage * 1.0)</l>
<c>        * </c>
<c>        * Set previous window coordinates.</c>
<l>        PrevWindowCoordinatesOut[0] := WindowRow</l>
<l>        PrevWindowCoordinatesOut[1] := WindowColumn</l>
<l>        PrevWindowCoordinatesOut[2] := WindowWidth</l>
<l>        PrevWindowCoordinatesOut[3] := WindowHeight</l>
<l>    endtry</l>
<l>else</l>
<c>    * </c>
<c>    * Open a new child window.</c>
<l>    open_child_window (ParentWindowHandle, Font, FontSize, Text, PrevWindowCoordinates, WindowHandleDict, WindowHandleKey, ChildWindowHandle, PrevWindowCoordinatesOut)</l>
<l>    set_window_param (ChildWindowHandle, 'flush', 'false')</l>
<l>    set_dict_tuple (WindowHandleDict, WindowHandleKey, [ParentWindowHandle,ChildWindowHandle])</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="get_child_window">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the next child window that can be used for visualization.</short>
<parameters>
<parameter id="Font">
<default_type>string</default_type>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="FontSize">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="HeightImage">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinates">
<default_type>integer</default_type>
<default_value>0</default_value>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinatesOut">
<default_type>integer</default_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Text">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleKey">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowImageRatio">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_ground_truth_detection" access="local">
<interface>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="LineWidthBbox" base_type="ctrl" dimension="0"/>
<par name="ClassIDs" base_type="ctrl" dimension="0"/>
<par name="BboxColors" base_type="ctrl" dimension="0"/>
<par name="BboxLabelColor" base_type="ctrl" dimension="0"/>
<par name="WindowImageRatio" base_type="ctrl" dimension="0"/>
<par name="TextColor" base_type="ctrl" dimension="0"/>
<par name="ShowLabels" base_type="ctrl" dimension="0"/>
<par name="ShowDirection" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="BboxIDs" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure displays the ground truth bounding boxes and masks (if present) of a DLSample.</c>
<c>* </c>
<l>InstanceType := ''</l>
<l>MaskExists := false</l>
<l>if (find(SampleKeys,'bbox_row1') != -1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_row1', BboxRow1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_col1', BboxCol1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_row2', BboxRow2)</l>
<l>    get_dict_tuple (DLSample, 'bbox_col2', BboxCol2)</l>
<l>    InstanceType := 'rectangle1'</l>
<l>elseif (find(SampleKeys,'bbox_phi') != -1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_row', BboxRow)</l>
<l>    get_dict_tuple (DLSample, 'bbox_col', BboxCol)</l>
<l>    get_dict_tuple (DLSample, 'bbox_length1', BboxLength1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_length2', BboxLength2)</l>
<l>    get_dict_tuple (DLSample, 'bbox_phi', BboxPhi)</l>
<l>    InstanceType := 'rectangle2'</l>
<l>else</l>
<l>    throw ('Ground truth bounding box data could not be found in DLSample.')</l>
<l>endif</l>
<l>if (find(SampleKeys,'mask') != -1)</l>
<l>    get_dict_object (InstanceMask, DLSample, 'mask')</l>
<l>    MaskExists := true</l>
<l>endif</l>
<l>if (InstanceType != 'rectangle1' and InstanceType != 'rectangle2' and not MaskExists)</l>
<l>    throw ('Ground truth bounding box or mask data could not be found in DLSample.')</l>
<l>endif</l>
<l>get_dict_tuple (DLSample, 'bbox_label_id', BboxLabels)</l>
<l>if (|BboxLabels| &gt; 0)</l>
<c>    * </c>
<c>    * Get text and text size for correct positioning of label IDs.</c>
<l>    if (ShowLabels)</l>
<l>        Text := BboxLabels</l>
<l>        get_string_extents (WindowHandle, Text, Ascent, Descent, _, _)</l>
<l>        TextOffset := (Ascent + Descent) / WindowImageRatio</l>
<l>    endif</l>
<c>    * </c>
<c>    * Generate bounding box XLDs.</c>
<l>    if (InstanceType == 'rectangle1')</l>
<l>        tuple_gen_const (|BboxRow1|, 0.0, BboxPhi)</l>
<l>        gen_rectangle2_contour_xld (BboxRectangle, 0.5 * (BboxRow1 + BboxRow2), 0.5 * (BboxCol1 + BboxCol2), BboxPhi, 0.5 * (BboxCol2 - BboxCol1), 0.5 * (BboxRow2 - BboxRow1))</l>
<l>        if (ShowLabels)</l>
<l>            LabelRow := BboxRow1</l>
<l>            LabelCol := BboxCol1</l>
<l>        endif</l>
<l>    elseif (InstanceType == 'rectangle2')</l>
<l>        gen_rectangle2_contour_xld (BboxRectangle, BboxRow, BboxCol, BboxPhi, BboxLength1, BboxLength2)</l>
<l>        if (ShowLabels)</l>
<l>            LabelRow := BboxRow - TextOffset</l>
<l>            LabelCol := BboxCol</l>
<l>        endif</l>
<l>        if (ShowDirection)</l>
<l>            HeadSize := 20.0</l>
<l>            gen_arrow_contour_xld (OrientationArrows, BboxRow, BboxCol, BboxRow - (BboxLength1 + HeadSize) * sin(BboxPhi), BboxCol + (BboxLength1 + HeadSize) * cos(BboxPhi), HeadSize, HeadSize)</l>
<l>        endif</l>
<l>    elseif (MaskExists)</l>
<l>        if (ShowLabels)</l>
<l>            area_center (InstanceMask, _, LabelRow, LabelCol)</l>
<l>        endif</l>
<l>    else</l>
<l>        throw ('Unknown instance_type: ' + InstanceType)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Collect the ClassIDs of the bounding boxes.</c>
<l>    tuple_gen_const (|BboxLabels|, 0, BboxIDs)</l>
<c>    * </c>
<c>    * Draw the bounding boxes.</c>
<l>    get_contour_style (WindowHandle, ContourStyle)</l>
<l>    dev_set_contour_style ('stroke_and_fill')</l>
<l>    get_line_style (WindowHandle, Style)</l>
<l>    dev_set_line_width (LineWidthBbox)</l>
<l>    for IndexBbox := 0 to |BboxLabels| - 1 by 1</l>
<l>        select_obj (BboxRectangle, RectangleSelected, IndexBbox + 1)</l>
<l>        ClassID := find(ClassIDs,BboxLabels[IndexBbox])</l>
<l>        BboxIDs[IndexBbox] := ClassID</l>
<l>        dev_set_color (BboxColors[ClassID] + '60')</l>
<l>        if (MaskExists)</l>
<l>            dev_set_draw ('fill')</l>
<l>            select_obj (InstanceMask, MaskSelected, IndexBbox + 1)</l>
<l>            dev_display (MaskSelected)</l>
<l>            dev_set_contour_style ('stroke')</l>
<l>        endif</l>
<l>        if (InstanceType != '')</l>
<l>            select_obj (BboxRectangle, RectangleSelected, IndexBbox + 1)</l>
<l>            dev_display (RectangleSelected)</l>
<l>            if (InstanceType == 'rectangle2' and ShowDirection)</l>
<l>                select_obj (OrientationArrows, ArrowSelected, IndexBbox + 1)</l>
<l>                dev_set_color (BboxColors[ClassID] + 'FF')</l>
<l>                dev_display (ArrowSelected)</l>
<l>                dev_set_color (BboxColors[ClassID] + '60')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Write text to the bounding boxes.</c>
<l>    if (ShowLabels)</l>
<c>        * For better visibility the text is displayed after all bounding boxes are drawn.</c>
<c>        * Select text color.</c>
<l>        if (TextColor == '')</l>
<l>            TextColorClasses := BboxColors[BboxIDs]</l>
<l>        else</l>
<l>            tuple_gen_const (|BboxIDs|, TextColor, TextColorClasses)</l>
<l>        endif</l>
<c>        * Display text.</c>
<l>        dev_disp_text (BboxLabels, 'image', LabelRow, LabelCol, TextColorClasses, ['box_color', 'shadow', 'border_radius'], [BboxLabelColor,'false', 0])</l>
<l>    endif</l>
<c>    * </c>
<l>    dev_set_contour_style (ContourStyle)</l>
<l>    set_line_style (WindowHandle, Style)</l>
<l>else</l>
<c>    * Do nothing if there are no ground truth bounding boxes.</c>
<l>    BboxIDs := []</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_ground_truth_detection">
<abstract lang="en_US">This procedure displays the ground truth bounding boxes of DLSample.

If an instance mask is present in the DLSample (under the key 'mask'), it is shown additionally.

SampleKeys is a tuple which should contain all the keys of DLSample.
LineWidthBbox sets the width of the lines with which the bounding boxes are drawn.
ClassIDs is a tuple with all the IDs of the different classes the network can distinguish.
BboxColors determines the colors of the bounding boxes for every class, which are given over hexadecimal numbers within an RGB triplet.
BboxLabelColor is a string determining the color used to display the bounding box labels.
WindowImageRatio is a real, determining the image ratio of the window used for the display.
TextColor is a string determining the color used to display the text within the label.
ShowLabels is a boolean, determining if the labels are shown or not.
ShowDirection is a boolean, determining if direction of the instance within the bounding box should be indicated by an arrow or not. Supported only for instance_type 'rectangle2'.
WindowHandle determines handle of the window.
The procedure returns the IDs of the classes assigned for the bounding box contents in BboxIDs.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display the ground truth bounding boxes of DLSample.</short>
<parameters>
<parameter id="BboxColors">
<default_type>string</default_type>
<description lang="en_US">Determines the colors of the bounding boxes for every class, which are given over hexadecimal numbers within an RGB triplet.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="BboxIDs">
<default_type>integer</default_type>
<description lang="en_US">IDs of the classes assigned for the bounding box contents in BboxIDs.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="BboxLabelColor">
<default_type>string</default_type>
<description lang="en_US">Determines the color used to display the bounding box labels.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ClassIDs">
<default_type>integer</default_type>
<description lang="en_US">Tuple with all the IDs of the different classes the network can distinguish.</description>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<description lang="en_US">Dictionary of the sample whose bounding boxes are to be visualized.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="LineWidthBbox">
<default_type>integer</default_type>
<description lang="en_US">Sets the width of the lines with which the bounding boxes are drawn.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SampleKeys">
<description lang="en_US">A tuple which should contain all the keys of DLSample.</description>
<sem_type>string</sem_type>
</parameter>
<parameter id="ShowDirection">
<description lang="en_US">Determines if the direction of an instance within the bounding box is visualized or not. Supported only for instance_type 'rectangle2'.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
</parameter>
<parameter id="ShowLabels">
<description lang="en_US">Determines if the labels are shown or not.</description>
<sem_type>integer</sem_type>
</parameter>
<parameter id="TextColor">
<default_type>string</default_type>
<default_value>'white'</default_value>
<description lang="en_US">Determines the color used the for text within the label.</description>
<sem_type>color</sem_type>
<type_list>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the window used for the display.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowImageRatio">
<default_type>real</default_type>
<description lang="en_US">WindowImageRatio is a real, determining the image ratio of the window used for the display.</description>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_result_detection" access="local">
<interface>
<ic>
<par name="DLResult" base_type="ctrl" dimension="0"/>
<par name="ResultKeys" base_type="ctrl" dimension="0"/>
<par name="LineWidthBbox" base_type="ctrl" dimension="0"/>
<par name="ClassIDs" base_type="ctrl" dimension="0"/>
<par name="TextConf" base_type="ctrl" dimension="0"/>
<par name="Colors" base_type="ctrl" dimension="0"/>
<par name="BoxLabelColor" base_type="ctrl" dimension="0"/>
<par name="WindowImageRatio" base_type="ctrl" dimension="0"/>
<par name="TextPositionRow" base_type="ctrl" dimension="0"/>
<par name="TextColor" base_type="ctrl" dimension="0"/>
<par name="ShowLabels" base_type="ctrl" dimension="0"/>
<par name="ShowDirection" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="BboxClassIndices" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure displays the bounding boxes and masks (if present) defined by a DLResult.</c>
<c>* The ClassIDs are necessary to display bounding boxes from the same class</c>
<c>* always with the same color.</c>
<c>* </c>
<l>InstanceType := ''</l>
<l>MaskExists := false</l>
<l>if (find(ResultKeys,'bbox_row1') != -1)</l>
<l>    get_dict_tuple (DLResult, 'bbox_row1', BboxRow1)</l>
<l>    get_dict_tuple (DLResult, 'bbox_col1', BboxCol1)</l>
<l>    get_dict_tuple (DLResult, 'bbox_row2', BboxRow2)</l>
<l>    get_dict_tuple (DLResult, 'bbox_col2', BboxCol2)</l>
<l>    InstanceType := 'rectangle1'</l>
<l>elseif (find(ResultKeys,'bbox_phi') != -1)</l>
<l>    get_dict_tuple (DLResult, 'bbox_row', BboxRow)</l>
<l>    get_dict_tuple (DLResult, 'bbox_col', BboxCol)</l>
<l>    get_dict_tuple (DLResult, 'bbox_length1', BboxLength1)</l>
<l>    get_dict_tuple (DLResult, 'bbox_length2', BboxLength2)</l>
<l>    get_dict_tuple (DLResult, 'bbox_phi', BboxPhi)</l>
<l>    get_dict_tuple (DLResult, 'bbox_class_id', BboxClasses)</l>
<l>    InstanceType := 'rectangle2'</l>
<l>else</l>
<l>    throw ('Result bounding box data could not be found in DLResult.')</l>
<l>endif</l>
<l>if (find(ResultKeys,'mask') != -1)</l>
<l>    get_dict_object (InstanceMask, DLResult, 'mask')</l>
<l>    MaskExists := true</l>
<l>endif</l>
<l>if (InstanceType != 'rectangle1' and InstanceType != 'rectangle2' and not MaskExists)</l>
<l>    throw ('Result bounding box or mask data could not be found in DLSample.')</l>
<l>endif</l>
<l>get_dict_tuple (DLResult, 'bbox_class_id', BboxClasses)</l>
<l>if (|BboxClasses| &gt; 0)</l>
<c>    * </c>
<c>    * Get text and text size for correct positioning of result class IDs.</c>
<l>    if (ShowLabels)</l>
<l>        Text := BboxClasses + TextConf</l>
<l>        get_string_extents (WindowHandle, Text, Ascent, Descent, _, _)</l>
<l>        TextOffset := (Ascent + Descent) / WindowImageRatio</l>
<l>    endif</l>
<c>    * </c>
<c>    * Generate bounding box XLDs.</c>
<l>    if (InstanceType == 'rectangle1')</l>
<l>        tuple_gen_const (|BboxRow1|, 0.0, BboxPhi)</l>
<l>        gen_rectangle2_contour_xld (BboxRectangle, 0.5 * (BboxRow1 + BboxRow2), 0.5 * (BboxCol1 + BboxCol2), BboxPhi, 0.5 * (BboxCol2 - BboxCol1), 0.5 * (BboxRow2 - BboxRow1))</l>
<l>        if (ShowLabels)</l>
<l>            LabelRowTop := BboxRow1</l>
<l>            LabelRowBottom := BboxRow2 - TextOffset</l>
<l>            LabelCol := BboxCol1</l>
<l>        endif</l>
<l>    elseif (InstanceType == 'rectangle2')</l>
<l>        gen_rectangle2_contour_xld (BboxRectangle, BboxRow, BboxCol, BboxPhi, BboxLength1, BboxLength2)</l>
<l>        if (ShowLabels)</l>
<l>            LabelRowTop := BboxRow - TextOffset</l>
<l>            LabelRowBottom := BboxRow</l>
<l>            LabelCol := BboxCol</l>
<l>        endif</l>
<l>        if (ShowDirection)</l>
<l>            HeadSize := 20.0</l>
<l>            gen_arrow_contour_xld (OrientationArrows, BboxRow, BboxCol, BboxRow - (BboxLength1 + HeadSize) * sin(BboxPhi), BboxCol + (BboxLength1 + HeadSize) * cos(BboxPhi), HeadSize, HeadSize)</l>
<l>        endif</l>
<l>    elseif (MaskExists)</l>
<l>        area_center (InstanceMask, _, MaskRow, MaskCol)</l>
<l>        LabelRowTop := MaskRow - TextOffset</l>
<l>        LabelRowBottom := MaskRow</l>
<l>        LabelCol := MaskCol</l>
<l>    else</l>
<l>        throw ('Unknown instance_type: ' + InstanceType)</l>
<l>    endif</l>
<c>    * </c>
<l>    get_contour_style (WindowHandle, ContourStyle)</l>
<l>    dev_set_contour_style ('stroke')</l>
<l>    get_line_style (WindowHandle, Style)</l>
<l>    LineWidths := [LineWidthBbox + 2,LineWidthBbox]</l>
<l>    dev_set_line_width (LineWidthBbox)</l>
<c>    * </c>
<c>    * Collect ClassIDs of the bounding boxes.</c>
<l>    tuple_gen_const (|BboxClasses|, 0, BboxClassIndices)</l>
<c>    * </c>
<c>    * Draw bounding boxes.</c>
<l>    for IndexBbox := 0 to |BboxClasses| - 1 by 1</l>
<l>        ClassID := find(ClassIDs,BboxClasses[IndexBbox])</l>
<l>        BboxClassIndices[IndexBbox] := ClassID</l>
<c>        * First draw in black to make the class-color visible.</c>
<l>        CurrentColors := ['black',Colors[ClassID]]</l>
<l>        if (MaskExists)</l>
<l>            select_obj (InstanceMask, MaskSelected, IndexBbox + 1)</l>
<l>            dev_set_draw ('fill')</l>
<l>            dev_set_color (Colors[ClassID] + '80')</l>
<l>            dev_display (MaskSelected)</l>
<l>            dev_set_draw ('margin')</l>
<l>        endif</l>
<l>        for IndexStyle := 0 to |CurrentColors| - 1 by 1</l>
<l>            dev_set_color (CurrentColors[IndexStyle])</l>
<l>            dev_set_line_width (LineWidths[IndexStyle])</l>
<l>            if (InstanceType != '')</l>
<l>                select_obj (BboxRectangle, RectangleSelected, IndexBbox + 1)</l>
<l>                dev_display (RectangleSelected)</l>
<l>                if (InstanceType == 'rectangle2' and ShowDirection)</l>
<l>                    select_obj (OrientationArrows, ArrowSelected, IndexBbox + 1)</l>
<l>                    dev_display (ArrowSelected)</l>
<l>                endif</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Draw text of bounding boxes.</c>
<l>    if (ShowLabels)</l>
<c>        * For better visibility the text is displayed after all bounding boxes are drawn.</c>
<c>        * Get text and text size for correct positioning of result class IDs.</c>
<l>        Text := BboxClasses + TextConf</l>
<c>        * Select text color.</c>
<l>        if (TextColor == '')</l>
<l>            TextColorClasses := Colors[BboxClassIndices]</l>
<l>        else</l>
<l>            tuple_gen_const (|BboxClassIndices|, TextColor, TextColorClasses)</l>
<l>        endif</l>
<c>        * Select correct position of the text.</c>
<l>        LabelRow := LabelRowTop</l>
<l>        if (TextPositionRow == 'bottom')</l>
<l>            LabelRow := LabelRowBottom</l>
<l>        endif</l>
<c>        * Display text.</c>
<l>        dev_disp_text (Text, 'image', LabelRow, LabelCol, TextColorClasses, ['box_color', 'shadow', 'border_radius'], [BoxLabelColor,'false', 0])</l>
<l>    endif</l>
<c>    * </c>
<l>    dev_set_contour_style (ContourStyle)</l>
<l>    set_line_style (WindowHandle, Style)</l>
<l>else</l>
<c>    * Do nothing if no results are present.</c>
<l>    BboxClassIndices := []</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dev_display_result_detection">
<abstract lang="en_US">This procedure displays the inferred bounding boxes in DLResult.

ResultKeys is a tuple which should contain all the keys of DLResult.
LineWidthBbox sets the width of the lines with which the bounding boxes are drawn.
ClassIDs is a tuple with all the IDs of the different classes the network can distinguish.
TextConf is a tuple of strings with the confidences.
Colors determines the colors of the bounding boxes for every class, which are given over hexadecimal numbers within an RGB triplet.
BoxLabelColor is a string, determining the color used to display the bounding box labels.
WindowImageRatio is a real, determining the image ratio of the window used for the display.
TextPositionRow determines, where next to the bounding box the class and confidences are displayed. Supported values: 'top' (default), 'bottom'.
TextColor is a string determining the color used to display the text within the label.
ShowLabels is a boolean, determining if the labels are shown or not.
ShowDirection is a boolean, determining if direction of the instance within the bounding box should be indicated by an arrow or not. Supported only for instance_type 'rectangle2'.

WindowHandle determines handle of the window.

The procedure returns the IDs of the classes assigned for the bounding box contents in BboxClassIndices.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display result bounding boxes.</short>
<parameters>
<parameter id="BboxClassIndices">
<default_type>integer</default_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="BoxLabelColor">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ClassIDs">
<default_type>integer</default_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Colors">
<default_type>string</default_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DLResult">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="LineWidthBbox">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ResultKeys">
<sem_type>string</sem_type>
</parameter>
<parameter id="ShowDirection">
<description lang="en_US">Determines if the direction of an instance within the bounding box is visualized or not. Supported only for instance_type 'rectangle2'.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
</parameter>
<parameter id="ShowLabels">
<sem_type>integer</sem_type>
</parameter>
<parameter id="TextColor">
<default_type>string</default_type>
<default_value>'white'</default_value>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="TextConf">
<default_type>string</default_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="TextPositionRow">
<default_type>integer</default_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowImageRatio">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_classification_ground_truth" access="local">
<interface>
<ic>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ClassificationLabelIDGroundTruth" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the classification ground truth label ID.</c>
<c>* </c>
<l>if (find(SampleKeys,'image_label_id') != -1)</l>
<l>    get_dict_tuple (DLSample, 'image_label_id', ClassificationLabelIDGroundTruth)</l>
<l>else</l>
<l>    throw ('Ground truth class label cannot be found in DLSample.')</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="get_classification_ground_truth">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the ground truth classification label id.</short>
<parameters>
<parameter id="ClassificationLabelIDGroundTruth">
<sem_type>integer</sem_type>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SampleKeys">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_classification_result" access="local">
<interface>
<ic>
<par name="ResultKeys" base_type="ctrl" dimension="0"/>
<par name="DLResult" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ClassificationClassID" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the predicted classification class ID.</c>
<c>* </c>
<l>if (find(ResultKeys,'classification_class_ids') != -1)</l>
<l>    get_dict_tuple (DLResult, 'classification_class_ids', ClassificationClassID)</l>
<l>    if (|ClassificationClassID| &gt; 0)</l>
<l>        ClassificationClassID := ClassificationClassID[0]</l>
<l>    endif</l>
<l>else</l>
<l>    throw ('Key entry \'classification_class_ids\' could not be found in DLResult.')</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="get_classification_result">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the predicted classification class ID.</short>
<parameters>
<parameter id="ClassificationClassID">
<sem_type>integer</sem_type>
</parameter>
<parameter id="DLResult">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ResultKeys">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_confidence_image" access="local">
<interface>
<oo>
<par name="ImageConfidence" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ResultKeys" base_type="ctrl" dimension="0"/>
<par name="DLResult" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure returns confidences of the segmentation result.</c>
<c>* </c>
<l>if (find(ResultKeys,'segmentation_confidence') != -1)</l>
<l>    get_dict_object (ImageConfidence, DLResult, 'segmentation_confidence')</l>
<l>elseif (find(ResultKeys,'segmentation_confidences') != -1)</l>
<l>    get_dict_object (ImageConfidence, DLResult, 'segmentation_confidences')</l>
<l>else</l>
<l>    throw ('Confidence image could not be found in DLSample.')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_confidence_image">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung und Kantenextraktion</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation and Edge Extraction</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the confidences of the segmentation result.</short>
<parameters>
<parameter id="DLResult">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageConfidence">
<sem_type>image</sem_type>
</parameter>
<parameter id="ResultKeys">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_confidence_regions" access="local">
<interface>
<io>
<par name="ImageConfidence" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="DrawTransparency" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Colors" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure displays a map of the confidences</c>
<c>* given in ImageConfidence as regions.</c>
<c>* DrawTransparency determines the alpha value of the colors.</c>
<c>* The used colors are returned.</c>
<c>* </c>
<c>* Define colors.</c>
<l>NumColors := 20</l>
<l>get_distinct_colors (NumColors, false, 0, 100, Colors)</l>
<l>WeightsColorsAlpha := Colors + DrawTransparency</l>
<l>ColorIndex := 0</l>
<c>* </c>
<c>* Threshold the image according to</c>
<c>* the number of colors and</c>
<c>* display resulting regions.</c>
<l>for ColorIndex := 0 to NumColors - 1 by 1</l>
<l>    Threshold := ColorIndex * (1.0 / NumColors)</l>
<l>    MinGray := Threshold</l>
<l>    MaxGray := Threshold + 1 / NumColors</l>
<l>    threshold (ImageConfidence, Region, Threshold, Threshold + (1.0 / NumColors))</l>
<l>    dev_set_color (WeightsColorsAlpha[ColorIndex])</l>
<l>    dev_display (Region)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="dev_display_confidence_regions">
<abstract lang="en_US">This procedure displays a map of the confidences given in ImageConfidence.
Thereby, the confidence values within certain intervals are mapped to regions.

As a result, the procedure returns the colors it used to display the regions.
</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display a map of the confidences.</short>
<parameters>
<parameter id="Colors">
<default_type>string</default_type>
<description lang="en_US">Defines the color values used as hexadecimal number within an RGBA quadruplet.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DrawTransparency">
<default_type>string</default_type>
<description lang="en_US">Defines the alpha value used as hexadecimal number within an RGBA quadruplet.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageConfidence">
<description lang="en_US">Image with the confidence values of the top predicted classes.</description>
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_map_color_bar" access="local">
<interface>
<ic>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="MapColorBarWidth" base_type="ctrl" dimension="0"/>
<par name="Colors" base_type="ctrl" dimension="0"/>
<par name="MaxValue" base_type="ctrl" dimension="0"/>
<par name="WindowImageRatio" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure displays a color bar next to the image</c>
<c>* specified with ImageWidth and ImageHeight.</c>
<c>* </c>
<l>get_system ('clip_region', ClipRegion)</l>
<l>set_system ('clip_region', 'false')</l>
<c>* </c>
<c>* Display the color bar.</c>
<l>ColorIndex := 0</l>
<l>RectHeight := 1.0 * ImageHeight / |Colors|</l>
<c>* Set draw mode to fill</c>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>dev_set_draw ('fill')</l>
<l>for Row := ImageHeight - 1 to 0 by -RectHeight</l>
<c>    * The color bar consists of multiple rectangle1.</c>
<l>    Row1 := Row - RectHeight</l>
<l>    Column1 := ImageWidth + 20 / WindowImageRatio</l>
<l>    Row2 := Row</l>
<l>    Column2 := ImageWidth + 20 + MapColorBarWidth / WindowImageRatio</l>
<l>    gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2)</l>
<l>    dev_set_color (Colors[ColorIndex])</l>
<l>    dev_display (Rectangle)</l>
<l>    ColorIndex := ColorIndex + 1</l>
<l>endfor</l>
<c>* </c>
<c>* Display labels for color bar.</c>
<l>get_string_extents (WindowHandle, '0123456789', _, _, _, TextHeight)</l>
<l>for Index := 0 to 1 by 0.2</l>
<l>    Text := (MaxValue - Index * MaxValue)$'.1f'</l>
<l>    dev_disp_text (Text, 'image', Index * (ImageHeight - 2 * (TextHeight / WindowImageRatio)), ImageWidth + 40 / WindowImageRatio, 'black', 'box', 'false')</l>
<l>endfor</l>
<c>* </c>
<l>set_system ('clip_region', ClipRegion)</l>
<l>dev_set_draw (DrawMode)</l>
<l>return ()</l>
</body>
<docu id="dev_display_map_color_bar">
<abstract lang="en_US">This procedure displays a color bar in the window given over its handle.
It allows to draw the color bar next to an image, whose dimensions are specified by ImageWidth and ImageHeight.
MapColorBarWidth specifies the width of the color bar elements.
Colors is a tuple determining the different colors used for the color bar and therewith also sets the number of differently colored rectangles.
MaxValue specifies the maximal value the color bar represents. Note, the values are displayed with one decimal place.
WindowImageRatio specifies the ratio of the window.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display a color bar next to an image.</short>
<parameters>
<parameter id="Colors">
<default_type>string</default_type>
<description lang="en_US">Determines the colors to be used for the color bar.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<description lang="en_US">Determines the height of the image, next to which the color bar is drawn.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>extent.x</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<description lang="en_US">Determines the width of the image, next to which the color bar is drawn.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MapColorBarWidth">
<description lang="en_US">Determines the width of the color bar.</description>
</parameter>
<parameter id="MaxValue">
<description lang="en_US">Specifies the maximal value the color bar represents.</description>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the image in which the color bar is drawn.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowImageRatio">
<default_type>string</default_type>
<description lang="en_US">Specifies the aspect ratio of the window size.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_segmentation_image_ground_truth" access="local">
<interface>
<oo>
<par name="SegmentationImagGroundTruth" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the ground truth segmentation image.</c>
<c>* </c>
<l>if (find(SampleKeys,'segmentation_image') != -1)</l>
<l>    get_dict_object (SegmentationImagGroundTruth, DLSample, 'segmentation_image')</l>
<l>else</l>
<l>    throw ('Ground truth segmentation image could not be found in DLSample.')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_segmentation_image_ground_truth">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung und Kantenextraktion</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation and Edge Extraction</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the ground truth segmentation image.</short>
<parameters>
<parameter id="DLSample">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SampleKeys">
<sem_type>string</sem_type>
</parameter>
<parameter id="SegmentationImagGroundTruth">
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_segmentation_image_result" access="local">
<interface>
<oo>
<par name="SegmentationImageResult" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ResultKeys" base_type="ctrl" dimension="0"/>
<par name="DLResult" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the predicted segmentation result image.</c>
<c>* </c>
<l>if (find(ResultKeys,'segmentation_image') != -1)</l>
<l>    get_dict_object (SegmentationImageResult, DLResult, 'segmentation_image')</l>
<l>else</l>
<l>    throw ('Result segmentation data could not be found in DLSample.')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_segmentation_image_result">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung und Kantenextraktion</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation and Edge Extraction</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the predicted segmentation result image.</short>
<parameters>
<parameter id="DLResult">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ResultKeys">
<sem_type>string</sem_type>
</parameter>
<parameter id="SegmentationImageResult">
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_segmentation_regions" access="local">
<interface>
<io>
<par name="SegmentationImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="ClassIDs" base_type="ctrl" dimension="0"/>
<par name="ColorsSegmentation" base_type="ctrl" dimension="0"/>
<par name="ExcludeClassIDs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageClassIDs" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure displays the ground truth/result segmentation</c>
<c>* given in SegmentationImage as regions. The ClassIDs are necessary to</c>
<c>* display ground truth/result segmentations from the same class</c>
<c>* always with the same color. It is possible to exclude certain ClassIDs</c>
<c>* from being displayed. The displayed classes are returned in ImageClassIDs.</c>
<c>* </c>
<c>* </c>
<c>* Remove excluded class IDs from the list.</c>
<l>IncludedClassIDs := difference(ClassIDs,ExcludeClassIDs)</l>
<c>* </c>
<c>* Get a region for each class ID.</c>
<l>threshold (SegmentationImage, Regions, IncludedClassIDs, IncludedClassIDs)</l>
<c>* </c>
<c>* Get classes with non-empty regions.</c>
<l>region_features (Regions, 'area', Area)</l>
<l>if (|Area| != |IncludedClassIDs|)</l>
<l>    throw ('No equal number of class IDs and segmentation regions.')</l>
<l>endif</l>
<l>tuple_select_mask (IncludedClassIDs, Area [&gt;] 0, ImageClassIDs)</l>
<c>* </c>
<c>* Display all non-empty class regions in distinct colors.</c>
<l>for Index := 0 to |IncludedClassIDs| - 1 by 1</l>
<l>    if (Area[Index] &gt; 0)</l>
<c>        * Use class ID to determine region color.</c>
<l>        ClassID := IncludedClassIDs[Index]</l>
<l>        IndexColor := find_first(ClassIDs,ClassID)</l>
<l>        dev_set_color (ColorsSegmentation[IndexColor])</l>
<c>        * Display the segmentation region.</c>
<l>        select_obj (Regions, SelectedRegion, Index + 1)</l>
<l>        dev_display (SelectedRegion)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="dev_display_segmentation_regions">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display the ground truth/result segmentation as regions.</short>
<parameters>
<parameter id="ClassIDs">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ColorsSegmentation">
<default_type>string</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ExcludeClassIDs">
<default_value>[]</default_value>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
</parameter>
<parameter id="ImageClassIDs">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SegmentationImage">
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_weight_image" access="local">
<interface>
<oo>
<par name="ImageWeight" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="SampleKeys" base_type="ctrl" dimension="0"/>
<par name="DLSample" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure returns the segmentation weight image of a sample.</c>
<c>* </c>
<l>if (find(SampleKeys,'weight_image') != -1)</l>
<l>    get_dict_object (ImageWeight, DLSample, 'weight_image')</l>
<l>else</l>
<l>    throw ('Weight image could not be found in DLSample.')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_weight_image">
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung und Kantenextraktion</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation and Edge Extraction</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the weight image of a sample.</short>
<parameters>
<parameter id="DLSample">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWeight">
<sem_type>image</sem_type>
</parameter>
<parameter id="SampleKeys">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_weight_regions" access="local">
<interface>
<io>
<par name="ImageWeight" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="DrawTransparency" base_type="ctrl" dimension="0"/>
<par name="SegMaxWeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Colors" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure displays a map of the weights</c>
<c>* given in ImageWeight as regions.</c>
<c>* The transparency can be adjusted.</c>
<c>* The used colors are returned.</c>
<c>* </c>
<c>* Define colors.</c>
<l>NumColors := 20</l>
<l>get_distinct_colors (NumColors, false, 0, 160, Colors)</l>
<l>tuple_inverse (Colors, Colors)</l>
<l>WeightsColorsAlpha := Colors + DrawTransparency</l>
<c>* </c>
<c>* Get gay values of ImageWeight.</c>
<l>get_domain (ImageWeight, Domain)</l>
<l>get_region_points (Domain, Rows, Columns)</l>
<l>get_grayval (ImageWeight, Rows, Columns, GrayVal)</l>
<c>* </c>
<c>* Check that the gray values of the image</c>
<c>* are below the specified maximum.</c>
<l>if (max(GrayVal) &gt; SegMaxWeight)</l>
<l>    throw ('The maximum weight (' + max(GrayVal) + ') in the weight image is greater than the given SegMaxWeight (' + SegMaxWeight + ').')</l>
<l>endif</l>
<c>* </c>
<l>while (GrayVal != [])</l>
<c>    * Go through all gray value 'groups',</c>
<c>    * starting from the maximum.</c>
<l>    GrayValWeight := max(GrayVal)</l>
<l>    GrayVal := remove(GrayVal,find(GrayVal,GrayValWeight))</l>
<l>    threshold (ImageWeight, WeightsRegion, GrayValWeight, GrayValWeight)</l>
<c>    * </c>
<c>    * Visualize the respective group.</c>
<l>    ColorIndex := int(ceil(GrayValWeight / SegMaxWeight * (NumColors - 1)))</l>
<l>    ClassColor := WeightsColorsAlpha[ColorIndex]</l>
<l>    dev_set_color (ClassColor)</l>
<l>    dev_display (WeightsRegion)</l>
<l>endwhile</l>
<l>return ()</l>
</body>
<docu id="dev_display_weight_regions">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display a map of weights.</short>
<parameters>
<parameter id="Colors">
<default_type>string</default_type>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DrawTransparency">
<default_type>string</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageWeight">
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="SegMaxWeight"/>
</parameters>
</docu>
</procedure>
<procedure name="visualize_point_cloud_and_gripping_pose" access="local">
<interface>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="DLResult" base_type="ctrl" dimension="0"/>
<par name="GenParams" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Checking if the data is present has been done while</c>
<c>* opening the window.</c>
<c>* </c>
<c>* Check mandatory point cloud specific parameters</c>
<c>* for their presence.</c>
<l>if (GenParams == [])</l>
<l>    throw ('Missing mandatory parameters.')</l>
<l>endif</l>
<l>PointCloudParams := ['arrow_length', 'arrow_thickness', 'sample_point_cloud', 'point_cloud_sample_distance', 'show_normals']</l>
<l>get_dict_param (GenParams, 'keys', [], GenParamNames)</l>
<l>for Index := 0 to |PointCloudParams| - 1 by 1</l>
<l>    if (find(GenParamNames,PointCloudParams[Index]) == -1)</l>
<l>        throw ('Missing mandatory parameter \'' + PointCloudParams[Index] + '\' in GenParams.')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Get data to generate the point cloud.</c>
<l>get_dict_object (Image, DLSample, 'image')</l>
<c>* </c>
<c>* Set the parameters to enable the texturing in</c>
<c>* visualize_object_model_3d.</c>
<c>* </c>
<l>if (GenParams.point_cloud_color != [])</l>
<l>    GenParamNamesOM3D := 'color_0'</l>
<l>    GenParamValuesOM3D := GenParams.point_cloud_color</l>
<l>else</l>
<l>    GenParamNamesOM3D := 'color_attrib_0'</l>
<l>    GenParamValuesOM3D := '&amp;gray'</l>
<l>endif</l>
<c></c>
<l>if (GenParams.show_normals == 'true')</l>
<c>    * If normals should be displayed, get the data</c>
<c>    * and attach the normals to the point cloud.</c>
<l>    get_dict_object (Normals, DLSample, 'normals')</l>
<l>    append_channel (Image, Normals, PointCloudData)</l>
<l>    xyz_attrib_to_object_model_3d (DLSample.['x'], DLSample.['y'], DLSample.['z'], PointCloudData, ['&amp;gray', 'point_normal_x', 'point_normal_y', 'point_normal_z'], ObjectModel3D)</l>
<l>    GenParamNamesOM3D := [GenParamNamesOM3D,'disp_normals_0']</l>
<l>    GenParamValuesOM3D := [GenParamValuesOM3D,'true']</l>
<l>    if (GenParams.normal_color != [])</l>
<l>        GenParamNamesOM3D := [GenParamNamesOM3D,'normal_color_0']</l>
<l>        GenParamValuesOM3D := [GenParamValuesOM3D,GenParams.normal_color]</l>
<l>    endif</l>
<l>else</l>
<c>    * If normals are not desired only texturize</c>
<c>    * the point cloud.</c>
<l>    xyz_attrib_to_object_model_3d (DLSample.['x'], DLSample.['y'], DLSample.['z'], Image, '&amp;gray', ObjectModel3D)</l>
<l>endif</l>
<c>* </c>
<c>* Get the poses of the gripping points.</c>
<l>NumberOfResults := 0</l>
<l>if (DLResult != [])</l>
<l>    get_dict_param (DLResult, 'key_exists', 'gripping_points', KeyExists)</l>
<l>    if (KeyExists)</l>
<l>        get_dict_tuple (DLResult, 'gripping_points', GrippingPoints)</l>
<l>        NumberOfResults := |GrippingPoints|</l>
<l>        Poses := {[]}</l>
<l>        for IndexGrippingPose := 0 to |GrippingPoints| - 1 by 1</l>
<l>            GrippingPointCoordDict := GrippingPoints[IndexGrippingPose]</l>
<l>            Poses.at(IndexGrippingPose) := GrippingPointCoordDict.pose</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Check if the point cloud should be sampled.</c>
<l>if (GenParams.sample_point_cloud == 'true')</l>
<l>    sample_object_model_3d (ObjectModel3D, 'xyz_mapping', GenParams.point_cloud_sample_distance, [], [], ObjectModel3D)</l>
<l>endif</l>
<c>* </c>
<c>* Generate the object model for the gripping pose.</c>
<l>gen_robot_tool_and_base_object_model_3d (GenParams.arrow_thickness, GenParams.arrow_length, OM3DToolOrigin, OM3DBase)</l>
<c>* </c>
<c>* Transform the gripping pose object model to</c>
<c>* the location in the point cloud and</c>
<c>* generate the parameter names and values for</c>
<c>* the gripping pose object model(s).</c>
<l>OM3DGrippingPoints := []</l>
<l>GenParamNameTools := []</l>
<l>GenParamValueTools := []</l>
<l>IndexGenParam := 1</l>
<l>for Index := 0 to NumberOfResults - 1 by 1</l>
<l>    rigid_trans_object_model_3d (OM3DToolOrigin, Poses.at(Index), OM3DTool)</l>
<l>    OM3DGrippingPoints := [OM3DGrippingPoints,OM3DTool]</l>
<l>    GenParamNameTools := [GenParamNameTools,'color_' + IndexGenParam,'color_' + (IndexGenParam + 1),'color_' + (IndexGenParam + 2)]</l>
<l>    GenParamValueTools := [GenParamValueTools,'red', 'green', 'blue']</l>
<l>    IndexGenParam := IndexGenParam + 3</l>
<l>endfor</l>
<c>* </c>
<c>* Generate visualization.</c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<l>Message := 'Inspect 3D scene and gripping poses'</l>
<l>visualize_object_model_3d (WindowHandle, [ObjectModel3D,OM3DGrippingPoints], [], [], [GenParamNamesOM3D,GenParamNameTools], [GenParamValuesOM3D,GenParamValueTools], Message, [], Instructions, PoseOut)</l>
<l>return ()</l>
</body>
<docu id="visualize_point_cloud_and_gripping_pose">
<abstract lang="en_US">This procedure visualizes a point cloud together with 3D gripping poses that are returned as the result of the 3D Gripping Point Detection.

DLSample is a dictionary that contains all relevant data needed to perform the 3D Gripping Point Detection.

DLResult is a dictionary that contains the results of the 3D Gripping Point Detection.

GenParams is a dictionary that can be used to customize the visualization. As some parameters are mandatory, the dict has to contain the following keys with corresponding values:
* *'arrow_length'*
* *'arrow_thickness'*
* *'sample_point_cloud'*
* *'point_cloud_sample_distance'*
* *'show_normals'*

Otherwise, the procedure will return an error. A detailed description of all mandatory and optional parameters for GenParams can be found in the procedure &lt;proc:dev_display_dl_data&gt;.

The point cloud and the 3D gripping poses are then displayed in the window WindowHandle.</abstract>
<chapters lang="de_DE">
<item>3D-Matching</item>
<item>3D Gripping Point Detection</item>
</chapters>
<chapters lang="en_US">
<item>3D Matching</item>
<item>3D Gripping Point Detection</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Visualize a point cloud and 3D gripping poses.</short>
<parameters>
<parameter id="DLResult">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the 3D Gripping Point Detection results.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the input data.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParams">
<default_type>integer</default_type>
<description lang="en_US">Dictionary customizing the visualization.</description>
<mixed_type>false</mixed_type>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the window used for the visualization.</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="tuple_shuffle">
<interface>
<ic>
<par name="Tuple" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Shuffled" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure sorts the input tuple randomly.</c>
<c>* </c>
<l>if (|Tuple| &gt; 0)</l>
<c>    * Create a tuple of random numbers,</c>
<c>    * sort this tuple, and return the indices</c>
<c>    * of this sorted tuple.</c>
<l>    ShuffleIndices := sort_index(rand(|Tuple|))</l>
<c>    * Assign the elements of Tuple</c>
<c>    * to these random positions.</c>
<l>    Shuffled := Tuple[ShuffleIndices]</l>
<l>else</l>
<c>    * If the input tuple is empty,</c>
<c>    * an empty tuple should be returned.</c>
<l>    Shuffled := []</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="tuple_shuffle">
<abstract lang="en_US">&lt;proc:tuple_shuffle&gt; sorts the elements of the input Tuple randomly, and returns the result in Shuffled. You can mix strings and numbers in Tuple. An empty input tuple results in an empty output tuple.</abstract>
<alternatives>
<item>tuple_sort</item>
</alternatives>
<chapters lang="de_DE">
<item>Tupel</item>
<item>Elementreihenfolge</item>
</chapters>
<chapters lang="en_US">
<item>Tuple</item>
<item>Element Order</item>
</chapters>
<example lang="de_DE">Tuple := [0:10]
tuple_shuffle (Tuple, Shuffled)</example>
<example lang="en_US">Tuple := [0:10]
tuple_shuffle (Tuple, Shuffled)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Sort the elements of a tuple randomly.</short>
<parameters>
<parameter id="Shuffled"/>
<parameter id="Tuple"/>
</parameters>
</docu>
</procedure>
<procedure name="check_dl_preprocess_param" access="local">
<interface>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure checks a dictionary with parameters for DL preprocessing.</c>
<c>* </c>
<l>CheckParams := true</l>
<c>* If check_params is set to false, do not check anything.</c>
<l>get_dict_param (DLPreprocessParam, 'key_exists', 'check_params', KeyExists)</l>
<l>if (KeyExists)</l>
<l>    get_dict_tuple (DLPreprocessParam, 'check_params', CheckParams)</l>
<l>    if (not CheckParams)</l>
<l>        return ()</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>try</l>
<l>    get_dict_tuple (DLPreprocessParam, 'model_type', DLModelType)</l>
<l>catch (Exception)</l>
<l>    throw ('DLPreprocessParam needs the parameter: \'' + 'model_type' + '\'')</l>
<l>endtry</l>
<c>* </c>
<c>* Check for correct model type.</c>
<l>SupportedModelTypes := ['3d_gripping_point_detection', 'anomaly_detection', 'classification', 'detection', 'gc_anomaly_detection', 'ocr_recognition', 'segmentation']</l>
<l>tuple_find (SupportedModelTypes, DLModelType, Index)</l>
<l>if ((Index == -1) or (Index == []))</l>
<l>    throw ('Only models of type \'3d_gripping_point_detection\', \'anomaly_detection\', \'classification\', \'detection\', \'gc_anomaly_detection\', \'ocr_recognition\' or \'segmentation\' are supported')</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Parameter names that are required.</c>
<c>* General parameters.</c>
<l>ParamNamesGeneral := ['model_type', 'image_width', 'image_height', 'image_num_channels', 'image_range_min', 'image_range_max', 'normalization_type', 'domain_handling']</l>
<c>* Segmentation specific parameters.</c>
<l>ParamNamesSegmentation := ['ignore_class_ids', 'set_background_id', 'class_ids_background']</l>
<c>* Detection specific parameters.</c>
<l>ParamNamesDetectionOptional := ['instance_type', 'ignore_direction', 'class_ids_no_orientation', 'instance_segmentation']</l>
<c>* Optional preprocessing parameters.</c>
<l>ParamNamesPreprocessingOptional := ['mean_values_normalization', 'deviation_values_normalization', 'check_params', 'augmentation']</l>
<c>* 3D Gripping Point Detection specific parameters.</c>
<l>ParamNames3DGrippingPointsOptional := ['min_z', 'max_z', 'normal_image_width', 'normal_image_height']</l>
<c>* All parameters</c>
<l>ParamNamesAll := [ParamNamesGeneral,ParamNamesSegmentation,ParamNamesDetectionOptional,ParamNames3DGrippingPointsOptional,ParamNamesPreprocessingOptional]</l>
<l>ParamNames := ParamNamesGeneral</l>
<l>if (DLModelType == 'segmentation')</l>
<c>    * Extend ParamNames for models of type segmentation.</c>
<l>    ParamNames := [ParamNames,ParamNamesSegmentation]</l>
<l>endif</l>
<c>* </c>
<c>* Check if legacy parameter exist.</c>
<c>* Otherwise map it to the legal parameter.</c>
<l>replace_legacy_preprocessing_parameters (DLPreprocessParam)</l>
<c>* </c>
<c>* Check that all necessary parameters are included.</c>
<c>* </c>
<l>get_dict_param (DLPreprocessParam, 'key_exists', ParamNames, KeysExists)</l>
<l>if (sum(KeysExists [==] 0) &gt; 0)</l>
<l>    for I := 0 to |KeysExists| by 1</l>
<l>        Exists := KeysExists[I]</l>
<l>        if (not Exists)</l>
<l>            throw ('DLPreprocessParam needs the parameter: \'' + ParamNames[I] + '\'')</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Check the keys provided.</c>
<l>get_dict_param (DLPreprocessParam, 'keys', [], InputKeys)</l>
<l>for I := 0 to |InputKeys| - 1 by 1</l>
<l>    Key := InputKeys[I]</l>
<l>    get_dict_tuple (DLPreprocessParam, Key, Value)</l>
<c>    * Check that the key is known.</c>
<l>    tuple_find (ParamNamesAll, Key, Indices)</l>
<l>    if (Indices == -1)</l>
<l>        throw ('Unknown key for DLPreprocessParam: \'' + InputKeys[I] + '\'')</l>
<l>        return ()</l>
<l>    endif</l>
<c>    * Set expected values and types.</c>
<l>    ValidValues := []</l>
<l>    ValidTypes := []</l>
<l>    if (Key == 'normalization_type')</l>
<l>        ValidValues := ['all_channels', 'first_channel', 'constant_values', 'none']</l>
<l>    elseif (Key == 'domain_handling')</l>
<l>        if (DLModelType == 'anomaly_detection')</l>
<l>            ValidValues := ['full_domain', 'crop_domain', 'keep_domain']</l>
<l>        elseif (DLModelType == '3d_gripping_point_detection')</l>
<l>            ValidValues := ['full_domain', 'crop_domain', 'keep_domain']</l>
<l>        else</l>
<l>            ValidValues := ['full_domain', 'crop_domain']</l>
<l>        endif</l>
<l>    elseif (Key == 'model_type')</l>
<l>        ValidValues := ['3d_gripping_point_detection', 'anomaly_detection', 'classification', 'detection', 'gc_anomaly_detection', 'ocr_recognition', 'segmentation']</l>
<l>    elseif (Key == 'augmentation')</l>
<l>        ValidValues := ['true', 'false']</l>
<l>    elseif (Key == 'set_background_id')</l>
<l>        ValidTypes := 'int'</l>
<l>    elseif (Key == 'class_ids_background')</l>
<l>        ValidTypes := 'int'</l>
<l>    endif</l>
<c>    * Check that type is valid.</c>
<l>    if (|ValidTypes| &gt; 0)</l>
<l>        for V := 0 to |ValidTypes| - 1 by 1</l>
<l>            T := ValidTypes[V]</l>
<l>            if (T == 'int')</l>
<l>                tuple_is_int (Value, IsInt)</l>
<l>                if (not IsInt)</l>
<l>                    ValidTypes := '\'' + ValidTypes + '\''</l>
<l>                    if (|ValidTypes| &lt; 2)</l>
<l>                        ValidTypesListing := ValidTypes</l>
<l>                    else</l>
<l>                        ValidTypesListing := sum(ValidTypes[0:max2(0,|ValidTypes| - 2)] + ', ' + ValidTypes[|ValidTypes| - 1])</l>
<l>                    endif</l>
<l>                    throw ('The value given in the key \'' + Key + '\' of DLPreprocessParam is invalid. Valid types are: ' + ValidTypesListing + '. The given value was \'' + Value + '\'.')</l>
<l>                    return ()</l>
<l>                endif</l>
<l>            else</l>
<l>                throw ('Internal error. Unknown valid type.')</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * Check that value is valid.</c>
<l>    if (|ValidValues| &gt; 0)</l>
<l>        tuple_find_first (ValidValues, Value, Index)</l>
<l>        if (Index == -1)</l>
<l>            ValidValues := '\'' + ValidValues + '\''</l>
<l>            if (|ValidValues| &lt; 2)</l>
<l>                ValidValueListing := ValidValues</l>
<l>            else</l>
<l>                EmptyStrings := gen_tuple_const(|ValidValues| - 2,'')</l>
<l>                ValidValueListing := sum(ValidValues[0:max2(0,|ValidValues| - 2)] + ', ' + [EmptyStrings,ValidValues[|ValidValues| - 1]])</l>
<l>            endif</l>
<l>            throw ('The value given in the key \'' + Key + '\' of DLPreprocessParam is invalid. Valid values are: ' + ValidValueListing + '. The given value was \'' + Value + '\'.')</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Check the correct setting of ImageRangeMin and ImageRangeMax.</c>
<l>if (DLModelType == 'classification' or DLModelType == 'detection')</l>
<c>    * Check ImageRangeMin and ImageRangeMax.</c>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', 'image_range_min', ImageRangeMinExists)</l>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', 'image_range_max', ImageRangeMaxExists)</l>
<c>    * If they are present, check that they are set correctly.</c>
<l>    if (ImageRangeMinExists)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)</l>
<l>        if (ImageRangeMin != -127)</l>
<l>            throw ('For model type ' + DLModelType + ' ImageRangeMin has to be -127.')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (ImageRangeMaxExists)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)</l>
<l>        if (ImageRangeMax != 128)</l>
<l>            throw ('For model type ' + DLModelType + ' ImageRangeMax has to be 128.')</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Check segmentation specific parameters.</c>
<l>if (DLModelType == 'segmentation')</l>
<c>    * Check if detection specific parameters are set.</c>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', ParamNamesDetectionOptional, KeysExists)</l>
<c>    * If they are present, check that they are [].</c>
<l>    for IndexParam := 0 to |ParamNamesDetectionOptional| - 1 by 1</l>
<l>        if (KeysExists[IndexParam])</l>
<l>            get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[IndexParam], Value)</l>
<l>            if (Value != [])</l>
<l>                throw ('The preprocessing parameter \'' + ParamNamesDetectionOptional[IndexParam] + '\' was set to ' + Value + ' but for segmentation it should be set to [], as it is not used for this method.')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Check 'set_background_id'.</c>
<l>    get_dict_tuple (DLPreprocessParam, 'set_background_id', SetBackgroundID)</l>
<l>    if (|SetBackgroundID| &gt; 1)</l>
<l>        throw ('Only one class_id as \'set_background_id\' allowed.')</l>
<l>    endif</l>
<c>    * Check 'class_ids_background'.</c>
<l>    get_dict_tuple (DLPreprocessParam, 'class_ids_background', ClassIDsBackground)</l>
<l>    if ((|SetBackgroundID| &gt; 0 and not (|ClassIDsBackground| &gt; 0)) or (|ClassIDsBackground| &gt; 0 and not (|SetBackgroundID| &gt; 0)))</l>
<l>        throw ('Both keys \'set_background_id\' and \'class_ids_background\' are required.')</l>
<l>    endif</l>
<c>    * Check that 'class_ids_background' and 'set_background_id' are disjoint.</c>
<l>    if (|SetBackgroundID| &gt; 0)</l>
<l>        tuple_intersection (SetBackgroundID, ClassIDsBackground, Intersection)</l>
<l>        if (|Intersection|)</l>
<l>            throw ('Class IDs in \'set_background_id\' and \'class_ids_background\' need to be disjoint.')</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Check 'ignore_class_ids'.</c>
<l>    get_dict_tuple (DLPreprocessParam, 'ignore_class_ids', IgnoreClassIDs)</l>
<l>    KnownClasses := [SetBackgroundID,ClassIDsBackground]</l>
<l>    for I := 0 to |IgnoreClassIDs| - 1 by 1</l>
<l>        IgnoreClassID := IgnoreClassIDs[I]</l>
<l>        tuple_find_first (KnownClasses, IgnoreClassID, Index)</l>
<l>        if (|Index| &gt; 0 and Index != -1)</l>
<l>            throw ('The given \'ignore_class_ids\' must not be included in the \'class_ids_background\' or \'set_background_id\'.')</l>
<l>        endif</l>
<l>    endfor</l>
<l>elseif (DLModelType == 'detection')</l>
<c>    * Check if segmentation specific parameters are set.</c>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', ParamNamesSegmentation, KeysExists)</l>
<c>    * If they are present, check that they are [].</c>
<l>    for IndexParam := 0 to |ParamNamesSegmentation| - 1 by 1</l>
<l>        if (KeysExists[IndexParam])</l>
<l>            get_dict_tuple (DLPreprocessParam, ParamNamesSegmentation[IndexParam], Value)</l>
<l>            if (Value != [])</l>
<l>                throw ('The preprocessing parameter \'' + ParamNamesSegmentation[IndexParam] + '\' was set to ' + Value + ' but for detection it should be set to [], as it is not used for this method.')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Check optional parameters.</c>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', ParamNamesDetectionOptional, OptionalKeysExist)</l>
<l>    if (OptionalKeysExist[0])</l>
<c>        * Check 'instance_type'.</c>
<l>        get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[0], InstanceType)</l>
<l>        if (find(['rectangle1', 'rectangle2', 'mask'],InstanceType) == -1)</l>
<l>            throw ('Invalid generic parameter for \'instance_type\': ' + InstanceType + ', only \'rectangle1\' and \'rectangle2\' are allowed')</l>
<l>        endif</l>
<l>    endif</l>
<c>    * If instance_segmentation is set we might overwrite the instance_type for the preprocessing.</c>
<l>    if (OptionalKeysExist[3])</l>
<l>        get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[3], IsInstanceSegmentation)</l>
<l>        if (find([true, false, 'true', 'false'],IsInstanceSegmentation) == -1)</l>
<l>            throw ('Invalid generic parameter for \'instance_segmentation\': ' + IsInstanceSegmentation + ', only true, false, \'true\' and \'false\' are allowed')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (OptionalKeysExist[1])</l>
<c>        * Check 'ignore_direction'.</c>
<l>        get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[1], IgnoreDirection)</l>
<l>        if (find([true, false],IgnoreDirection) == -1)</l>
<l>            throw ('Invalid generic parameter for \'ignore_direction\': ' + IgnoreDirection + ', only true and false are allowed')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (OptionalKeysExist[2])</l>
<c>        * Check 'class_ids_no_orientation'.</c>
<l>        get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[2], ClassIDsNoOrientation)</l>
<l>        tuple_sem_type_elem (ClassIDsNoOrientation, SemTypes)</l>
<l>        if (ClassIDsNoOrientation != [] and sum(SemTypes [==] 'integer') != |ClassIDsNoOrientation|)</l>
<l>            throw ('Invalid generic parameter for \'class_ids_no_orientation\': ' + ClassIDsNoOrientation + ', only integers are allowed')</l>
<l>        else</l>
<l>            if (ClassIDsNoOrientation != [] and sum(ClassIDsNoOrientation [&gt;=] 0) != |ClassIDsNoOrientation|)</l>
<l>                throw ('Invalid generic parameter for \'class_ids_no_orientation\': ' + ClassIDsNoOrientation + ', only non-negative integers are allowed')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="check_dl_preprocess_param">
<abstract lang="en_US">This procedure checks the content of the parameter dictionary DLPreprocessParam.

If DLPreprocessParam contains a key 'check_params' with value false, the procedure returns without checking any parameter.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Check the content of the parameter dictionary DLPreprocessParam.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Parameter dictionary to check.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_augmentation_data">
<interface>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure preprocesses the provided DLSample image for augmentation purposes.</c>
<c>* </c>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* Get the required preprocessing parameters.</c>
<l>ImageWidth := DLPreprocessParam.image_width</l>
<l>ImageHeight := DLPreprocessParam.image_height</l>
<l>ImageNumChannels := DLPreprocessParam.image_num_channels</l>
<l>ModelType := DLPreprocessParam.model_type</l>
<c>* </c>
<c>* Determine whether the preprocessing is required or not.</c>
<l>get_dict_param (DLPreprocessParam, 'key_exists', 'augmentation', AugmentationKeyExists)</l>
<l>if (not AugmentationKeyExists)</l>
<l>    return ()</l>
<l>endif</l>
<l>if (DLPreprocessParam.augmentation != 'true')</l>
<l>    return ()</l>
<l>endif</l>
<l>if (ModelType != 'ocr_recognition')</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* Get the input image and its properties.</c>
<l>get_dict_param (DLSample, 'key_exists', 'image', ImageKeyExists)</l>
<l>if (not ImageKeyExists)</l>
<l>    throw ('The sample to process needs to include an image.')</l>
<l>endif</l>
<l>InputImage := DLSample.image</l>
<l>count_obj (InputImage, NumImages)</l>
<l>if (NumImages != 1)</l>
<l>    throw ('The sample to process needs to include exactly 1 image.')</l>
<l>endif</l>
<l>count_channels (InputImage, NumChannels)</l>
<l>get_image_type (InputImage, ImageType)</l>
<l>get_image_size (InputImage, InputImageWidth, InputImageHeight)</l>
<c>* </c>
<c>* Execute model specific preprocessing.</c>
<l>if (ModelType == 'ocr_recognition')</l>
<l>    if (ImageNumChannels != 1)</l>
<l>        throw ('The only \'image_num_channels\' value supported for ocr_recognition models is 1.')</l>
<l>    endif</l>
<l>    if (regexp_test(ImageType,'byte|real') != 1)</l>
<l>        throw ('Please provide only images of type \'byte\' or \'real\' for ocr_recognition models.')</l>
<l>    endif</l>
<l>    if (sum(NumChannels [==] 1 or NumChannels [==] 3) != 1)</l>
<l>        throw ('Please provide only 1- or 3-channels images for ocr_recognition models.')</l>
<l>    endif</l>
<c>    * </c>
<l>    full_domain (InputImage, ImageHighRes)</l>
<l>    if (NumChannels == 3)</l>
<l>        rgb1_to_gray (ImageHighRes, ImageHighRes)</l>
<l>    endif</l>
<l>    InputImageWidthHeightRatio := InputImageWidth / real(InputImageHeight)</l>
<l>    ZoomHeight := min2(InputImageHeight,2 * ImageHeight)</l>
<l>    ZoomWidth := int(ZoomHeight * InputImageWidthHeightRatio)</l>
<l>    HasPadding := int(ImageHeight * InputImageWidthHeightRatio) &lt; ImageWidth</l>
<l>    if (ZoomHeight &gt; ImageHeight or HasPadding)</l>
<l>        zoom_image_size (ImageHighRes, ImageHighRes, ZoomWidth, ZoomHeight, 'constant')</l>
<l>        DLSample.augmentation_data := dict{}</l>
<l>        DLSample.augmentation_data.image_high_res := ImageHighRes</l>
<l>        DLSample.augmentation_data.preprocess_params := DLPreprocessParam</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_augmentation_data">
<abstract lang="en_US">This procedure preprocesses data from DLSample for augmentation purposes, according to the parameters in the dictionary DLPreprocessParam.

The resulting data is stored in DLSample in the dictionary field 'augmentation_data'. The dictionary 'augmentation_data' is used by &lt;proc:augment_dl_samples&gt;.

The dictionary DLPreprocessParam specifies the properties the images need for a successful model application, and it can be created using e.g., &lt;proc:create_dl_preprocess_param&gt; or &lt;proc:create_dl_preprocess_param_from_model&gt;.

This procedure works only if the preprocessing parameter 'augmentation_data' is set to 'true'.

The procedure supports only the model type 'ocr_recognition'.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess the provided DLSample image for augmentation purposes.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<description lang="en_US">DLSample dictionary.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_images">
<interface>
<io>
<par name="Images" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImagesPreprocessed" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure preprocesses the provided Images according to the parameters in</c>
<c>* the dictionary DLPreprocessParam. Note that depending on the images, additional</c>
<c>* preprocessing steps might be beneficial.</c>
<c>* </c>
<c>* </c>
<c>* Get the preprocessing parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_num_channels', ImageNumChannels)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)</l>
<l>get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<l>get_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)</l>
<l>get_dict_tuple (DLPreprocessParam, 'model_type', ModelType)</l>
<c>* </c>
<c>* Validate the type of the input images.</c>
<l>count_obj (Images, NumImages)</l>
<l>get_image_type (Images, Type)</l>
<l>tuple_regexp_test (Type, 'byte|int|real', NumMatches)</l>
<c></c>
<c>* Validate the number channels of the input images.</c>
<l>count_channels (Images, InputNumChannels)</l>
<l>OutputNumChannels := gen_tuple_const(NumImages,ImageNumChannels)</l>
<c>* Only for 'image_num_channels' 1 and 3 combinations of 1- and 3-channel images are allowed.</c>
<l>if (ImageNumChannels == 1 or ImageNumChannels == 3)</l>
<l>    NumChannels1 := gen_tuple_const(NumImages,1)</l>
<l>    NumChannels3 := gen_tuple_const(NumImages,3)</l>
<l>    AreInputNumChannels1 := InputNumChannels [==] NumChannels1</l>
<l>    AreInputNumChannels3 := InputNumChannels [==] NumChannels3</l>
<l>    AreInputNumChannels1Or3 := AreInputNumChannels1 + AreInputNumChannels3</l>
<l>    ValidNumChannels := AreInputNumChannels1Or3 == NumChannels1</l>
<l>    ValidNumChannelsText := 'Valid numbers of channels for the specified model are 1 or 3.'</l>
<l>endif</l>
<c></c>
<c>* Preprocess the images.</c>
<c>* </c>
<c>* For models of type '3d_gripping_point_detection', the preprocessing steps need to be performed on full</c>
<c>* domain images while the domains are preserved and set back into the images after the preprocessing.</c>
<l>PreserveDomain := false</l>
<c></c>
<c>* </c>
<c>* Apply the domain to the images.</c>
<l>if (DomainHandling == 'full_domain')</l>
<l>    full_domain (Images, Images)</l>
<l>endif</l>
<c>* </c>
<c>* Zoom preserved domains before zooming the images.</c>
<c></c>
<l>if (regexp_test(Type,'int1|int4|int8') == 0)</l>
<l>    zoom_image_size (Images, Images, ImageWidth, ImageHeight, 'constant')</l>
<l>    convert_image_type (Images, Images, 'real')</l>
<l>endif</l>
<c>* </c>
<l>if (NormalizationType == 'all_channels')</l>
<l>elseif (NormalizationType == 'none')</l>
<l>    tuple_find (Type, 'byte', Indices)</l>
<l>    if (Indices != -1)</l>
<c>        * Shift the gray values from [0-255] to the expected range for byte images.</c>
<l>        RescaleRange := (ImageRangeMax - ImageRangeMin) / 255.0</l>
<l>        select_obj (Images, ImageSelected, Indices + 1)</l>
<l>        scale_image (ImageSelected, ImageSelected, RescaleRange, ImageRangeMin)</l>
<l>        replace_obj (Images, ImageSelected, Images, Indices + 1)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Ensure that the number of channels of the resulting images is consistent with the</c>
<c>* number of channels of the given model. The only exceptions that are adapted below</c>
<c>* are combinations of 1- and 3-channel images if ImageNumChannels is either 1 or 3.</c>
<l>if (ImageNumChannels == 1 or ImageNumChannels == 3)</l>
<l>    count_channels (Images, CurrentNumChannels)</l>
<l>    tuple_find (CurrentNumChannels [!=] OutputNumChannels, 1, DiffNumChannelsIndices)</l>
<l>endif</l>
<c>* </c>
<c>* In case the image domains were preserved, they need to be set back into the images.</c>
<c></c>
<c>* Write preprocessed images to output variable.</c>
<l>ImagesPreprocessed := Images</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_images">
<abstract lang="en_US">This procedure preprocesses the provided Images according to the parameters in the dictionary DLPreprocessParam.

The dictionary DLPreprocessParam specifies the properties the images need for a successful model application.

The preprocessed images are returned in ImagesPreprocessed.

The dictionary DLPreprocessParam can be created using e.g., &lt;proc:create_dl_preprocess_param&gt; or &lt;proc:create_dl_preprocess_param_from_model&gt;.

Note that depending on the dataset, additional customized preprocessing steps might be beneficial, but they have to be done before this procedure is called.

It is recommended to check the output images of this procedure in order to verify that they are suitable for a successful training of a model. For example, if defects on the images are no longer discernible after zooming, it might help to increase the image dimensions.

Note that this procedure can only preprocess input images fulfilling the following conditions:
- Image type is equal to 'byte', 'int1', 'int2', 'uint2', 'int4', 'int8' or 'real'.&lt;br/&gt;
   Different image types could be combined if the other conditions are met.
- Number of channels is equal to the parameter *'image_num_channels'* in DLPreprocessParam.&lt;br/&gt;
   Special cases:
   - *'image_num_channels'* is either *1* or *3*: For each case, both 1- and 3-channel images will also be supported and their output adapted if required.
   - *'normalization_type'* is *'constant_values'* and any of the parameters 'mean_values_normalization' or 'deviation_values_normalization' was not specified: Only 1- or 3-channel images will be supported if *'image_num_channels'* is *1* or *3*.
   - *'normalization_type'* is 'none': It is expected that images of type 'real' and 'int' already have gray values in the range [ImageRangeMin,ImageRangeMax].

If an input image differs in these points, please execute a customized preprocessing.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess images for deep-learning-based training and inference.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Images">
<description lang="en_US">Images to be preprocessed.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImagesPreprocessed">
<description lang="en_US">Preprocessed images.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_anomaly">
<interface>
<io>
<par name="AnomalyImages" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="AnomalyImagesPreprocessed" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure preprocesses the anomaly images given by AnomalyImages</c>
<c>* according to the parameters in the dictionary DLPreprocessParam.</c>
<c>* Note that depending on the images,</c>
<c>* additional preprocessing steps might be beneficial.</c>
<c>* </c>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* Get the preprocessing parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)</l>
<l>get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<l>get_dict_tuple (DLPreprocessParam, 'model_type', ModelType)</l>
<c>* </c>
<l>ImageNumChannels := 1</l>
<c>* </c>
<c>* Preprocess the images.</c>
<c>* </c>
<l>if (DomainHandling == 'full_domain')</l>
<l>    full_domain (AnomalyImages, AnomalyImages)</l>
<l>elseif (DomainHandling == 'crop_domain')</l>
<l>    crop_domain (AnomalyImages, AnomalyImages)</l>
<l>elseif (DomainHandling == 'keep_domain' and ModelType == 'anomaly_detection')</l>
<c>    * The option 'keep_domain' is only supported for models of 'type' = 'anomaly_detection'</c>
<l>else</l>
<l>    throw ('Unsupported parameter value for \'domain_handling\'')</l>
<l>endif</l>
<c>* </c>
<l>min_max_gray (AnomalyImages, AnomalyImages, 0, Min, Max, Range)</l>
<l>if (Min &lt; 0.0)</l>
<l>    throw ('Values of anomaly image must not be smaller than 0.0.')</l>
<l>endif</l>
<c>* </c>
<c>* Zoom images only if they have a different size than the specified size.</c>
<l>get_image_size (AnomalyImages, ImageWidthInput, ImageHeightInput)</l>
<l>EqualWidth := ImageWidth [==] ImageWidthInput</l>
<l>EqualHeight := ImageHeight [==] ImageHeightInput</l>
<l>if (min(EqualWidth) == 0 or min(EqualHeight) == 0)</l>
<l>    zoom_image_size (AnomalyImages, AnomalyImages, ImageWidth, ImageHeight, 'nearest_neighbor')</l>
<l>endif</l>
<c>* </c>
<c>* Check the type of the input images.</c>
<l>get_image_type (AnomalyImages, Type)</l>
<l>tuple_regexp_test (Type, 'byte|real', NumMatches)</l>
<l>count_obj (AnomalyImages, NumImages)</l>
<l>if (NumMatches != NumImages)</l>
<l>    throw ('Please provide only images of type \'byte\' or \'real\'.')</l>
<l>endif</l>
<c>* </c>
<c>* If the type is 'byte', convert it to 'real' and scale it.</c>
<c>* The gray value scaling does not work on 'byte' images.</c>
<c>* For 'real' images it is assumed that the range is already correct.</c>
<l>EqualByte := Type [==] 'byte'</l>
<l>if (max(EqualByte) == 1)</l>
<l>    if (min(EqualByte) == 0)</l>
<l>        throw ('Passing mixed type images is not supported.')</l>
<l>    endif</l>
<c>    * Convert the image type from 'byte' to 'real',</c>
<c>    * because the model expects 'real' images.</c>
<l>    convert_image_type (AnomalyImages, AnomalyImages, 'real')</l>
<l>endif</l>
<c>* </c>
<c>* Check the number of channels.</c>
<l>count_obj (AnomalyImages, NumImages)</l>
<c>* Check all images for number of channels.</c>
<l>count_channels (AnomalyImages, NumChannelsAllImages)</l>
<l>tuple_gen_const (NumImages, ImageNumChannels, ImageNumChannelsTuple)</l>
<l>tuple_find (NumChannelsAllImages [!=] ImageNumChannelsTuple, 1, IndicesWrongChannels)</l>
<c>* </c>
<c>* Check for anomaly image channels.</c>
<c>* Only single channel images are accepted.</c>
<l>if (IndicesWrongChannels != -1)</l>
<l>    throw ('Number of channels in anomaly image is not supported. Please check for anomaly images with a number of channels different from 1.')</l>
<l>endif</l>
<c>* </c>
<c>* Write preprocessed image to output variable.</c>
<l>AnomalyImagesPreprocessed := AnomalyImages</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_anomaly">
<abstract lang="en_US">This procedure preprocesses the anomaly images given by AnomalyImages which can be used as ground truth for evaluation and visualization.

The dictionary DLPreprocessParam specifies the properties the images need to be used as ground truth for model types *'anomaly_detection'* and *'gc_anomaly_detection'*.

The AnomalyImages are, if necessary, modified in order to fulfill the following requirements:
- image size: set to the sample image size
- image type: set to real
The preprocessed images are returned in AnomalyImagesPreprocessed.

The dictionary DLPreprocessParam can be created using e.g., &lt;proc:create_dl_preprocess_param&gt; or &lt;proc:create_dl_preprocess_param_from_model&gt;.
For further information on the parameters to be set in DLPreprocessParam, see the documentation of &lt;proc:preprocess_dl_samples&gt;.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess anomaly images for evaluation and visualization of deep-learning-based anomaly detection or Global Context Anomaly Detection.</short>
<parameters>
<parameter id="AnomalyImages">
<description lang="en_US">Images to be preprocessed.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="AnomalyImagesPreprocessed">
<description lang="en_US">Preprocessed images.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_bbox_rect1" access="local">
<interface>
<io>
<par name="ImageRaw" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure preprocesses the bounding boxes of type 'rectangle1' for a given sample.</c>
<c>* </c>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* Get the preprocessing parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<c>* </c>
<c>* Get bounding box coordinates and labels.</c>
<l>try</l>
<l>    get_dict_tuple (DLSample, 'bbox_col1', BBoxCol1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_col2', BBoxCol2)</l>
<l>    get_dict_tuple (DLSample, 'bbox_row1', BBoxRow1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_row2', BBoxRow2)</l>
<l>    get_dict_tuple (DLSample, 'bbox_label_id', BBoxLabel)</l>
<l>catch (Exception)</l>
<l>    get_dict_tuple (DLSample, 'image_id', ImageId)</l>
<l>    if (Exception[0] == 1302)</l>
<l>        ExceptionMessage := 'A bounding box coordinate key is missing.'</l>
<l>    else</l>
<l>        ExceptionMessage := Exception[2]</l>
<l>    endif</l>
<l>    throw ('An error has occurred during preprocessing image_id ' + ImageId + ' when getting bounding box coordinates : ' + ExceptionMessage)</l>
<l>endtry</l>
<c>* </c>
<c>* Check that there are no invalid boxes.</c>
<l>if (|BBoxRow1| &gt; 0)</l>
<l>    BoxesInvalid := (BBoxRow1 [&gt;=] BBoxRow2) or (BBoxCol1 [&gt;=] BBoxCol2)</l>
<l>    if (sum(BoxesInvalid) &gt; 0)</l>
<l>        get_dict_tuple (DLSample, 'image_id', ImageId)</l>
<l>        throw ('An error has occurred during preprocessing image_id ' + ImageId + ': Sample contains at least one box with zero-area, i.e. bbox_col1 &gt;= bbox_col2 or bbox_row1 &gt;= bbox_row2.')</l>
<l>    endif</l>
<l>else</l>
<c>    * There are no bounding boxes, hence nothing to do.</c>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* If the domain is cropped, crop bounding boxes.</c>
<l>if (DomainHandling == 'crop_domain')</l>
<c>    * </c>
<c>    * Get domain.</c>
<l>    get_domain (ImageRaw, DomainRaw)</l>
<c>    * </c>
<c>    * Set the size of the raw image to the domain extensions.</c>
<l>    smallest_rectangle1 (DomainRaw, DomainRow1, DomainColumn1, DomainRow2, DomainColumn2)</l>
<c>    * The domain is always given as a pixel-precise region.</c>
<l>    WidthRaw := DomainColumn2 - DomainColumn1 + 1.0</l>
<l>    HeightRaw := DomainRow2 - DomainRow1 + 1.0</l>
<c>    * </c>
<c>    * Crop the bounding boxes.</c>
<l>    Row1 := max2(BBoxRow1,DomainRow1 - .5)</l>
<l>    Col1 := max2(BBoxCol1,DomainColumn1 - .5)</l>
<l>    Row2 := min2(BBoxRow2,DomainRow2 + .5)</l>
<l>    Col2 := min2(BBoxCol2,DomainColumn2 + .5)</l>
<l>    MaskDelete := (Row1 [&gt;=] Row2) or (Col1 [&gt;=] Col2)</l>
<l>    MaskNewBbox := 1 - MaskDelete</l>
<c>    * Store the preprocessed bounding box entries.</c>
<l>    BBoxCol1New := select_mask(Col1,MaskNewBbox) - DomainColumn1</l>
<l>    BBoxCol2New := select_mask(Col2,MaskNewBbox) - DomainColumn1</l>
<l>    BBoxRow1New := select_mask(Row1,MaskNewBbox) - DomainRow1</l>
<l>    BBoxRow2New := select_mask(Row2,MaskNewBbox) - DomainRow1</l>
<l>    BBoxLabelNew := select_mask(BBoxLabel,MaskNewBbox)</l>
<c>    * </c>
<c>    * If we remove/select bounding boxes we also need to filter the corresponding</c>
<c>    * instance segmentation masks if they exist.</c>
<l>    filter_dl_sample_instance_segmentation_masks (DLSample, MaskNewBbox)</l>
<l>elseif (DomainHandling == 'full_domain')</l>
<c>    * If the entire image is used, set the variables accordingly.</c>
<c>    * Get the original size.</c>
<l>    get_image_size (ImageRaw, WidthRaw, HeightRaw)</l>
<c>    * Set new coordinates to input coordinates.</c>
<l>    BBoxCol1New := BBoxCol1</l>
<l>    BBoxCol2New := BBoxCol2</l>
<l>    BBoxRow1New := BBoxRow1</l>
<l>    BBoxRow2New := BBoxRow2</l>
<l>    BBoxLabelNew := BBoxLabel</l>
<l>else</l>
<l>    throw ('Unsupported parameter value for \'domain_handling\'')</l>
<l>endif</l>
<c>* </c>
<c>* Rescale the bounding boxes.</c>
<c>* </c>
<c>* Get required images width and height.</c>
<c>* </c>
<c>* Only rescale bounding boxes if the required image dimensions are not the raw dimensions.</c>
<l>if (ImageHeight != HeightRaw or ImageWidth != WidthRaw)</l>
<c>    * Calculate rescaling factor.</c>
<l>    FactorResampleWidth := real(ImageWidth) / WidthRaw</l>
<l>    FactorResampleHeight := real(ImageHeight) / HeightRaw</l>
<c>    * Rescale the bounding box coordinates.</c>
<c>    * As we use XLD-coordinates we temporarily move the boxes by (.5,.5) for rescaling.</c>
<c>    * Doing so, the center of the XLD-coordinate system (-0.5,-0.5) is used</c>
<c>    * for scaling, hence the scaling is performed w.r.t. the pixel coordinate system.</c>
<l>    BBoxCol1New := (BBoxCol1New + .5) * FactorResampleWidth - .5</l>
<l>    BBoxCol2New := (BBoxCol2New + .5) * FactorResampleWidth - .5</l>
<l>    BBoxRow1New := (BBoxRow1New + .5) * FactorResampleHeight - .5</l>
<l>    BBoxRow2New := (BBoxRow2New + .5) * FactorResampleHeight - .5</l>
<c>    * </c>
<l>endif</l>
<c>* </c>
<c>* Make a final check and remove bounding boxes that have zero area.</c>
<l>if (|BBoxRow1New| &gt; 0)</l>
<l>    MaskDelete := (BBoxRow1New [&gt;=] BBoxRow2New) or (BBoxCol1New [&gt;=] BBoxCol2New)</l>
<l>    BBoxCol1New := select_mask(BBoxCol1New,1 - MaskDelete)</l>
<l>    BBoxCol2New := select_mask(BBoxCol2New,1 - MaskDelete)</l>
<l>    BBoxRow1New := select_mask(BBoxRow1New,1 - MaskDelete)</l>
<l>    BBoxRow2New := select_mask(BBoxRow2New,1 - MaskDelete)</l>
<l>    BBoxLabelNew := select_mask(BBoxLabelNew,1 - MaskDelete)</l>
<c>    * </c>
<c>    * If we remove/select bounding boxes we also need to filter the corresponding</c>
<c>    * instance segmentation masks if they exist.</c>
<l>    filter_dl_sample_instance_segmentation_masks (DLSample, 1 - MaskDelete)</l>
<l>endif</l>
<c>* </c>
<c>* Set new bounding box coordinates in the dictionary.</c>
<l>set_dict_tuple (DLSample, 'bbox_col1', BBoxCol1New)</l>
<l>set_dict_tuple (DLSample, 'bbox_col2', BBoxCol2New)</l>
<l>set_dict_tuple (DLSample, 'bbox_row1', BBoxRow1New)</l>
<l>set_dict_tuple (DLSample, 'bbox_row2', BBoxRow2New)</l>
<l>set_dict_tuple (DLSample, 'bbox_label_id', BBoxLabelNew)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_bbox_rect1">
<abstract lang="en_US">This procedure preprocesses the bounding boxes of type 'rectangle1' for a sample given by the dictionary DLSample.
In particular the bounding boxes are rescaled according to the rescaling of the images to the size required by the deep learning model.
All required parameters are provided through the dictionary DLPreprocessParam.

The dictionary DLPreprocessParam can be created using e.g., &lt;proc:create_dl_preprocess_param&gt; or &lt;proc:create_dl_preprocess_param_from_model&gt;.
For information to the preprocessing parameters, see the documentation of &lt;proc:preprocess_dl_samples&gt;.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Objektdetektion und Instanz-Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection and Instance Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess the bounding boxes of type 'rectangle1' for a given sample.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<default_value>DLSample</default_value>
<description lang="en_US">Dictionary of the sample related to ImageRaw and containing the bounding boxes appertain.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageRaw">
<description lang="en_US">Raw, not preprocessed image.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_bbox_rect2" access="local">
<interface>
<io>
<par name="ImageRaw" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure preprocesses the bounding boxes of type 'rectangle2' for a given sample.</c>
<c>* </c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* Get preprocess parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<c>* The keys 'ignore_direction' and 'class_ids_no_orientation' are optional.</c>
<l>IgnoreDirection := false</l>
<l>ClassIDsNoOrientation := []</l>
<l>get_dict_param (DLPreprocessParam, 'key_exists', ['ignore_direction', 'class_ids_no_orientation'], KeyExists)</l>
<l>if (KeyExists[0])</l>
<l>    get_dict_tuple (DLPreprocessParam, 'ignore_direction', IgnoreDirection)</l>
<l>    if (IgnoreDirection == 'true')</l>
<l>        IgnoreDirection := true</l>
<l>    elseif (IgnoreDirection == 'false')</l>
<l>        IgnoreDirection := false</l>
<l>    endif</l>
<l>endif</l>
<l>if (KeyExists[1])</l>
<l>    get_dict_tuple (DLPreprocessParam, 'class_ids_no_orientation', ClassIDsNoOrientation)</l>
<l>endif</l>
<c>* </c>
<c>* Get bounding box coordinates and labels.</c>
<l>try</l>
<l>    get_dict_tuple (DLSample, 'bbox_row', BBoxRow)</l>
<l>    get_dict_tuple (DLSample, 'bbox_col', BBoxCol)</l>
<l>    get_dict_tuple (DLSample, 'bbox_length1', BBoxLength1)</l>
<l>    get_dict_tuple (DLSample, 'bbox_length2', BBoxLength2)</l>
<l>    get_dict_tuple (DLSample, 'bbox_phi', BBoxPhi)</l>
<l>    get_dict_tuple (DLSample, 'bbox_label_id', BBoxLabel)</l>
<l>catch (Exception)</l>
<l>    get_dict_tuple (DLSample, 'image_id', ImageId)</l>
<l>    if (Exception[0] == 1302)</l>
<l>        ExceptionMessage := 'A bounding box coordinate key is missing.'</l>
<l>    else</l>
<l>        ExceptionMessage := Exception[2]</l>
<l>    endif</l>
<l>    throw ('An error has occurred during preprocessing image_id ' + ImageId + ' when getting bounding box coordinates : ' + ExceptionMessage)</l>
<l>endtry</l>
<c>* </c>
<c>* Check that there are no invalid boxes.</c>
<l>if (|BBoxRow| &gt; 0)</l>
<l>    BoxesInvalid := sum(BBoxLength1 [==] 0) + sum(BBoxLength2 [==] 0)</l>
<l>    if (BoxesInvalid &gt; 0)</l>
<l>        get_dict_tuple (DLSample, 'image_id', ImageId)</l>
<l>        throw ('An error has occurred during preprocessing image_id ' + ImageId + ': Sample contains at least one bounding box with zero-area, i.e. bbox_length1 == 0 or bbox_length2 == 0!')</l>
<l>    endif</l>
<l>else</l>
<c>    * There are no bounding boxes, hence nothing to do.</c>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* If the domain is cropped, crop bounding boxes.</c>
<l>if (DomainHandling == 'crop_domain')</l>
<c>    * </c>
<c>    * Get domain.</c>
<l>    get_domain (ImageRaw, DomainRaw)</l>
<c>    * </c>
<c>    * Set the size of the raw image to the domain extensions.</c>
<l>    smallest_rectangle1 (DomainRaw, DomainRow1, DomainColumn1, DomainRow2, DomainColumn2)</l>
<l>    WidthRaw := DomainColumn2 - DomainColumn1 + 1</l>
<l>    HeightRaw := DomainRow2 - DomainRow1 + 1</l>
<c>    * </c>
<c>    * Crop the bounding boxes.</c>
<c>    * Remove the boxes with center outside of the domain.</c>
<l>    MaskDelete := (BBoxRow [&lt;] DomainRow1 or BBoxCol [&lt;] DomainColumn1 or BBoxRow [&gt;] DomainRow2) or (BBoxCol [&gt;] DomainColumn2)</l>
<l>    MaskNewBbox := 1 - MaskDelete</l>
<c>    * Store the preprocessed bounding box entries.</c>
<l>    BBoxRowNew := select_mask(BBoxRow,MaskNewBbox) - DomainRow1</l>
<l>    BBoxColNew := select_mask(BBoxCol,MaskNewBbox) - DomainColumn1</l>
<l>    BBoxLength1New := select_mask(BBoxLength1,MaskNewBbox)</l>
<l>    BBoxLength2New := select_mask(BBoxLength2,MaskNewBbox)</l>
<l>    BBoxPhiNew := select_mask(BBoxPhi,MaskNewBbox)</l>
<l>    BBoxLabelNew := select_mask(BBoxLabel,MaskNewBbox)</l>
<c>    * </c>
<c>    * If we remove/select bounding boxes we also need to filter the corresponding</c>
<c>    * instance segmentation masks if they exist.</c>
<l>    filter_dl_sample_instance_segmentation_masks (DLSample, MaskNewBbox)</l>
<c>    * </c>
<l>elseif (DomainHandling == 'full_domain')</l>
<c>    * If the entire image is used, set the variables accordingly.</c>
<c>    * Get the original size.</c>
<l>    get_image_size (ImageRaw, WidthRaw, HeightRaw)</l>
<c>    * Set new coordinates to input coordinates.</c>
<l>    BBoxRowNew := BBoxRow</l>
<l>    BBoxColNew := BBoxCol</l>
<l>    BBoxLength1New := BBoxLength1</l>
<l>    BBoxLength2New := BBoxLength2</l>
<l>    BBoxPhiNew := BBoxPhi</l>
<l>    BBoxLabelNew := BBoxLabel</l>
<l>else</l>
<l>    throw ('Unsupported parameter value for \'domain_handling\'')</l>
<l>endif</l>
<c>* </c>
<c>* Generate smallest enclosing axis-aligned bounding box for classes in ClassIDsNoOrientation.</c>
<l>ClassIDsNoOrientationIndices := []</l>
<l>for Index := 0 to |ClassIDsNoOrientation| - 1 by 1</l>
<l>    ClassIDsNoOrientationIndicesTmp := find(BBoxLabelNew [==] ClassIDsNoOrientation[Index],1)</l>
<l>    if (ClassIDsNoOrientationIndicesTmp != -1)</l>
<l>        ClassIDsNoOrientationIndices := [ClassIDsNoOrientationIndices,ClassIDsNoOrientationIndicesTmp]</l>
<l>    endif</l>
<l>endfor</l>
<l>if (|ClassIDsNoOrientationIndices| &gt; 0)</l>
<c>    * Calculate length1 and length2 using position of corners.</c>
<l>    DirectionLength1Row := -sin(BBoxPhiNew[ClassIDsNoOrientationIndices])</l>
<l>    DirectionLength1Col := cos(BBoxPhiNew[ClassIDsNoOrientationIndices])</l>
<l>    DirectionLength2Row := -DirectionLength1Col</l>
<l>    DirectionLength2Col := DirectionLength1Row</l>
<l>    Corner1Row := BBoxLength1New[ClassIDsNoOrientationIndices] * DirectionLength1Row + BBoxLength2New[ClassIDsNoOrientationIndices] * DirectionLength2Row</l>
<l>    Corner1Col := BBoxLength1New[ClassIDsNoOrientationIndices] * DirectionLength1Col + BBoxLength2New[ClassIDsNoOrientationIndices] * DirectionLength2Col</l>
<l>    Corner2Row := BBoxLength1New[ClassIDsNoOrientationIndices] * DirectionLength1Row - BBoxLength2New[ClassIDsNoOrientationIndices] * DirectionLength2Row</l>
<l>    Corner2Col := BBoxLength1New[ClassIDsNoOrientationIndices] * DirectionLength1Col - BBoxLength2New[ClassIDsNoOrientationIndices] * DirectionLength2Col</l>
<c>    * </c>
<l>    BBoxPhiNew[ClassIDsNoOrientationIndices] := 0.0</l>
<l>    BBoxLength1New[ClassIDsNoOrientationIndices] := max2(abs(Corner1Col),abs(Corner2Col))</l>
<l>    BBoxLength2New[ClassIDsNoOrientationIndices] := max2(abs(Corner1Row),abs(Corner2Row))</l>
<l>endif</l>
<c>* </c>
<c>* Rescale bounding boxes.</c>
<c>* </c>
<c>* Get required images width and height.</c>
<c>* </c>
<c>* Only rescale bounding boxes if the required image dimensions are not the raw dimensions.</c>
<l>if (ImageHeight != HeightRaw or ImageWidth != WidthRaw)</l>
<c>    * Calculate rescaling factor.</c>
<l>    FactorResampleWidth := real(ImageWidth) / WidthRaw</l>
<l>    FactorResampleHeight := real(ImageHeight) / HeightRaw</l>
<l>    if (FactorResampleHeight != FactorResampleWidth and |BBoxRowNew| &gt; 0)</l>
<c>        * In order to preserve the correct orientation we have to transform the points individually.</c>
<c>        * Get the coordinates of the four corner points.</c>
<l>        convert_rect2_5to8param (BBoxRowNew, BBoxColNew, BBoxLength1New, BBoxLength2New, BBoxPhiNew, BBoxRow1, BBoxCol1, BBoxRow2, BBoxCol2, BBoxRow3, BBoxCol3, BBoxRow4, BBoxCol4)</l>
<c>        * </c>
<c>        * Rescale the coordinates.</c>
<l>        BBoxCol1New := BBoxCol1 * FactorResampleWidth</l>
<l>        BBoxCol2New := BBoxCol2 * FactorResampleWidth</l>
<l>        BBoxCol3New := BBoxCol3 * FactorResampleWidth</l>
<l>        BBoxCol4New := BBoxCol4 * FactorResampleWidth</l>
<l>        BBoxRow1New := BBoxRow1 * FactorResampleHeight</l>
<l>        BBoxRow2New := BBoxRow2 * FactorResampleHeight</l>
<l>        BBoxRow3New := BBoxRow3 * FactorResampleHeight</l>
<l>        BBoxRow4New := BBoxRow4 * FactorResampleHeight</l>
<c>        * </c>
<c>        * The rectangles will get sheared, that is why new rectangles have to be found.</c>
<c>        * Generate homography to scale rectangles.</c>
<l>        hom_mat2d_identity (HomMat2DIdentity)</l>
<l>        hom_mat2d_scale (HomMat2DIdentity, FactorResampleHeight, FactorResampleWidth, 0, 0, HomMat2DScale)</l>
<c>        * Generate XLD contours for the rectangles.</c>
<l>        gen_rectangle2_contour_xld (Rectangle2XLD, BBoxRowNew, BBoxColNew, BBoxPhiNew, BBoxLength1New, BBoxLength2New)</l>
<c>        * Scale the XLD contours --&gt; results in sheared regions.</c>
<l>        affine_trans_contour_xld (Rectangle2XLD, Rectangle2XLDSheared, HomMat2DScale)</l>
<l>        smallest_rectangle2_xld (Rectangle2XLDSheared, BBoxRowNew, BBoxColNew, BBoxPhiNew, BBoxLength1New, BBoxLength2New)</l>
<c>        * </c>
<c>        * smallest_rectangle2_xld might change the orientation of the bounding box.</c>
<c>        * Hence, take the orientation that is closest to the one obtained out of the 4 corner points.</c>
<l>        convert_rect2_8to5param (BBoxRow1New, BBoxCol1New, BBoxRow2New, BBoxCol2New, BBoxRow3New, BBoxCol3New, BBoxRow4New, BBoxCol4New, IgnoreDirection, _, _, _, _, BBoxPhiTmp)</l>
<l>        PhiDelta := fmod(BBoxPhiTmp - BBoxPhiNew,rad(360))</l>
<c>        * Guarantee that angles are positive.</c>
<l>        PhiDeltaNegativeIndices := find(PhiDelta [&lt;] 0.0,1)</l>
<l>        if (PhiDeltaNegativeIndices != -1)</l>
<l>            PhiDelta[PhiDeltaNegativeIndices] := PhiDelta[PhiDeltaNegativeIndices] + rad(360)</l>
<l>        endif</l>
<l>        IndicesRot90 := find((PhiDelta [&gt;] rad(45)) and (PhiDelta [&lt;=] rad(135)),1)</l>
<l>        IndicesRot180 := find((PhiDelta [&gt;] rad(135)) and (PhiDelta [&lt;=] rad(225)),1)</l>
<l>        IndicesRot270 := find((PhiDelta [&gt;] rad(225)) and (PhiDelta [&lt;=] rad(315)),1)</l>
<l>        SwapIndices := []</l>
<l>        if (IndicesRot90 != -1)</l>
<l>            BBoxPhiNew[IndicesRot90] := BBoxPhiNew[IndicesRot90] + rad(90)</l>
<l>            SwapIndices := [SwapIndices,IndicesRot90]</l>
<l>        endif</l>
<l>        if (IndicesRot180 != -1)</l>
<l>            BBoxPhiNew[IndicesRot180] := BBoxPhiNew[IndicesRot180] + rad(180)</l>
<l>        endif</l>
<l>        if (IndicesRot270 != -1)</l>
<l>            BBoxPhiNew[IndicesRot270] := BBoxPhiNew[IndicesRot270] + rad(270)</l>
<l>            SwapIndices := [SwapIndices,IndicesRot270]</l>
<l>        endif</l>
<l>        if (SwapIndices != [])</l>
<l>            Tmp := BBoxLength1New[SwapIndices]</l>
<l>            BBoxLength1New[SwapIndices] := BBoxLength2New[SwapIndices]</l>
<l>            BBoxLength2New[SwapIndices] := Tmp</l>
<l>        endif</l>
<c>        * Change angles such that they lie in the range (-180°, 180°].</c>
<l>        BBoxPhiNewIndices := find(BBoxPhiNew [&gt;] rad(180),1)</l>
<l>        if (BBoxPhiNewIndices != -1)</l>
<l>            BBoxPhiNew[BBoxPhiNewIndices] := BBoxPhiNew[BBoxPhiNewIndices] - rad(360)</l>
<l>        endif</l>
<c>        * </c>
<l>    else</l>
<l>        BBoxColNew := BBoxColNew * FactorResampleWidth</l>
<l>        BBoxRowNew := BBoxRowNew * FactorResampleWidth</l>
<l>        BBoxLength1New := BBoxLength1New * FactorResampleWidth</l>
<l>        BBoxLength2New := BBoxLength2New * FactorResampleWidth</l>
<c>        * Phi stays the same.</c>
<l>    endif</l>
<c>    * </c>
<l>endif</l>
<c>* </c>
<c>* Adapt the bounding box angles such that they are within the correct range,</c>
<c>* which is (-180°,180°] for 'ignore_direction'==false and (-90°,90°] else.</c>
<l>PhiThreshold := rad(180) - IgnoreDirection * rad(90)</l>
<l>PhiDelta := 2 * PhiThreshold</l>
<c>* Correct angles that are too large.</c>
<l>PhiToCorrect := find(BBoxPhiNew [&gt;] PhiThreshold,1)</l>
<l>if (PhiToCorrect != -1 and PhiToCorrect != [])</l>
<l>    NumCorrections := int((BBoxPhiNew[PhiToCorrect] - PhiThreshold) / PhiDelta) + 1</l>
<l>    BBoxPhiNew[PhiToCorrect] := BBoxPhiNew[PhiToCorrect] - NumCorrections * PhiDelta</l>
<l>endif</l>
<c>* Correct angles that are too small.</c>
<l>PhiToCorrect := find(BBoxPhiNew [&lt;=] -PhiThreshold,1)</l>
<l>if (PhiToCorrect != -1 and PhiToCorrect != [])</l>
<l>    NumCorrections := int(abs(BBoxPhiNew[PhiToCorrect] + PhiThreshold) / PhiDelta) + 1</l>
<l>    BBoxPhiNew[PhiToCorrect] := BBoxPhiNew[PhiToCorrect] + NumCorrections * PhiDelta</l>
<l>endif</l>
<c>* </c>
<c>* Check that there are no invalid boxes.</c>
<l>if (|BBoxRowNew| &gt; 0)</l>
<l>    BoxesInvalid := sum(BBoxLength1New [==] 0) + sum(BBoxLength2New [==] 0)</l>
<l>    if (BoxesInvalid &gt; 0)</l>
<l>        get_dict_tuple (DLSample, 'image_id', ImageId)</l>
<l>        throw ('An error has occurred during preprocessing image_id ' + ImageId + ': Sample contains at least one box with zero-area, i.e. bbox_length1 == 0 or bbox_length2 == 0!')</l>
<l>    endif</l>
<l>endif</l>
<l>set_dict_tuple (DLSample, 'bbox_row', BBoxRowNew)</l>
<l>set_dict_tuple (DLSample, 'bbox_col', BBoxColNew)</l>
<l>set_dict_tuple (DLSample, 'bbox_length1', BBoxLength1New)</l>
<l>set_dict_tuple (DLSample, 'bbox_length2', BBoxLength2New)</l>
<l>set_dict_tuple (DLSample, 'bbox_phi', BBoxPhiNew)</l>
<l>set_dict_tuple (DLSample, 'bbox_label_id', BBoxLabelNew)</l>
<c>* </c>
<l>return ()</l>
<c></c>
</body>
<docu id="preprocess_dl_model_bbox_rect2">
<abstract lang="en_US">This procedure preprocesses the bounding boxes of type 'rectangle2' for a sample given by the dictionary DLSample.
In particular the bounding boxes are rescaled according to the rescaling of the images to the size required by the deep learning model.
All required parameters are provided through the dictionary DLPreprocessParam.

The dictionary DLPreprocessParam can be created using e.g., &lt;proc:create_dl_preprocess_param&gt; or &lt;proc:create_dl_preprocess_param_from_model&gt;.
For information to the preprocessing parameters, see the documentation of &lt;proc:preprocess_dl_samples&gt;.

Note: If the width and height are not rescaled by the same factor, rescaling the bounding boxes will usually result in a shearing.
In such a case the preprocessed rectangular bounding boxes will border a slightly different image area.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Objektdetektion und Instanz-Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection and Instance Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess the bounding boxes of type 'rectangle2' for a given sample.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<default_value>DLSample</default_value>
<description lang="en_US">Dictionary of the sample related to ImageRaw and containing the bounding boxes appertain.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageRaw">
<description lang="en_US">Raw, not preprocessed image.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_instance_masks" access="local">
<interface>
<io>
<par name="ImageRaw" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure preprocesses the instance masks of a DLSample.</c>
<c>* </c>
<c>* Check preprocess parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* Get relevant preprocess parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<c>* </c>
<c>* Get the preprocessed instance masks.</c>
<l>get_dict_object (InstanceMasks, DLSample, 'mask')</l>
<c>* </c>
<c>* Get the number of instance masks.</c>
<l>count_obj (InstanceMasks, NumMasks)</l>
<c>* </c>
<c>* Domain handling of the image to be preprocessed.</c>
<c>* </c>
<l>get_image_size (ImageRaw, WidthRaw, HeightRaw)</l>
<l>if (DomainHandling == 'crop_domain')</l>
<c>    * Clip and translate masks w.r.t. the image domain</c>
<l>    get_domain (ImageRaw, Domain)</l>
<l>    smallest_rectangle1 (Domain, DomainRow1, DomainColumn1, DomainRow2, DomainColumn2)</l>
<c>    * </c>
<c>    * Clip the remaining regions to the domain.</c>
<l>    clip_region (InstanceMasks, InstanceMasks, DomainRow1, DomainColumn1, DomainRow2, DomainColumn2)</l>
<l>    WidthRaw := DomainColumn2 - DomainColumn1 + 1.0</l>
<l>    HeightRaw := DomainRow2 - DomainRow1 + 1.0</l>
<c>    * We need to move the remaining regions back to the origin,</c>
<c>    * because crop_domain will be applied to the image</c>
<l>    move_region (InstanceMasks, InstanceMasks, -DomainRow1, -DomainColumn1)</l>
<l>elseif (DomainHandling != 'full_domain')</l>
<l>    throw ('Unsupported parameter value for \'domain_handling\'')</l>
<l>endif</l>
<c>* </c>
<c>* Zoom masks only if the image has a different size than the specified size.</c>
<l>if (ImageWidth [!=] WidthRaw or ImageHeight [!=] HeightRaw)</l>
<c>    * Calculate rescaling factor.</c>
<l>    FactorResampleWidth := real(ImageWidth) / WidthRaw</l>
<l>    FactorResampleHeight := real(ImageHeight) / HeightRaw</l>
<c></c>
<c>    * Zoom the masks.</c>
<l>    zoom_region (InstanceMasks, InstanceMasks, FactorResampleWidth, FactorResampleHeight)</l>
<l>endif</l>
<c>* </c>
<c>* Set the preprocessed instance masks.</c>
<l>set_dict_object (InstanceMasks, DLSample, 'mask')</l>
<c>* </c>
<c>* </c>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_instance_masks">
<abstract lang="en_US">This procedure preprocesses the instance segmentation masks for a sample given by the dictionary DLSample.
In particular the masks are rescaled according to the rescaling of the images to the size required by the deep learning model.
All required parameters are provided through the dictionary DLPreprocessParam.

The dictionary DLPreprocessParam can be created using e.g., &lt;proc:create_dl_preprocess_param&gt; or &lt;proc:create_dl_preprocess_param_from_model&gt;.
For information to the preprocessing parameters, see the documentation of &lt;proc:preprocess_dl_samples&gt;.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Objektdetektion und Instanz-Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection and Instance Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess the instance segmentation masks for a sample given by the dictionary DLSample.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary of preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<description lang="en_US">Dictionary of the sample related to ImageRaw and containing bounding box coordinates and optionally instance masks.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageRaw">
<description lang="en_US">Raw image.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_segmentations">
<interface>
<io>
<par name="ImagesRaw" base_type="iconic" dimension="0"/>
<par name="Segmentations" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SegmentationsPreprocessed" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure preprocesses the segmentation or weight images</c>
<c>* given by Segmentations so that they can be handled by</c>
<c>* train_dl_model_batch and apply_dl_model.</c>
<c>* </c>
<c>* Check input data.</c>
<c>* Examine number of images.</c>
<l>count_obj (ImagesRaw, NumberImages)</l>
<l>count_obj (Segmentations, NumberSegmentations)</l>
<l>if (NumberImages != NumberSegmentations)</l>
<l>    throw ('Equal number of images given in ImagesRaw and Segmentations required')</l>
<l>endif</l>
<c>* Size of images.</c>
<l>get_image_size (ImagesRaw, Width, Height)</l>
<l>get_image_size (Segmentations, WidthSeg, HeightSeg)</l>
<l>if (Width != WidthSeg or Height != HeightSeg)</l>
<l>    throw ('Equal size of the images given in ImagesRaw and Segmentations required.')</l>
<l>endif</l>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* Get the relevant preprocessing parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'model_type', DLModelType)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_num_channels', ImageNumChannels)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)</l>
<l>get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<c>* Segmentation specific parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'set_background_id', SetBackgroundID)</l>
<l>get_dict_tuple (DLPreprocessParam, 'class_ids_background', ClassesToBackground)</l>
<l>get_dict_tuple (DLPreprocessParam, 'ignore_class_ids', IgnoreClassIDs)</l>
<c>* </c>
<c>* Check the input parameter for setting the background ID.</c>
<l>if (SetBackgroundID != [])</l>
<c>    * Check that the model is a segmentation model.</c>
<l>    if (DLModelType != 'segmentation')</l>
<l>        throw ('Setting class IDs to background is only implemented for segmentation.')</l>
<l>    endif</l>
<c>    * Check the background ID.</c>
<l>    tuple_is_int_elem (SetBackgroundID, IsInt)</l>
<l>    if (|SetBackgroundID| != 1)</l>
<l>        throw ('Only one class_id as \'set_background_id\' allowed.')</l>
<l>    elseif (not IsInt)</l>
<c>        * Given class_id has to be of type int.</c>
<l>        throw ('The class_id given as \'set_background_id\' has to be of type int.')</l>
<l>    endif</l>
<c>    * Check the values of ClassesToBackground.</c>
<l>    if (|ClassesToBackground| == 0)</l>
<c>        * Check that the given classes are of length &gt; 0.</c>
<l>        throw ('If \'set_background_id\' is given, \'class_ids_background\' must at least contain this class ID.')</l>
<l>    elseif (intersection(ClassesToBackground,IgnoreClassIDs) != [])</l>
<c>        * Check that class_ids_background is not included in the ignore_class_ids of the DLModel.</c>
<l>        throw ('The given \'class_ids_background\' must not be included in the \'ignore_class_ids\' of the model.')</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Domain handling of the image to be preprocessed.</c>
<c>* </c>
<l>if (DomainHandling == 'full_domain')</l>
<l>    full_domain (Segmentations, Segmentations)</l>
<l>elseif (DomainHandling == 'crop_domain')</l>
<c>    * If the domain should be cropped the domain has to be transferred</c>
<c>    * from the raw image to the segmentation image.</c>
<l>    get_domain (ImagesRaw, Domain)</l>
<l>    for IndexImage := 1 to NumberImages by 1</l>
<l>        select_obj (Segmentations, SelectedSeg, IndexImage)</l>
<l>        select_obj (Domain, SelectedDomain, IndexImage)</l>
<l>        change_domain (SelectedSeg, SelectedDomain, SelectedSeg)</l>
<l>        replace_obj (Segmentations, SelectedSeg, Segmentations, IndexImage)</l>
<l>    endfor</l>
<l>    crop_domain (Segmentations, Segmentations)</l>
<l>else</l>
<l>    throw ('Unsupported parameter value for \'domain_handling\'')</l>
<l>endif</l>
<c>* </c>
<c>* Preprocess the segmentation images.</c>
<c>* </c>
<c>* Set all background classes to the given background class ID.</c>
<l>if (SetBackgroundID != [])</l>
<l>    reassign_pixel_values (Segmentations, Segmentations, ClassesToBackground, SetBackgroundID)</l>
<l>endif</l>
<c>* </c>
<c>* Zoom images only if they have a different size than the specified size.</c>
<l>get_image_size (Segmentations, ImageWidthRaw, ImageHeightRaw)</l>
<l>EqualWidth := ImageWidth [==] ImageWidthRaw</l>
<l>EqualHeight := ImageHeight [==] ImageHeightRaw</l>
<l>if (min(EqualWidth) == 0 or min(EqualHeight) == 0)</l>
<l>    zoom_image_size (Segmentations, Segmentations, ImageWidth, ImageHeight, 'nearest_neighbor')</l>
<l>endif</l>
<c>* </c>
<c>* Check the type of the input images</c>
<c>* and convert if necessary.</c>
<l>get_image_type (Segmentations, Type)</l>
<l>EqualReal := Type [==] 'real'</l>
<c>* </c>
<l>if (min(EqualReal) == 0)</l>
<c>    * Convert the image type to 'real',</c>
<c>    * because the model expects 'real' images.</c>
<l>    convert_image_type (Segmentations, Segmentations, 'real')</l>
<l>endif</l>
<c>* </c>
<c>* Write preprocessed Segmentations to output variable.</c>
<l>SegmentationsPreprocessed := Segmentations</l>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_segmentations">
<abstract lang="en_US">This procedure preprocesses the segmentation or weight images given by Segmentations so that they can be handled by &lt;op:train_dl_model_batch&gt; and &lt;op:apply_dl_model&gt;.

The dictionary DLPreprocessParam specifies the properties the images need for a successful model application. Next to the dimensions, also the image type is set (to 'real').
The preprocessed images are returned in SegmentationsPreprocessed.

The dictionary DLPreprocessParam can be created using e.g., &lt;proc:create_dl_preprocess_param&gt; or &lt;proc:create_dl_preprocess_param_from_model&gt;.
For further information on the parameters to be set in DLPreprocessParam, see the documentation of &lt;proc:preprocess_dl_samples&gt;.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Semantische Segmentierung und Kantenextraktion</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Semantic Segmentation and Edge Extraction</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess segmentation and weight images for deep-learning-based segmentation training and inference.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagesRaw">
<description lang="en_US">Raw, not preprocessed images.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Segmentations">
<description lang="en_US">Segmentation or weight images to be preprocessed.</description>
<multichannel>false</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int2</item>
<item>uint2</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="SegmentationsPreprocessed">
<description lang="en_US">Preprocessed segmentation or weight images.</description>
<multichannel>false</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="crop_dl_sample_image" access="local">
<interface>
<io>
<par name="Domain" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="Key" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>get_dict_param (DLSample, 'key_exists', Key, KeyExists)</l>
<l>if (KeyExists)</l>
<l>    if (DLPreprocessParam.domain_handling == 'crop_domain')</l>
<l>        smallest_rectangle1 (Domain, Row1, Column1, Row2, Column2)</l>
<l>        crop_part (DLSample.[Key], DLSample.[Key], Row1, Column1, Column2 - Column1 + 1, Row2 - Row1 + 1)</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="crop_dl_sample_image">
<abstract lang="en_US">Crops a given image object DLSample.[Key] based on the 'domain_handling' setting in the DLPreprocessingParams dictionary.

The given input Domain should be the domain of the DLSample.image in the same coordinate system as the DLSample.[Key] (not preprocessed).

If the given Key does not exist in DLSample this procedure will return without a side effect or error.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Internal Procedures</library>
<short lang="en_US">Crops a given image object based on the given domain handling.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<description lang="en_US">Input dictionary.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Domain">
<description lang="en_US">Domain of the input image that is not yet preprocessed.</description>
<multivalue>false</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="Key">
<default_type>string</default_type>
<description lang="en_US">Key of image object in DLSample to be cropped.</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_3d_data">
<interface>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure preprocesses 3D data of a DLSample.</c>
<c>* </c>
<c>* Check presence of inputs in DLSample.</c>
<c>* </c>
<l>get_dict_param (DLSample, 'key_exists', 'normals', HasNormals)</l>
<l>XYZKeys := ['x', 'y', 'z']</l>
<l>get_dict_param (DLSample, 'key_exists', XYZKeys, HasXYZ)</l>
<l>HasX := HasXYZ[0]</l>
<l>HasY := HasXYZ[1]</l>
<l>HasZ := HasXYZ[2]</l>
<l>tuple_min (HasXYZ, HasFullXYZ)</l>
<l>if (not HasNormals)</l>
<c>    * XYZ are required because normals would need to be computed.</c>
<l>    if (not HasFullXYZ)</l>
<l>        throw ('The given input DLSample does not contain necessary images \'x\',\'y\' and \'z\'. This is required if no normals are provided.')</l>
<l>    endif</l>
<l>else</l>
<c>    * At least Z is required if normals are given.</c>
<l>    if (not HasZ)</l>
<l>        throw ('The given input DLSample does not contain at least the depth image \'z\'. This is required because normals are provided. Optionally, \'x\' and \'y\' images might be provided additionally.')</l>
<l>    endif</l>
<l>    count_channels (DLSample.normals, NumChannels)</l>
<l>    if (NumChannels != 3)</l>
<l>        throw ('The given input DLSample.normals has to have three channels.')</l>
<l>    endif</l>
<l>    get_image_type (DLSample.normals, Type)</l>
<l>    if (Type != 'real')</l>
<l>        throw ('The given input DLSample.normals is not a real image.')</l>
<l>    endif</l>
<l>endif</l>
<l>for Index := 0 to |HasXYZ| - 1 by 1</l>
<l>    if (HasXYZ[Index])</l>
<l>        Key := XYZKeys[Index]</l>
<l>        count_channels (DLSample.[Key], NumChannels)</l>
<l>        if (NumChannels != 1)</l>
<l>            throw ('The given input DLSample.' + Key + ' needs to have a single channel.')</l>
<l>        endif</l>
<l>        get_image_type (DLSample.[Key], Type)</l>
<l>        if (Type != 'real')</l>
<l>            throw ('The given input DLSample.' + Key + ' is not a real image.')</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>ImageZ := DLSample.z</l>
<l>get_domain (ImageZ, Domain)</l>
<c>* Reduce Z domain to user-defined min/max values for Z.</c>
<l>get_dict_param (DLPreprocessParam, 'key_exists', ['min_z', 'max_z'], ZMinMaxExist)</l>
<l>if (ZMinMaxExist[0])</l>
<l>    threshold (ImageZ, Region, 'min', DLPreprocessParam.min_z)</l>
<l>    difference (Domain, Region, Domain)</l>
<l>endif</l>
<l>if (ZMinMaxExist[1])</l>
<l>    threshold (ImageZ, Region, DLPreprocessParam.max_z, 'max')</l>
<l>    difference (Domain, Region, Domain)</l>
<l>endif</l>
<c>* Reduce domain because it might have changed</c>
<l>if (max(ZMinMaxExist))</l>
<l>    reduce_domain (ImageZ, Domain, ImageReduced)</l>
<l>endif</l>
<l>complement (Domain, DomainComplement)</l>
<c>* </c>
<c>* Before we zoom any 3D images we want to set all pixels outside of the domain to</c>
<c>* an invalid value.</c>
<l>GrayvalOutsideInit := 0</l>
<c></c>
<l>if (HasFullXYZ)</l>
<l>    ImageX := DLSample.x</l>
<l>    ImageY := DLSample.y</l>
<l>    ImageZ := DLSample.z</l>
<c></c>
<l>    full_domain (ImageX, ImageX)</l>
<l>    full_domain (ImageY, ImageY)</l>
<l>    full_domain (ImageZ, ImageZ)</l>
<c></c>
<l>    overpaint_region (ImageX, DomainComplement, GrayvalOutsideInit, 'fill')</l>
<l>    overpaint_region (ImageY, DomainComplement, GrayvalOutsideInit, 'fill')</l>
<l>    overpaint_region (ImageZ, DomainComplement, GrayvalOutsideInit, 'fill')</l>
<c></c>
<l>    reduce_domain (ImageX, Domain, ImageX)</l>
<l>    reduce_domain (ImageY, Domain, ImageY)</l>
<l>    reduce_domain (ImageZ, Domain, ImageZ)</l>
<c></c>
<l>    if (not HasNormals)</l>
<c>        * Get optional user-defined resolution of normal computation.</c>
<l>        get_dict_param (DLPreprocessParam, 'key_exists', ['normal_image_width', 'normal_image_height'], NormalSizeExists)</l>
<l>        if (not NormalSizeExists[0])</l>
<l>            NormalWidth := int(DLPreprocessParam.image_width * 1.5)</l>
<l>        else</l>
<l>            NormalWidth := DLPreprocessParam.normal_image_width</l>
<l>        endif</l>
<l>        if (not NormalSizeExists[1])</l>
<l>            NormalHeight := int(DLPreprocessParam.image_height * 1.5)</l>
<l>        else</l>
<l>            NormalHeight := DLPreprocessParam.normal_image_height</l>
<l>        endif</l>
<c></c>
<l>        get_image_size (ImageZ, WidthZ, HeightZ)</l>
<l>        ZoomNormals := NormalWidth != WidthZ or NormalHeight != HeightZ</l>
<c></c>
<l>        if (ZoomNormals)</l>
<l>            compose3 (ImageX, ImageY, ImageZ, ImageXYZ)</l>
<l>            get_image_size (ImageXYZ, Width, Height)</l>
<l>            zoom_image_size (ImageXYZ, ImageXYZ, NormalWidth, NormalHeight, 'nearest_neighbor')</l>
<l>            access_channel (ImageXYZ, ImageX, 1)</l>
<l>            access_channel (ImageXYZ, ImageY, 2)</l>
<l>            access_channel (ImageXYZ, ImageZ, 3)</l>
<l>            ScaleWidth := NormalWidth / real(Width)</l>
<l>            ScaleHeight := NormalHeight / real(Height)</l>
<l>            zoom_region (Domain, Domain, ScaleWidth, ScaleHeight)</l>
<l>            remove_invalid_3d_pixels (ImageX, ImageY, ImageZ, Domain, Domain, GrayvalOutsideInit)</l>
<l>            complement (Domain, DomainComplement)</l>
<l>        endif</l>
<c></c>
<l>        compute_normals_xyz (ImageX, ImageY, ImageZ, NXImage, NYImage, NZImage, true)</l>
<l>    else</l>
<l>        access_channel (DLSample.normals, NXImage, 1)</l>
<l>        access_channel (DLSample.normals, NYImage, 2)</l>
<l>        access_channel (DLSample.normals, NZImage, 3)</l>
<l>    endif</l>
<l>else</l>
<l>    gen_empty_obj (ImageX)</l>
<l>    gen_empty_obj (ImageY)</l>
<c></c>
<l>    access_channel (DLSample.normals, NXImage, 1)</l>
<l>    access_channel (DLSample.normals, NYImage, 2)</l>
<l>    access_channel (DLSample.normals, NZImage, 3)</l>
<l>endif</l>
<c></c>
<l>full_domain (ImageZ, ImageZ)</l>
<c></c>
<l>full_domain (NXImage, NXImage)</l>
<l>full_domain (NYImage, NYImage)</l>
<l>full_domain (NZImage, NZImage)</l>
<c></c>
<c>* full_domain does not change the pixels outside of the existing domain.</c>
<c>* Hence we have to set a specific value</c>
<l>overpaint_region (NXImage, DomainComplement, GrayvalOutsideInit, 'fill')</l>
<l>overpaint_region (NYImage, DomainComplement, GrayvalOutsideInit, 'fill')</l>
<l>overpaint_region (NZImage, DomainComplement, GrayvalOutsideInit, 'fill')</l>
<l>overpaint_region (ImageZ, DomainComplement, GrayvalOutsideInit, 'fill')</l>
<c></c>
<l>compose4 (NXImage, NYImage, NZImage, ImageZ, MultiChannelImage)</l>
<c></c>
<l>count_obj (ImageX, HasX)</l>
<l>if (HasX)</l>
<l>    full_domain (ImageX, ImageX)</l>
<l>    append_channel (MultiChannelImage, ImageX, MultiChannelImage)</l>
<l>    count_channels (MultiChannelImage, XIndex)</l>
<l>endif</l>
<l>count_obj (ImageY, HasY)</l>
<l>if (HasY)</l>
<l>    full_domain (ImageY, ImageY)</l>
<l>    append_channel (MultiChannelImage, ImageY, MultiChannelImage)</l>
<l>    count_channels (MultiChannelImage, YIndex)</l>
<l>endif</l>
<l>get_image_size (MultiChannelImage, Width, Height)</l>
<l>zoom_image_size (MultiChannelImage, MultiChannelImage, DLPreprocessParam.image_width, DLPreprocessParam.image_height, 'nearest_neighbor')</l>
<c></c>
<l>decompose4 (MultiChannelImage, NXImage, NYImage, NZImage, ImageZ)</l>
<l>if (HasX)</l>
<l>    access_channel (MultiChannelImage, ImageX, XIndex)</l>
<l>endif</l>
<l>if (HasY)</l>
<l>    access_channel (MultiChannelImage, ImageY, YIndex)</l>
<l>endif</l>
<c></c>
<c></c>
<c>* Zoom the domain</c>
<l>ScaleWidth := DLPreprocessParam.image_width / real(Width)</l>
<l>ScaleHeight := DLPreprocessParam.image_height / real(Height)</l>
<l>zoom_region (Domain, Domain, ScaleWidth, ScaleHeight)</l>
<l>remove_invalid_3d_pixels (NXImage, NYImage, NZImage, Domain, Domain, GrayvalOutsideInit)</l>
<c></c>
<l>reduce_domain (ImageX, Domain, ImageX)</l>
<l>reduce_domain (ImageY, Domain, ImageY)</l>
<l>reduce_domain (ImageZ, Domain, ImageZ)</l>
<l>compose3 (NXImage, NYImage, NZImage, DLSample.normals)</l>
<l>reduce_domain (DLSample.normals, Domain, DLSample.normals)</l>
<c></c>
<c>* Overwrite preprocessed 3D data</c>
<l>if (HasX)</l>
<l>    DLSample.x := ImageX</l>
<l>endif</l>
<l>if (HasY)</l>
<l>    DLSample.y := ImageY</l>
<l>endif</l>
<l>if (HasZ)</l>
<l>    DLSample.z := ImageZ</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_3d_data">
<abstract lang="en_US">This procedure preprocesses the provided 3D data according to the parameters in the dictionary DLPreprocessParam.

The preprocessing results overwrite the entries in the according sample dictionary DLSample.

The 3D data has to be provided in the input dictionary DLSample as separate single-channel images of type 'real'.

The following keys may be provided in DLSample:&lt;br/&gt;
- *'x'*: x-position of each pixel in camera coordinates (optional if the key *'normals'* is set in DLSample)&lt;br/&gt;
- *'y'*: y-position of each pixel in camera coordinates (optional if the key *'normals'* is set in DLSample)&lt;br/&gt;
- *'z'*: depth of each pixel in camera coordinates (required)&lt;br/&gt;
Each image has to have the same width and height.

The 3D data may have a domain specified. It is assumed that the domain of each input image is the same. During preprocessing the domain is preserved and each output image will have a domain that contains only valid pixels.

The following keys are optional in DLSample:&lt;br/&gt;
- *'normals'*: three-channel image of type 'real' containing the normals for each pixel.&lt;br/&gt;
- *'x'*, *'y'*: these keys are only optional if *'normals'* is given.&lt;br/&gt;
This procedure will compute normals if the key *'normals'* is not set in DLSample.
The computed normals will have the same resolution as the preprocessed images ('x','y','z').

It is optional to provide a resolution at which the normal-computation is done.
The DLPreprocessParam dictionary can have the following entries:&lt;br/&gt;
- *'normal_image_width'*: Width of normal computation (default: 1.5 * DLPreprocessParam.image_width).&lt;br/&gt;
- *'normal_image_height'*: Height of normal computation (default: 1.5 * DLPreprocessParam.image_height).&lt;br/&gt;
Note, that the runtime of the normal computation depends on those two parameters.

The dictionary DLPreprocessParam can be created using e.g., &lt;proc:create_dl_preprocess_param&gt; or &lt;proc:create_dl_preprocess_param_from_model&gt;.

The following keys of DLPreprocessParam might be used:&lt;br/&gt;
- *'image_width'*: Width of the preprocessed images.&lt;br/&gt;
- *'image_height'*: Height of the preprocessed images.&lt;br/&gt;
- *'min_z'* (optional): The domain of the input depth image DLSample.z is reduced to include only pixels greater or equal to the parameter value.
   *Default*: not set.
- *'max_z'* (optional): The domain of the input depth image DLSample.z is reduced to include only pixels less or equal to the parameter value.
   *Default*: not set.
- *'normal_image_width'* (optional): Width of normal computation.&lt;br/&gt;
- *'normal_image_height'* (optional): Height of normal computation.&lt;br/&gt;

Other keys in DLPreprocessParam are ignored.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess 3D data for deep-learning-based training and inference.</short>
<parameters>
<parameter id="DLPreprocessParam">
<description lang="en_US">Parameter dictionary.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<description lang="en_US">Input dictionary.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="update_window_meta_information" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WidthImage" base_type="ctrl" dimension="0"/>
<par name="HeightImage" base_type="ctrl" dimension="0"/>
<par name="WindowRow1" base_type="ctrl" dimension="0"/>
<par name="WindowColumn1" base_type="ctrl" dimension="0"/>
<par name="MapColorBarWidth" base_type="ctrl" dimension="0"/>
<par name="MarginBottom" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowImageRatioHeight" base_type="ctrl" dimension="0"/>
<par name="WindowImageRatioWidth" base_type="ctrl" dimension="0"/>
<par name="SetPartRow2" base_type="ctrl" dimension="0"/>
<par name="SetPartColumn2" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinatesOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure sets and returns meta information to display images correctly.</c>
<c>* </c>
<c>* Set part for the image to be displayed later and adapt window size (+ MarginBottom + MapColorBarWidth).</c>
<l>get_window_extents (WindowHandle, _, _, WindowWidth, WindowHeight)</l>
<l>WindowImageRatioHeight := WindowHeight / (HeightImage * 1.0)</l>
<l>WindowImageRatioWidth := WindowWidth / (WidthImage * 1.0)</l>
<c>* </c>
<c>* Set window part such that image is displayed undistorted.</c>
<l>WindowRow2 := WindowHeight</l>
<l>WindowColumn2 := WindowWidth</l>
<l>WindowRatio := WindowColumn2 / (WindowRow2 * 1.0)</l>
<c>* </c>
<l>ImageRow2 := HeightImage + MarginBottom / WindowImageRatioHeight</l>
<l>ImageColumn2 := WidthImage + MapColorBarWidth / WindowImageRatioWidth</l>
<l>ImageRatio := ImageColumn2 / (ImageRow2 * 1.0)</l>
<l>if (ImageRatio &gt; WindowRatio)</l>
<c>    * </c>
<c>    * Extend image until right window border.</c>
<l>    SetPartColumn2 := ImageColumn2</l>
<l>    ImageWindowRatioHeight := ImageColumn2 / (WindowColumn2 * 1.0)</l>
<l>    ImageRow2InWindow := ImageRow2 / ImageWindowRatioHeight</l>
<l>    SetPartRow2 := ImageRow2 + (WindowRow2 - ImageRow2InWindow) / WindowImageRatioWidth</l>
<l>else</l>
<c>    * </c>
<c>    * Extend image until bottom of window.</c>
<l>    SetPartRow2 := ImageRow2</l>
<l>    ImageWindowRatioHeight := ImageRow2 / (WindowRow2 * 1.0)</l>
<l>    ImageCol2InWindow := ImageColumn2 / ImageWindowRatioHeight</l>
<l>    SetPartColumn2 := ImageColumn2 + (WindowColumn2 - ImageCol2InWindow) / WindowImageRatioHeight</l>
<l>endif</l>
<l>dev_set_part (0, 0, SetPartRow2 - 1, SetPartColumn2 - 1)</l>
<c>* </c>
<c>* Return the coordinates of the new window.</c>
<l>PrevWindowCoordinatesOut := [WindowRow1,WindowColumn1,WindowWidth,WindowHeight]</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="update_window_meta_information">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Set and return meta information to display images correctly.</short>
<parameters>
<parameter id="HeightImage">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MapColorBarWidth">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MarginBottom"/>
<parameter id="PrevWindowCoordinatesOut">
<default_type>integer</default_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SetPartColumn2">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="SetPartRow2">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WidthImage">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowColumn1">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowImageRatioHeight">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowImageRatioWidth"/>
<parameter id="WindowRow1">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="open_next_window" access="local">
<interface>
<ic>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="FontSize" base_type="ctrl" dimension="0"/>
<par name="ShowBottomDesc" base_type="ctrl" dimension="0"/>
<par name="WidthImage" base_type="ctrl" dimension="0"/>
<par name="HeightImage" base_type="ctrl" dimension="0"/>
<par name="MapColorBarWidth" base_type="ctrl" dimension="0"/>
<par name="ScaleWindows" base_type="ctrl" dimension="0"/>
<par name="ThresholdWidth" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinates" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
<par name="WindowHandleKey" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandleNew" base_type="ctrl" dimension="0"/>
<par name="WindowImageRatioHeight" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinatesOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure opens a new window, either next to</c>
<c>* the last ones, or in a new row.</c>
<c>* </c>
<c>* Get coordinates of previous window.</c>
<l>PrevWindowRow := PrevWindowCoordinates[0]</l>
<l>PrevWindowColumn := PrevWindowCoordinates[1]</l>
<l>PrevWindowWidth := PrevWindowCoordinates[2]</l>
<l>PrevWindowHeight := PrevWindowCoordinates[3]</l>
<c>* </c>
<l>if (PrevWindowColumn + PrevWindowWidth &gt; ThresholdWidth)</l>
<c>    * Open window in new row.</c>
<l>    WindowRow := PrevWindowRow + PrevWindowHeight + 55</l>
<l>    WindowColumn := 0</l>
<l>else</l>
<c>    * Open window in same row.</c>
<l>    WindowRow := PrevWindowRow</l>
<l>    WindowColumn := PrevWindowColumn + PrevWindowWidth</l>
<l>    if (WindowColumn != 0)</l>
<l>        WindowColumn := WindowColumn + 5</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>dev_open_window_fit_size (WindowRow, WindowColumn, WidthImage, HeightImage, [500, 800] * ScaleWindows, [400, 600] * ScaleWindows, WindowHandleNew)</l>
<l>set_display_font (WindowHandleNew, FontSize, Font, 'true', 'false')</l>
<c>* </c>
<c>* Add MarginBottom and MapColorBarWidth to window.</c>
<l>if (ShowBottomDesc)</l>
<l>    get_string_extents (WindowHandleNew, 'Test_string', Ascent, Descent, _, _)</l>
<l>    NumLines := ShowBottomDesc</l>
<l>    MarginBottom := NumLines * (Ascent + Descent) + 2 * 12</l>
<l>else</l>
<l>    MarginBottom := 0</l>
<l>endif</l>
<l>get_window_extents (WindowHandleNew, _, _, WindowWidth, WindowHeight)</l>
<l>dev_set_window_extents (WindowRow, WindowColumn, WindowWidth + MapColorBarWidth, WindowHeight + MarginBottom)</l>
<c>* </c>
<c>* Get and set meta information of new window handle.</c>
<l>update_window_meta_information (WindowHandleNew, WidthImage, HeightImage, WindowRow, WindowColumn, MapColorBarWidth, MarginBottom, WindowImageRatioHeight, WindowImageRatioWidth, SetPartRow2, SetPartColumn2, PrevWindowCoordinatesOut)</l>
<c>* </c>
<c>* Set window handle and some meta information about the new window handle.</c>
<l>set_dict_tuple (WindowHandleDict, WindowHandleKey, WindowHandleNew)</l>
<l>get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_height', WindowImageRatioHeight)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_window_image_ratio_width', WindowImageRatioWidth)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_set_part_row2', SetPartRow2)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_set_part_column2', SetPartColumn2)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_margin_bottom', MarginBottom)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_map_color_bar_with', MapColorBarWidth)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_window_coordinates', PrevWindowCoordinatesOut)</l>
<l>set_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="open_next_window">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Open a new window, either next to the last ones, or in a new row.</short>
<parameters>
<parameter id="Font">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="FontSize">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="HeightImage">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="MapColorBarWidth">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinates">
<default_type>integer</default_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinatesOut">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ScaleWindows">
<default_type>real</default_type>
<default_value>1.0</default_value>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
<values>
<item>0.5</item>
<item>0.75</item>
</values>
</parameter>
<parameter id="ShowBottomDesc"/>
<parameter id="ThresholdWidth">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WidthImage">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>extent.x</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleKey">
<default_type>string</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandleNew">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowImageRatioHeight">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="scale_image_range">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageScaled" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Min" base_type="ctrl" dimension="0"/>
<par name="Max" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Convenience procedure to scale the gray values of the</c>
<c>* input image Image from the interval [Min,Max]</c>
<c>* to the interval [0,255] (default).</c>
<c>* Gray values &lt; 0 or &gt; 255 (after scaling) are clipped.</c>
<c>* </c>
<c>* If the image shall be scaled to an interval different from [0,255],</c>
<c>* this can be achieved by passing tuples with 2 values [From, To]</c>
<c>* as Min and Max.</c>
<c>* Example:</c>
<c>* scale_image_range(Image:ImageScaled:[100,50],[200,250])</c>
<c>* maps the gray values of Image from the interval [100,200] to [50,250].</c>
<c>* All other gray values will be clipped.</c>
<c>* </c>
<c>* input parameters:</c>
<c>* Image: the input image</c>
<c>* Min: the minimum gray value which will be mapped to 0</c>
<c>*      If a tuple with two values is given, the first value will</c>
<c>*      be mapped to the second value.</c>
<c>* Max: The maximum gray value which will be mapped to 255</c>
<c>*      If a tuple with two values is given, the first value will</c>
<c>*      be mapped to the second value.</c>
<c>* </c>
<c>* Output parameter:</c>
<c>* ImageScale: the resulting scaled image.</c>
<c>* </c>
<l>if (|Min| == 2)</l>
<l>    LowerLimit := Min[1]</l>
<l>    Min := Min[0]</l>
<l>else</l>
<l>    LowerLimit := 0.0</l>
<l>endif</l>
<l>if (|Max| == 2)</l>
<l>    UpperLimit := Max[1]</l>
<l>    Max := Max[0]</l>
<l>else</l>
<l>    UpperLimit := 255.0</l>
<l>endif</l>
<c>* </c>
<c>* Calculate scaling parameters.</c>
<c>* Only scale if the scaling range is not zero.</c>
<l>if (not (abs(Max - Min) &lt; 1.0E-6))</l>
<l>    Mult := real(UpperLimit - LowerLimit) / (Max - Min)</l>
<l>    Add := -Mult * Min + LowerLimit</l>
<c>    * Scale image.</c>
<l>    scale_image (Image, Image, Mult, Add)</l>
<l>endif</l>
<c>* </c>
<c>* Clip gray values if necessary.</c>
<c>* This must be done for each image and channel separately.</c>
<l>gen_empty_obj (ImageScaled)</l>
<l>count_obj (Image, NumImages)</l>
<l>for ImageIndex := 1 to NumImages by 1</l>
<l>    select_obj (Image, ImageSelected, ImageIndex)</l>
<l>    count_channels (ImageSelected, Channels)</l>
<l>    for ChannelIndex := 1 to Channels by 1</l>
<l>        access_channel (ImageSelected, SelectedChannel, ChannelIndex)</l>
<l>        min_max_gray (SelectedChannel, SelectedChannel, 0, MinGray, MaxGray, Range)</l>
<l>        threshold (SelectedChannel, LowerRegion, min([MinGray,LowerLimit]), LowerLimit)</l>
<l>        threshold (SelectedChannel, UpperRegion, UpperLimit, max([UpperLimit,MaxGray]))</l>
<l>        paint_region (LowerRegion, SelectedChannel, SelectedChannel, LowerLimit, 'fill')</l>
<l>        paint_region (UpperRegion, SelectedChannel, SelectedChannel, UpperLimit, 'fill')</l>
<l>        if (ChannelIndex == 1)</l>
<l>            copy_obj (SelectedChannel, ImageSelectedScaled, 1, 1)</l>
<l>        else</l>
<l>            append_channel (ImageSelectedScaled, SelectedChannel, ImageSelectedScaled)</l>
<l>        endif</l>
<l>    endfor</l>
<l>    concat_obj (ImageScaled, ImageSelectedScaled, ImageScaled)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="scale_image_range">
<abstract lang="en_US">Convenience procedure to scale the gray values of the input image Image from the interval [Min,Max] to the interval [*0*,*255*] (default).
Gray values &lt; *0* or &gt; *255* (after scaling) are clipped.
If the image shall be scaled to an interval different from [*0*,*255*], this can be achieved by passing tuples with 2 values [*From*, *To*] as Min and Max.

Example:

      scale_image_range (Image, ImageScaled, [100,50], [200,250])
maps the gray values of Image from the interval [*100*,*200*] to [*50*,*250*].
All other gray values will be clipped.</abstract>
<alternatives>
<item>scale_image</item>
<item>scale_image_max</item>
</alternatives>
<chapters lang="de_DE">
<item>Filter</item>
<item>Arithmetik</item>
</chapters>
<chapters lang="en_US">
<item>Filters</item>
<item>Arithmetic</item>
</chapters>
<example lang="en_US">read_image (Image, 'fabrik')
scale_image_range (Image, ImageScaled, [100,50], [200,250])</example>
<keywords lang="de_DE">
<item>Grauwerte skalieren</item>
</keywords>
<keywords lang="en_US">
<item>scale gray values</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>scale_image</item>
<item>scale_image_max</item>
</see_also>
<short>Scale the gray values of an image from the interval [Min,Max] to [0,255]</short>
<short lang="en_US">Scale the gray values of an image from the interval [Min,Max] to [0,255]</short>
<parameters>
<parameter id="Image">
<description lang="en_US">The input image to be scaled</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
</type_list>
</parameter>
<parameter id="ImageScaled">
<description lang="en_US">The scaled output image</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
</type_list>
</parameter>
<parameter id="Max">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The maximum gray value which will be mapped to 255. If a tuple with two values is given, the first value will be mapped to the second value.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Min">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The minimum gray value which will be mapped to 0. If a tuple with two values is given, the first value will be mapped to the second value.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="apply_colorscheme_on_gray_value_image">
<interface>
<io>
<par name="InputImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ResultImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Schema" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure generates an RGB ResultImage for a gray-value InputImage.</c>
<c>* In order to do so, create a color distribution as look up table</c>
<c>* according to the Schema.</c>
<c>* </c>
<l>X := [0:255]</l>
<l>tuple_gen_const (256, 0, Low)</l>
<l>tuple_gen_const (256, 255, High)</l>
<c>* </c>
<l>if (Schema == 'jet')</l>
<c>    * Scheme Jet: from blue to red</c>
<l>    OffR := 3.0 * 64.0</l>
<l>    OffG := 2.0 * 64.0</l>
<l>    OffB := 64.0</l>
<l>    A1 := -4.0</l>
<l>    A0 := 255.0 + 128.0</l>
<l>    R := min2(max2(abs(X - OffR) * A1 + A0,Low),High)</l>
<l>    G := min2(max2(abs(X - OffG) * A1 + A0,Low),High)</l>
<l>    B := min2(max2(abs(X - OffB) * A1 + A0,Low),High)</l>
<c>    * </c>
<l>elseif (Schema == 'inverse_jet')</l>
<c>    * Scheme InvJet: from red to blue.</c>
<l>    OffR := 64</l>
<l>    OffG := 2 * 64</l>
<l>    OffB := 3 * 64</l>
<l>    A1 := -4.0</l>
<l>    A0 := 255.0 + 128.0</l>
<l>    R := min2(max2(abs(X - OffR) * A1 + A0,Low),High)</l>
<l>    G := min2(max2(abs(X - OffG) * A1 + A0,Low),High)</l>
<l>    B := min2(max2(abs(X - OffB) * A1 + A0,Low),High)</l>
<c>    * </c>
<l>elseif (Schema == 'hot')</l>
<c>    * Scheme Hot.</c>
<l>    A1 := 3.0</l>
<l>    A0R := 0.0</l>
<l>    A0G := 1.0 / 3.0 * A1 * 255.0</l>
<l>    A0B := 2.0 / 3.0 * A1 * 255.0</l>
<l>    R := min2(max2(X * A1 - A0R,Low),High)</l>
<l>    G := min2(max2(X * A1 - A0G,Low),High)</l>
<l>    B := min2(max2(X * A1 - A0B,Low),High)</l>
<c>    * </c>
<l>elseif (Schema == 'inverse_hot')</l>
<c>    * Scheme Inverse Hot.</c>
<l>    A1 := -3.0</l>
<l>    A0R := A1 * 255.0</l>
<l>    A0G := 2.0 / 3.0 * A1 * 255.0</l>
<l>    A0B := 1.0 / 3.0 * A1 * 255.0</l>
<l>    R := min2(max2(X * A1 - A0R,Low),High)</l>
<l>    G := min2(max2(X * A1 - A0G,Low),High)</l>
<l>    B := min2(max2(X * A1 - A0B,Low),High)</l>
<c>    * </c>
<l>else</l>
<c>    * </c>
<l>    throw ('Unknown color schema: ' + Schema + '.')</l>
<c>    * </c>
<l>endif</l>
<c>* </c>
<l>lut_trans (InputImage, ImageR, R)</l>
<l>lut_trans (InputImage, ImageG, G)</l>
<l>lut_trans (InputImage, ImageB, B)</l>
<l>compose3 (ImageR, ImageG, ImageB, ResultImage)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="apply_colorscheme_on_gray_value_image">
<abstract lang="en_US">This procedure converts the pixel values of the gray-scale InputImage into a color image ResultImage.
In order to do so, a lookup table according to the specified Schema is created.

Note: The images are assumed to be byte images, thus having a range [0,255].</abstract>
<chapters lang="de_DE">
<item>Bild</item>
<item>Kanal</item>
</chapters>
<chapters lang="en_US">
<item>Image</item>
<item>Channel</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Create a lookup table and convert a gray scale image.</short>
<parameters>
<parameter id="InputImage">
<description lang="en_US">Byte image whose gray values are to be displayed in color.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="ResultImage">
<description lang="en_US">RGB image.</description>
<multichannel>true</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="Schema">
<description lang="en_US">Color scheme defining the created LUT.</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="open_child_window" access="local">
<interface>
<ic>
<par name="WindowHandleFather" base_type="ctrl" dimension="0"/>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="FontSize" base_type="ctrl" dimension="0"/>
<par name="Text" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinates" base_type="ctrl" dimension="0"/>
<par name="WindowHandleDict" base_type="ctrl" dimension="0"/>
<par name="WindowHandleKey" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandleChild" base_type="ctrl" dimension="0"/>
<par name="PrevWindowCoordinatesOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure opens a window next to the given WindowHandleFather.</c>
<c>* </c>
<c>* Get the maximum width of the text to be displayed.</c>
<c>* The width should be at least 200.</c>
<l>StringWidth := 150</l>
<l>for IndexText := 0 to |Text| - 1 by 1</l>
<l>    get_string_extents (WindowHandleFather, Text[IndexText], _, _, TextWidth, _)</l>
<l>    StringWidth := max2(StringWidth,TextWidth)</l>
<l>endfor</l>
<c>* </c>
<c>* Define window coordinates.</c>
<l>WindowRow := PrevWindowCoordinates[0]</l>
<l>WindowColumn := PrevWindowCoordinates[1] + PrevWindowCoordinates[2] + 5</l>
<l>WindowWidth := StringWidth + 2 * 12.0</l>
<l>WindowHeight := PrevWindowCoordinates[3]</l>
<c>* </c>
<l>dev_open_window (WindowRow, WindowColumn, WindowWidth, WindowHeight, 'black', WindowHandleChild)</l>
<l>set_display_font (WindowHandleChild, FontSize, Font, 'true', 'false')</l>
<c>* </c>
<c>* Return the coordinates of the new window.</c>
<l>PrevWindowCoordinatesOut := [WindowRow,WindowColumn,WindowWidth,WindowHeight]</l>
<c>* </c>
<c>* Set some meta information about the new child window handle.</c>
<l>get_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<l>set_dict_tuple (MetaInfo, WindowHandleKey + '_child_window_coordinates', PrevWindowCoordinatesOut)</l>
<l>set_dict_tuple (WindowHandleDict, 'meta_information', MetaInfo)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="open_child_window">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Open a window next to the given WindowHandleFather. </short>
<parameters>
<parameter id="Font">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="FontSize">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinates">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PrevWindowCoordinatesOut">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Text">
<default_type>string</default_type>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandleChild">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleDict">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleFather">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleKey">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_arrow_contour_xld">
<interface>
<oo>
<par name="Arrow" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="HeadLength" base_type="ctrl" dimension="0"/>
<par name="HeadWidth" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure generates arrow shaped XLD contours,</c>
<c>* pointing from (Row1, Column1) to (Row2, Column2).</c>
<c>* If starting and end point are identical, a contour consisting</c>
<c>* of a single point is returned.</c>
<c>* </c>
<c>* input parameters:</c>
<c>* Row1, Column1: Coordinates of the arrows' starting points</c>
<c>* Row2, Column2: Coordinates of the arrows' end points</c>
<c>* HeadLength, HeadWidth: Size of the arrow heads in pixels</c>
<c>* </c>
<c>* output parameter:</c>
<c>* Arrow: The resulting XLD contour</c>
<c>* </c>
<c>* The input tuples Row1, Column1, Row2, and Column2 have to be of</c>
<c>* the same length.</c>
<c>* HeadLength and HeadWidth either have to be of the same length as</c>
<c>* Row1, Column1, Row2, and Column2 or have to be a single element.</c>
<c>* If one of the above restrictions is violated, an error will occur.</c>
<c>* </c>
<c>* </c>
<c>* Initialization.</c>
<l>gen_empty_obj (Arrow)</l>
<c>* </c>
<c>* Calculate the arrow length</c>
<l>distance_pp (Row1, Column1, Row2, Column2, Length)</l>
<c>* </c>
<c>* Mark arrows with identical start and end point</c>
<c>* (set Length to -1 to avoid division-by-zero exception)</c>
<l>ZeroLengthIndices := find(Length,0)</l>
<l>if (ZeroLengthIndices != -1)</l>
<l>    Length[ZeroLengthIndices] := -1</l>
<l>endif</l>
<c>* </c>
<c>* Calculate auxiliary variables.</c>
<l>DR := 1.0 * (Row2 - Row1) / Length</l>
<l>DC := 1.0 * (Column2 - Column1) / Length</l>
<l>HalfHeadWidth := HeadWidth / 2.0</l>
<c>* </c>
<c>* Calculate end points of the arrow head.</c>
<l>RowP1 := Row1 + (Length - HeadLength) * DR + HalfHeadWidth * DC</l>
<l>ColP1 := Column1 + (Length - HeadLength) * DC - HalfHeadWidth * DR</l>
<l>RowP2 := Row1 + (Length - HeadLength) * DR - HalfHeadWidth * DC</l>
<l>ColP2 := Column1 + (Length - HeadLength) * DC + HalfHeadWidth * DR</l>
<c>* </c>
<c>* Finally create output XLD contour for each input point pair</c>
<l>for Index := 0 to |Length| - 1 by 1</l>
<l>    if (Length[Index] == -1)</l>
<c>        * Create_ single points for arrows with identical start and end point</c>
<l>        gen_contour_polygon_xld (TempArrow, Row1[Index], Column1[Index])</l>
<l>    else</l>
<c>        * Create arrow contour</c>
<l>        gen_contour_polygon_xld (TempArrow, [Row1[Index],Row2[Index],RowP1[Index],Row2[Index],RowP2[Index],Row2[Index]], [Column1[Index],Column2[Index],ColP1[Index],Column2[Index],ColP2[Index],Column2[Index]])</l>
<l>    endif</l>
<l>    concat_obj (Arrow, TempArrow, Arrow)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_arrow_contour_xld">
<abstract lang="en_US">This procedure creates arrow shaped XLD contours, which point from the coordinates (Row1, Column1) to the coordinates (Row2, Column2). The shape of the arrow head can be specified with the parameters HeadLength and HeadWidth (in pixels).

If starting and end point are identical, a contour consisting of a single point is returned.

The input tuples Row1, Column1, Row2, and Column2 have to be of the same length. HeadLength and HeadWidth either have to be of the same length as Row1, Column1, Row2, and Column2 or have to be a single element. If one of the above restrictions is violated, an error will occur.</abstract>
<alternatives>
<item>disp_arrow</item>
<item>gen_contour_polygon_xld</item>
</alternatives>
<chapters lang="de_DE">
<item>XLD</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>XLD</item>
<item>Creation</item>
</chapters>
<example lang="en_US">StartPointRows:=[100,100]
StartPointColumns:=[100,100]
EndPointRows:=[200,50]
EndPointColumns:=[200,150]
dev_set_colored (3)
gen_arrow_contour_xld (Arrow, StartPointRows, StartPointColumns, EndPointRows, EndPointColumns, [10,20], [20,10])</example>
<keywords lang="de_DE">
<item>XLD-Konturen erzeugen</item>
<item>XLD-Kontur eines Pfeils erzeugen</item>
</keywords>
<keywords lang="en_US">
<item>create XLD contours</item>
<item>create XLD contour of arrow</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>gen_contour_nurbs_xld</item>
</see_also>
<short lang="en_US">Create an arrow shaped XLD contour.</short>
<successor>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="Arrow">
<description lang="en_US">The generated xld</description>
<multivalue>optional</multivalue>
<sem_type>xld_cont</sem_type>
</parameter>
<parameter id="Column1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The column coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The column coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HeadLength">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The length of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="HeadWidth">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The width of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="Row1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The row coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Row2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The row coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="xyz_attrib_to_object_model_3d">
<interface>
<io>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
<par name="Z" base_type="iconic" dimension="0"/>
<par name="AttribImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="AttribName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Consistency checks:</c>
<l>count_obj (AttribImage, Number)</l>
<l>if (Number != 1)</l>
<l>    throw ('The attribute image must be an image array with exactly one object. If you want to set multiple attributes, use a multichannel image.')</l>
<l>endif</l>
<c>* </c>
<l>count_channels (AttribImage, Channels)</l>
<l>if (Channels != |AttribName|)</l>
<l>    throw ('The number of channels of the attribute image (' + Channels + ') must be equal to the number of attribute names (' + |AttribName| + ').')</l>
<l>endif</l>
<c>* </c>
<l>get_image_size (X, WidthX, HeightX)</l>
<l>get_image_size (Y, WidthY, HeightY)</l>
<l>get_image_size (Z, WidthZ, HeightZ)</l>
<l>get_image_size (AttribImage, WidthA, HeightA)</l>
<l>if (WidthX != WidthY or HeightX != HeightY or WidthX != WidthZ or HeightX != HeightZ or WidthX != WidthA or HeightX != HeightA)</l>
<l>    throw ('Image sizes do not match. The size of all input images must be equal.')</l>
<l>endif</l>
<c>* </c>
<l>get_param_info ('set_object_model_3d_attrib_mod', 'AttribName', 'value_list', AvailableAttributes)</l>
<l>tuple_regexp_select (AvailableAttributes, 'point_.*', Selection)</l>
<l>tuple_difference (AttribName, Selection, Difference)</l>
<l>tuple_regexp_select (Difference, '^[^&amp;]', InvalidParameters)</l>
<l>if (|InvalidParameters| &gt; 0)</l>
<l>    Exception := 'The following attribute names are invalid: ' + sum(InvalidParameters + ', ') + 'please use a \'&amp;\' prefix for extended attributes, e.g., \'&amp;' + InvalidParameters[0] + '\', or a standard point attribute.'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<c>* </c>
<c>* Get the domain of the images containing the 3D points and get the region all</c>
<c>* three of them share. This is because xyz_to_object_model_3d only uses points</c>
<c>* in the intersecting domains of all three images.</c>
<l>get_domain (X, DomainX)</l>
<l>get_domain (Y, DomainY)</l>
<l>get_domain (Z, DomainZ)</l>
<l>intersection (DomainX, DomainY, RegionIntersectionTmp)</l>
<l>intersection (RegionIntersectionTmp, DomainZ, RegionIntersection)</l>
<c>* </c>
<c>* Transform the images that contain the X, Y, and Z-coordinates to a 3D object model.</c>
<l>xyz_to_object_model_3d (X, Y, Z, ObjectModel3D)</l>
<c>* </c>
<c>* Loop through all channels and collect the corresponding attribute values</c>
<l>AttribValues := []</l>
<l>for Index := 1 to Channels by 1</l>
<l>    access_channel (AttribImage, Channel, Index)</l>
<l>    get_region_points (RegionIntersection, Rows, Columns)</l>
<l>    get_grayval (Channel, Rows, Columns, AttribValuesTmp)</l>
<l>    AttribValues := [AttribValues,AttribValuesTmp]</l>
<l>endfor</l>
<c>* </c>
<c>* Set the attributes</c>
<l>set_object_model_3d_attrib_mod (ObjectModel3D, AttribName, 'points', AttribValues)</l>
<l>return ()</l>
</body>
<docu id="xyz_attrib_to_object_model_3d">
<abstract lang="en_US">The procedure &lt;proc:xyz_attrib_to_object_model_3d&gt; transforms the images X, Y, and Z into a 3D object model ObjectModel3D. Additionally, it sets the point attributes in AttribName to the values in AttribImage.

The procedure can be used, e.g., to create a 3D object model that uses an RGB image to set the extended attributes *'&amp;amp;red'*, *'&amp;amp;green'*, and *'&amp;amp;blue'*. Then, as seen in the example code below, the procedure &lt;proc:visualize_object_model_3d&gt; can be used to display the object model with the respective texture.

AttribImage can be a multichannel image. The number of channels of the attribute image must be equal to the size of the tuple AttribName. Additionally, the images X, Y, Z, and AttribImage must be the same size.

Only points in the intersecting domains of the X, Y, and Z-image are used. The domain of AttribImage is ignored. The created 3D object model contains the coordinates of the points, as well as the xyz mapping attribute that contains the original row and column of each 3D point. Points where one of the coordinates is infinity or "Not a Number" (NaN) are ignored and not added to the 3D object model.

Note that if a 3D object model is no longer needed or should be overwritten, the memory has to be freed first by calling the operator &lt;op:clear_object_model_3d&gt;.</abstract>
<alternatives>
<item>xyz_to_object_model_3d</item>
<item>set_object_model_3d_attrib</item>
</alternatives>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Transformationen</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Transformations</item>
</chapters>
<example lang="en_US">xyz_attrib_to_object_model_3d (X, Y, Z, ImageRGB, ['&amp;amp;red', '&amp;amp;green', '&amp;amp;blue'], ObjectModel3D)
prepare_object_model_3d (ObjectModel3D, 'segmentation', 'true', [], [])
visualize_object_model_3d (WindowHandle, ObjectModel3D, [], [], ['red_channel_attrib', 'green_channel_attrib', 'blue_channel_attrib'], ['&amp;amp;red', '&amp;amp;green', '&amp;amp;blue'], [], [], [], PoseOut)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>disparity_image_to_xyz</item>
</predecessor>
<short lang="en_US">Transform 3D points from images to a 3D object model, and add extended attributes to the points of the object model.</short>
<successor>
<item>prepare_object_model_3d</item>
<item>select_points_object_model_3d</item>
</successor>
<parameters>
<parameter id="AttribImage">
<description lang="en_US">The (multichannel) image with the attributes.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="AttribName">
<default_type>string</default_type>
<default_value>'&amp;amp;gray'</default_value>
<description lang="en_US">The names of the attributes.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>['&amp;amp;red', '&amp;amp;green', '&amp;amp;blue']</item>
<item>'&amp;amp;distance'</item>
</values>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<description lang="en_US">Handle of the 3D object model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="X">
<description lang="en_US">Image with the X coordinates of the 3D points.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Y">
<description lang="en_US">Image with the Y coordinates of the 3D points.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Z">
<description lang="en_US">Image with the Z coordinates of the 3D points.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_robot_tool_and_base_object_model_3d">
<interface>
<ic>
<par name="ArrowThickness" base_type="ctrl" dimension="0"/>
<par name="ArrowLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DToolOrigin" base_type="ctrl" dimension="0"/>
<par name="OM3DBase" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure creates 3D models that represent the tool and the base</c>
<c>* of the robot.</c>
<c>* </c>
<l>if (ArrowThickness &lt;= 0)</l>
<l>    throw ('ArrowThickness should be &gt; 0')</l>
<l>endif</l>
<l>if (ArrowLength &lt;= 0)</l>
<l>    throw ('ArrowLength should be &gt; 0')</l>
<l>endif</l>
<l>create_pose (0, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', IdentityPose)</l>
<c>* </c>
<c>* 3D model for the tool.</c>
<l>create_pose (ArrowLength, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransXPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransXPose, OM3DToolXOrigin)</l>
<l>create_pose (0, ArrowLength, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransYPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransYPose, OM3DToolYOrigin)</l>
<l>create_pose (0, 0, ArrowLength, 0, 0, 0, 'Rp+T', 'gba', 'point', TransZPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransZPose, OM3DToolZOrigin)</l>
<l>OM3DToolOrigin := [OM3DToolXOrigin,OM3DToolYOrigin,OM3DToolZOrigin]</l>
<c>* </c>
<c>* 3D model for the base.</c>
<l>FactorVisBase := ArrowThickness * 10</l>
<l>gen_box_object_model_3d (IdentityPose, FactorVisBase * 1.5, FactorVisBase * 1.5, FactorVisBase / 12.0, OM3DBasePlate)</l>
<l>create_pose (ArrowLength, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransXPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransXPose, OM3DBaseX)</l>
<l>create_pose (0, ArrowLength, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransYPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransYPose, OM3DBaseY)</l>
<l>create_pose (0, 0, ArrowLength, 0, 0, 0, 'Rp+T', 'gba', 'point', TransZPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransZPose, OM3DBaseZ)</l>
<l>OM3DBase := [OM3DBaseX,OM3DBaseY,OM3DBaseZ,OM3DBasePlate]</l>
<l>return ()</l>
</body>
<docu id="gen_robot_tool_and_base_object_model_3d">
<abstract lang="en_US">This procedures generates the 3D models of the base and the tool coordinate systems of the robot.

The input parameters ArrowThickness and ArrowLength determine the size of the objects in 3D.

The output parameters OM3DToolOrigin and OM3DBase carry the handles for the tool and base 3D models respectively.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate base and tool 3D models of the robot.</short>
<parameters>
<parameter id="ArrowLength">
<default_type>real</default_type>
<description lang="en_US">Length of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowThickness">
<default_type>real</default_type>
<description lang="en_US">Thickness of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DBase">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's base.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DToolOrigin">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's tool.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="visualize_object_model_3d">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="PoseIn" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Label" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PoseOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* The procedure visualize_object_model_3d can be used to display</c>
<c>* one or more 3d object models and to interactively modify</c>
<c>* the object poses by using the mouse.</c>
<c>* </c>
<c>* The pose can be modified by moving the mouse while</c>
<c>* pressing a mouse button. The default settings are:</c>
<c>* </c>
<c>*  Rotate: Left mouse button</c>
<c>*  Zoom: Shift + Left mouse button (or Center mouse button)</c>
<c>*  Pan: Ctrl + Left mouse button</c>
<c>* </c>
<c>* Furthermore, it is possible to select and deselect objects,</c>
<c>* to decrease the mouse sensitivity, and to toggle the</c>
<c>* inspection mode (see the description of the generic parameter</c>
<c>* 'inspection_mode' below):</c>
<c>* </c>
<c>*  (De-)select object(s): Right mouse button</c>
<c>*  Low mouse sensitivity: Alt + mouse button</c>
<c>*  Toggle inspection mode: Ctrl + Alt + Left mouse button</c>
<c>* </c>
<c>* In GenParamName and GenParamValue all generic Parameters</c>
<c>* of disp_object_model_3d are supported.</c>
<c>* </c>
<c>* **********************************************************</c>
<c>* Define global variables</c>
<c>* **********************************************************</c>
<c>* </c>
<l>global def tuple gDispObjOffset</l>
<l>global def tuple gLabelsDecor</l>
<l>global def tuple gInfoDecor</l>
<l>global def tuple gInfoPos</l>
<l>global def tuple gTitlePos</l>
<l>global def tuple gTitleDecor</l>
<l>global def tuple gTerminationButtonLabel</l>
<l>global def tuple gAlphaDeselected</l>
<l>global def tuple gIsSinglePose</l>
<l>global def tuple gUsesOpenGL</l>
<c>* </c>
<c>* **********************************************************</c>
<c>* Initialize Handles to enable correct handling in error case</c>
<c>* **********************************************************</c>
<l>Scene3DTest := []</l>
<l>Scene3D := []</l>
<l>WindowHandleBuffer := []</l>
<c></c>
<c>* **********************************************************</c>
<c>* Some user defines that may be adapted if desired</c>
<c>* **********************************************************</c>
<c>* </c>
<c>* TrackballSize defines the diameter of the trackball in</c>
<c>* the image with respect to the smaller image dimension.</c>
<l>TrackballSize := 0.8</l>
<c>* </c>
<c>* VirtualTrackball defines the type of virtual trackball that</c>
<c>* shall be used ('shoemake' or 'bell').</c>
<l>VirtualTrackball := 'shoemake'</l>
<l>* VirtualTrackball := 'bell'</l>
<c>* </c>
<c>* Functionality of mouse buttons</c>
<c>*     1: Left mouse button</c>
<c>*     2: Middle mouse button</c>
<c>*     4: Right mouse button</c>
<c>*     5: Left+Right mouse button</c>
<c>*   8+x: Shift + mouse button</c>
<c>*  16+x: Ctrl + mouse button</c>
<c>*  48+x: Ctrl + Alt + mouse button</c>
<c>* in the order [Translate, Rotate, Scale, ScaleAlternative1, ScaleAlternative2, SelectObjects, ToggleSelectionMode]</c>
<l>MouseMapping := [17, 1, 2, 5, 9, 4, 49]</l>
<c>* </c>
<c>* The labels of the objects appear next to their projected</c>
<c>* center. With gDispObjOffset a fixed offset is added</c>
<c>*                   R,  C</c>
<l>gDispObjOffset := [-30, 0]</l>
<c>* </c>
<c>* Customize the decoration of the different text elements</c>
<c>*               Color,   Box</c>
<l>gInfoDecor := ['white', 'false']</l>
<l>gLabelsDecor := ['white', 'false']</l>
<l>gTitleDecor := ['black', 'true']</l>
<c>* </c>
<c>* Customize the position of some text elements</c>
<c>*   gInfoPos has one of the values</c>
<c>*   {'UpperLeft', 'LowerLeft', 'UpperRight'}</c>
<l>gInfoPos := 'LowerLeft'</l>
<c>*   gTitlePos has one of the values</c>
<c>*   {'UpperLeft', 'UpperCenter', 'UpperRight'}</c>
<l>gTitlePos := 'UpperLeft'</l>
<c>* Alpha value (=1-transparency) that is used for visualizing</c>
<c>* the objects that are not selected</c>
<l>gAlphaDeselected := 0.3</l>
<c>* Customize the label of the continue button</c>
<l>gTerminationButtonLabel := ' Continue '</l>
<c>* Define if the continue button responds to a single click event or</c>
<c>* if it responds only if the mouse button is released while being placed</c>
<c>* over the continue button.</c>
<c>* 'true':  Wait until the continue button has been released.</c>
<c>*          This should be used to avoid unwanted continuations of</c>
<c>*          subsequent calls of visualize_object_model_3d, which can</c>
<c>*          otherwise occur if the mouse button remains pressed while the</c>
<c>*          next visualization is active.</c>
<c>* 'false': Continue the execution already if the continue button is</c>
<c>*          pressed. This option allows a fast forwarding through</c>
<c>*          subsequent calls of visualize_object_model_3d.</c>
<l>WaitForButtonRelease := 'true'</l>
<c>* Number of 3D Object models that can be selected and handled individually.</c>
<c>* If there are more models passed then this number, some calculations</c>
<c>* are performed differently and the individual selection and handling</c>
<c>* of models is not supported anymore. Note that the value of MaxNumModels</c>
<c>* can be overwritten with the generic parameter max_num_selectable_models.</c>
<l>MaxNumModels := 1000</l>
<c>* Defines the default for the initial state of the rotation center:</c>
<c>* (1) The rotation center is fixed in the center of the image and lies</c>
<c>*     on the surface of the object.</c>
<c>* (2) The rotation center lies in the center of the object.</c>
<l>WindowCenteredRotation := 2</l>
<c>* </c>
<c>* **********************************************************</c>
<c>* </c>
<c>* Initialize some values</c>
<l>NumModels := |ObjectModel3D|</l>
<l>SelectedObject := gen_tuple_const(NumModels,1)</l>
<c>* </c>
<c>* Apply some system settings</c>
<l>dev_get_preferences ('graphics_window_context_menu', WindowContextMenu)</l>
<l>dev_set_preferences ('graphics_window_context_menu', 'false')</l>
<l>dev_get_preferences ('graphics_window_mouse_wheel', WindowMouseWheel)</l>
<l>dev_set_preferences ('graphics_window_mouse_wheel', 'false')</l>
<l>get_system ('clip_region', ClipRegion)</l>
<l>set_system ('clip_region', 'false')</l>
<l>dev_update_off ()</l>
<c>* </c>
<c>* Check if GenParamName matches GenParamValue</c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<l>    throw ('Number of generic parameters does not match number of generic parameter values')</l>
<l>endif</l>
<c>* </c>
<l>try</l>
<c>    * </c>
<c>    * Refactor camera parameters to fit to window size</c>
<c>    * </c>
<l>    CPLength := |CamParam|</l>
<l>    get_window_extents (WindowHandle, RowNotUsed, ColumnNotUsed, Width, Height)</l>
<l>    get_part (WindowHandle, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<l>    set_part (WindowHandle, 0, 0, Height - 1, Width - 1)</l>
<l>    if (CPLength == 0)</l>
<l>        gen_cam_par_area_scan_division (0.06, 0, 8.5e-6, 8.5e-6, Width / 2, Height / 2, Width, Height, CamParam)</l>
<l>    else</l>
<l>        get_cam_par_data (CamParam, ['sx', 'sy', 'cx', 'cy', 'image_width', 'image_height'], CamParamValue)</l>
<l>        CamWidth := real(CamParamValue[4])</l>
<l>        CamHeight := real(CamParamValue[5])</l>
<l>        Scale := min([Width / CamWidth,Height / CamHeight])</l>
<l>        set_cam_par_data (CamParam, 'sx', CamParamValue[0] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'sy', CamParamValue[1] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cx', CamParamValue[2] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cy', CamParamValue[3] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_width', int(CamParamValue[4] * Scale), CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_height', int(CamParamValue[5] * Scale), CamParam)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for max_num_selectable_models</c>
<c>    * (Note that the default is set above to MaxNumModels := 1000)</c>
<l>    Indices := find(GenParamName,'max_num_selectable_models')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (is_number(GenParamValue[Indices[0]]))</l>
<l>            if (int(number(GenParamValue[Indices[0]])) &lt; 1)</l>
<c>                * Wrong parameter value: Only integer values greater than 0 are allowed</c>
<l>                throw ('Wrong value for parameter \'max_num_selectable_models\' (must be an integer value greater than 0)')</l>
<l>            endif</l>
<l>        else</l>
<c>            * Wrong parameter value: Only integer values greater than 0 are allowed</c>
<l>            throw ('Wrong value for parameter \'max_num_selectable_models\' (must be an integer value greater than 0)')</l>
<l>        endif</l>
<l>        MaxNumModels := int(number(GenParamValue[Indices[0]]))</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for window_centered_rotation</c>
<c>    * (Note that the default is set above to WindowCenteredRotation := 2)</c>
<l>    Indices := find(GenParamName,'inspection_mode')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[0]] == 'surface')</l>
<l>            WindowCenteredRotation := 1</l>
<l>        elseif (GenParamValue[Indices[0]] == 'standard')</l>
<l>            WindowCenteredRotation := 2</l>
<l>        else</l>
<c>            * Wrong parameter value, use default value</c>
<l>        endif</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for disp_background</c>
<c>    * (The former parameter name 'use_background' is still supported</c>
<c>    *  for compatibility reasons)</c>
<l>    DispBackground := 'false'</l>
<l>    if (|GenParamName| &gt; 0)</l>
<l>        Mask := GenParamName [==] 'disp_background' or GenParamName [==] 'use_background'</l>
<l>        Indices := find(Mask,1)</l>
<l>    else</l>
<l>        Indices := -1</l>
<l>    endif</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        DispBackground := GenParamValue[Indices[0]]</l>
<l>        if (DispBackground != 'true' and DispBackground != 'false')</l>
<c>            * Wrong parameter value: Only 'true' and 'false' are allowed</c>
<l>            throw ('Wrong value for parameter \'disp_background\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<c>        * Note that the background is handled explicitly in this procedure</c>
<c>        * and therefore, the parameter is removed from the list of</c>
<c>        * parameters and disp_background is always set to true (see below)</c>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Read and check the parameter Label for each object</c>
<l>    if (|Label| == 0)</l>
<c>        * no labels set -&gt; leave as []</c>
<l>    elseif (|Label| == 1)</l>
<c>        * a single label set for all models</c>
<l>        Label := gen_tuple_const(NumModels,Label)</l>
<l>    else</l>
<l>        if (|Label| != NumModels)</l>
<c>            * Number of elements in Label does not match</c>
<c>            * the number of object models.</c>
<l>            throw ('Number of elements in Label (' + |Label| + ') does not match the number of object models(' + NumModels + ').')</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Convert labels into strings</c>
<l>    Label := '' + Label</l>
<c>    * </c>
<c>    * Read and check the parameter PoseIn for each object</c>
<l>    get_object_models_center (ObjectModel3D, Center)</l>
<l>    if (Center == [])</l>
<l>        Center := [0, 0, 0]</l>
<l>    endif</l>
<l>    if (|PoseIn| == 0)</l>
<c>        * If no pose was specified by the caller, automatically calculate</c>
<c>        * a pose that is appropriate for the visualization.</c>
<c>        * Set the initial model reference pose. The orientation is parallel</c>
<c>        * to the object coordinate system, the position is at the center</c>
<c>        * of gravity of all models.</c>
<l>        create_pose (-Center[0], -Center[1], -Center[2], 0, 0, 0, 'Rp+T', 'gba', 'point', PoseIn)</l>
<l>        determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, PoseEstimated)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseEstimated[Sequence % 7]</l>
<l>        gIsSinglePose := true</l>
<l>    elseif (|PoseIn| == 7)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseIn[Sequence % 7]</l>
<l>        gIsSinglePose := true</l>
<l>    else</l>
<l>        if (|PoseIn| != |ObjectModel3D| * 7)</l>
<c>            * Wrong number of values of input control parameter 'PoseIn'</c>
<l>            throw ('Wrong number of values of input control parameter \'PoseIn\'.')</l>
<l>        else</l>
<l>            Poses := PoseIn</l>
<l>        endif</l>
<l>        gIsSinglePose := false</l>
<l>    endif</l>
<c>    * </c>
<c>    * Open (invisible) buffer window to avoid flickering</c>
<l>    open_window (0, 0, Width, Height, 0, 'buffer', '', WindowHandleBuffer)</l>
<l>    set_part (WindowHandleBuffer, 0, 0, Height - 1, Width - 1)</l>
<l>    get_font (WindowHandle, Font)</l>
<l>    try</l>
<l>        set_font (WindowHandleBuffer, Font)</l>
<l>    catch (Exception)</l>
<l>    endtry</l>
<c>    * </c>
<c>    *  Is OpenGL available and should it be used?</c>
<l>    gUsesOpenGL := 'true'</l>
<l>    Indices := find(GenParamName,'opengl')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        gUsesOpenGL := GenParamValue[Indices[0]]</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>        if (gUsesOpenGL != 'true' and gUsesOpenGL != 'false')</l>
<c>            * Wrong parameter value: Only 'true' and 'false' are allowed</c>
<l>            throw ('Wrong value for parameter \'opengl\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (gUsesOpenGL == 'true')</l>
<l>        get_system ('opengl_info', OpenGLInfo)</l>
<l>        if (OpenGLInfo == 'No OpenGL support included.')</l>
<l>            gUsesOpenGL := 'false'</l>
<l>        else</l>
<l>            gen_object_model_3d_from_points (0, 0, 0, DummyObjectModel3D)</l>
<l>            create_scene_3d (Scene3DTest)</l>
<l>            add_scene_3d_camera (Scene3DTest, CamParam, CameraIndexTest)</l>
<l>            determine_optimum_pose_distance (DummyObjectModel3D, CamParam, 0.9, [0, 0, 0, 0, 0, 0, 0], PoseTest)</l>
<l>            add_scene_3d_instance (Scene3DTest, DummyObjectModel3D, PoseTest, InstanceIndexTest)</l>
<l>            try</l>
<l>                display_scene_3d (WindowHandleBuffer, Scene3DTest, InstanceIndexTest)</l>
<l>            catch (Exception)</l>
<l>                gUsesOpenGL := 'false'</l>
<l>            endtry</l>
<l>            clear_scene_3d (Scene3DTest)</l>
<l>            Scene3DTest := []</l>
<l>            clear_object_model_3d (DummyObjectModel3D)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Compute the trackball</c>
<l>    MinImageSize := min([Width,Height])</l>
<l>    TrackballRadiusPixel := TrackballSize * MinImageSize / 2.0</l>
<c>    * </c>
<c>    * Measure the text extents for the continue button in the</c>
<c>    * graphics window</c>
<l>    get_string_extents (WindowHandleBuffer, gTerminationButtonLabel + '  ', Ascent, Descent, TextWidth, TextHeight)</l>
<c>    * </c>
<c>    * Store background image</c>
<l>    if (DispBackground == 'false')</l>
<l>        clear_window (WindowHandle)</l>
<l>    endif</l>
<l>    dump_window_image (Image, WindowHandle)</l>
<c>    * Special treatment for color background images necessary</c>
<l>    count_channels (Image, NumChannels)</l>
<l>    ColorImage := NumChannels == 3</l>
<c>    * </c>
<l>    create_scene_3d (Scene3D)</l>
<l>    add_scene_3d_camera (Scene3D, CamParam, CameraIndex)</l>
<l>    add_scene_3d_instance (Scene3D, ObjectModel3D, Poses, AllInstances)</l>
<c>    * Always set 'disp_background' to true,  because it is handled explicitly</c>
<c>    * in this procedure (see above)</c>
<l>    set_scene_3d_param (Scene3D, 'disp_background', 'true')</l>
<c>    * Check if we have to set light specific parameters</c>
<l>    SetLight := regexp_test(GenParamName,'light_')</l>
<l>    if (SetLight)</l>
<c>        * set position of light source</c>
<l>        Indices := find(GenParamName,'light_position')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If multiple light positions are given, use the last one</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| != 4)</l>
<l>                throw ('light_position must be given as a string that contains four space separated floating point numbers')</l>
<l>            endif</l>
<l>            LightPosition := LightParam[0:2]</l>
<l>            LightKind := 'point_light'</l>
<l>            if (LightParam[3] == 0)</l>
<l>                LightKind := 'directional_light'</l>
<l>            endif</l>
<c>            * Currently, only one light source is supported</c>
<l>            remove_scene_3d_light (Scene3D, 0)</l>
<l>            add_scene_3d_light (Scene3D, LightPosition, LightKind, LightIndex)</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<c>        * set ambient part of light source</c>
<l>        Indices := find(GenParamName,'light_ambient')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If the ambient part is set multiple times, use the last setting</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| &lt; 3)</l>
<l>                throw ('light_ambient must be given as a string that contains three space separated floating point numbers')</l>
<l>            endif</l>
<l>            set_scene_3d_light_param (Scene3D, 0, 'ambient', LightParam[0:2])</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<c>        * Set diffuse part of light source</c>
<l>        Indices := find(GenParamName,'light_diffuse')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If the diffuse part is set multiple times, use the last setting</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| &lt; 3)</l>
<l>                throw ('light_diffuse must be given as a string that contains three space separated floating point numbers')</l>
<l>            endif</l>
<l>            set_scene_3d_light_param (Scene3D, 0, 'diffuse', LightParam[0:2])</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Handle persistence parameters separately because persistence will</c>
<c>    * only be activated immediately before leaving the visualization</c>
<c>    * procedure</c>
<l>    PersistenceParamName := []</l>
<l>    PersistenceParamValue := []</l>
<c>    * Set position of light source</c>
<l>    Indices := find(GenParamName,'object_index_persistence')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[|Indices| - 1]] == 'true')</l>
<l>            PersistenceParamName := [PersistenceParamName,'object_index_persistence']</l>
<l>            PersistenceParamValue := [PersistenceParamValue,'true']</l>
<l>        elseif (GenParamValue[Indices[|Indices| - 1]] == 'false')</l>
<l>        else</l>
<l>            throw ('Wrong value for parameter \'object_index_persistence\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>        tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>        tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>    endif</l>
<l>    Indices := find(GenParamName,'depth_persistence')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[|Indices| - 1]] == 'true')</l>
<l>            PersistenceParamName := [PersistenceParamName,'depth_persistence']</l>
<l>            PersistenceParamValue := [PersistenceParamValue,'true']</l>
<l>        elseif (GenParamValue[Indices[|Indices| - 1]] == 'false')</l>
<l>        else</l>
<l>            throw ('Wrong value for parameter \'depth_persistence\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>        tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>        tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Parse the generic parameters</c>
<c>    * - First, all parameters that are understood by set_scene_3d_instance_param</c>
<l>    AlphaOrig := gen_tuple_const(NumModels,1)</l>
<l>    for I := 0 to |GenParamName| - 1 by 1</l>
<l>        ParamName := GenParamName[I]</l>
<l>        ParamValue := GenParamValue[I]</l>
<c>        * Check if this parameter is understood by set_scene_3d_param</c>
<l>        if (ParamName == 'alpha')</l>
<l>            AlphaOrig := gen_tuple_const(NumModels,ParamValue)</l>
<l>        endif</l>
<l>        try</l>
<l>            set_scene_3d_param (Scene3D, ParamName, ParamValue)</l>
<l>            continue</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 1203 or Exception[0] == 1303)</l>
<l>                if (ParamName == 'color_attrib' or ParamName == 'red_channel_attrib' or ParamName == 'green_channel_attrib' or ParamName == 'blue_channel_attrib')</l>
<l>                    throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue + '. ' + ParamValue + ' may not be attached to the points of the 3D object model. Compare the parameter AttachExtAttribTo of set_object_model_3d_attrib.')</l>
<l>                else</l>
<l>                    throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue)</l>
<l>                endif</l>
<l>            endif</l>
<l>        endtry</l>
<c>        * Check if it is a parameter that is valid for only one instance</c>
<c>        * and therefore can be set only with set_scene_3d_instance_param</c>
<l>        ParamNameTrunk := regexp_replace(ParamName,'_\\d+$','')</l>
<l>        if (ParamName == ParamNameTrunk)</l>
<l>            Instance := [0:NumModels - 1]</l>
<l>        else</l>
<l>            Instance := number(regexp_replace(ParamName,'^' + ParamNameTrunk + '_(\\d+)$','$1'))</l>
<l>            if (Instance &lt; 0 or Instance &gt; NumModels - 1)</l>
<l>                throw ('Parameter ' + ParamName + ' refers to a non existing 3D object model')</l>
<l>            endif</l>
<l>        endif</l>
<l>        try</l>
<l>            set_scene_3d_instance_param (Scene3D, Instance, ParamNameTrunk, ParamValue)</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 1204 or Exception[0] == 1304)</l>
<l>                if (ParamNameTrunk == 'color_attrib' or ParamNameTrunk == 'red_channel_attrib' or ParamNameTrunk == 'green_channel_attrib' or ParamNameTrunk == 'blue_channel_attrib')</l>
<l>                    throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue + '. ' + ParamValue + ' may not be attached to the points of the 3D object model. Compare the parameter AttachExtAttribTo of set_object_model_3d_attrib.')</l>
<l>                else</l>
<l>                    throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue)</l>
<l>                endif</l>
<l>            elseif (Exception[0] == 1203 or Exception[0] == 1303)</l>
<l>                throw ('Wrong parameter name ' + ParamName)</l>
<l>            else</l>
<l>                throw (Exception)</l>
<l>            endif</l>
<l>        endtry</l>
<l>        if (ParamNameTrunk == 'alpha')</l>
<l>            AlphaOrig[Instance] := ParamValue</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Start the visualization loop</c>
<l>    pose_to_hom_mat3d (Poses[0:6], HomMat3D)</l>
<l>    affine_trans_point_3d (HomMat3D, Center[0], Center[1], Center[2], Qx, Qy, Qz)</l>
<l>    TBCenter := [Qx,Qy,Qz]</l>
<l>    TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>    ButtonHold := false</l>
<l>    while (1)</l>
<l>        VisualizeTB := max(SelectedObject) != 0</l>
<l>        MaxIndex := min([|ObjectModel3D|,MaxNumModels]) - 1</l>
<c>        * Set trackball fixed in the center of the window</c>
<l>        TrackballCenterRow := Height / 2</l>
<l>        TrackballCenterCol := Width / 2</l>
<l>        if (WindowCenteredRotation == 1)</l>
<l>            try</l>
<l>                get_trackball_center_fixed (SelectedObject[0:MaxIndex], TrackballCenterRow, TrackballCenterCol, TrackballRadiusPixel, Scene3D, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], WindowHandleBuffer, CamParam, GenParamName, GenParamValue, TBCenter, TBSize)</l>
<l>            catch (Exception)</l>
<l>                disp_message (WindowHandle, 'Surface inspection mode is not available.', 'image', 5, 20, 'red', 'true')</l>
<l>                WindowCenteredRotation := 2</l>
<l>                get_trackball_center (SelectedObject[0:MaxIndex], TrackballRadiusPixel, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], TBCenter, TBSize)</l>
<l>                wait_seconds (1)</l>
<l>            endtry</l>
<l>        else</l>
<l>            get_trackball_center (SelectedObject[0:MaxIndex], TrackballRadiusPixel, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], TBCenter, TBSize)</l>
<l>        endif</l>
<l>        dump_image_output (Image, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3D, GenParamName, GenParamValue, CamParam, Poses, ColorImage, Title, Information, Label, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObject, WindowCenteredRotation, TBCenter)</l>
<l>        dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>        dev_set_window (WindowHandle)</l>
<l>        dev_display (ImageDump)</l>
<c>        * </c>
<c>        * Check for mouse events</c>
<l>        GraphEvent := false</l>
<l>        Exit := false</l>
<l>        while (1)</l>
<c>            * </c>
<c>            * Check graphic event</c>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, GraphButtonRow, GraphButtonColumn, GraphButton)</l>
<l>                if (GraphButton != 0)</l>
<l>                    if (GraphButtonRow &gt; Height - TextHeight - 25 and GraphButtonRow &lt; Height and GraphButtonColumn &gt; Width - TextWidth - 15 and GraphButtonColumn &lt; Width)</l>
<c>                        * Wait until the continue button has been released</c>
<l>                        if (WaitForButtonRelease == 'true')</l>
<l>                            while (1)</l>
<l>                                get_mposition_sub_pix (WindowHandle, GraphButtonRow, GraphButtonColumn, GraphButton)</l>
<l>                                if (GraphButton == 0 or GraphButton == [])</l>
<l>                                    if (GraphButtonRow &gt; Height - TextHeight - 25 and GraphButtonRow &lt; Height and GraphButtonColumn &gt; Width - TextWidth - 15 and GraphButtonColumn &lt; Width)</l>
<l>                                        ButtonReleased := true</l>
<l>                                    else</l>
<l>                                        ButtonReleased := false</l>
<l>                                    endif</l>
<c>                                    * </c>
<l>                                    break</l>
<l>                                endif</l>
<c>                                * Keep waiting until mouse button is released or moved out of the window</c>
<l>                            endwhile</l>
<l>                        else</l>
<l>                            ButtonReleased := true</l>
<l>                        endif</l>
<c>                        * Exit the visualization loop</c>
<l>                        if (ButtonReleased)</l>
<l>                            Exit := true</l>
<l>                            break</l>
<l>                        endif</l>
<l>                    endif</l>
<l>                    GraphEvent := true</l>
<l>                    break</l>
<l>                else</l>
<l>                    ButtonHold := false</l>
<l>                endif</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>        if (GraphEvent)</l>
<l>            analyze_graph_event (Image, MouseMapping, GraphButton, GraphButtonRow, GraphButtonColumn, WindowHandle, WindowHandleBuffer, VirtualTrackball, TrackballSize, SelectedObject, Scene3D, AlphaOrig, ObjectModel3D, CamParam, Label, Title, Information, GenParamName, GenParamValue, Poses, ButtonHold, TBCenter, TBSize, WindowCenteredRotation, MaxNumModels, Poses, SelectedObject, ButtonHold, WindowCenteredRotation)</l>
<l>        endif</l>
<l>        if (Exit)</l>
<l>            break</l>
<l>        endif</l>
<l>    endwhile</l>
<c>    * </c>
<c>    * Display final state with persistence, if requested</c>
<c>    * Note that disp_object_model_3d must be used instead of the 3D scene</c>
<l>    if (|PersistenceParamName| &gt; 0)</l>
<l>        disp_object_model_3d (WindowHandle, ObjectModel3D, CamParam, Poses, ['disp_background', 'alpha',PersistenceParamName], ['true', 0.0,PersistenceParamValue])</l>
<l>    endif</l>
<c>    * </c>
<c>    * Compute the output pose</c>
<l>    if (gIsSinglePose)</l>
<l>        PoseOut := Poses[0:6]</l>
<l>    else</l>
<l>        PoseOut := Poses</l>
<l>    endif</l>
<c>    * </c>
<c>    * Clean up.</c>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    dev_set_preferences ('graphics_window_context_menu', WindowContextMenu)</l>
<l>    dev_set_preferences ('graphics_window_mouse_wheel', WindowMouseWheel)</l>
<l>    dump_image_output (Image, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3D, GenParamName, GenParamValue, CamParam, Poses, ColorImage, Title, [], Label, 0, 'false', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObject, WindowCenteredRotation, TBCenter)</l>
<l>    dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>    dev_set_window (WindowHandle)</l>
<l>    dev_display (ImageDump)</l>
<l>    close_window (WindowHandleBuffer)</l>
<l>    set_part (WindowHandle, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<l>    clear_scene_3d (Scene3D)</l>
<l>    Scene3D := []</l>
<l>catch (Exception)</l>
<l>    try</l>
<c>        * Try to clean up as much as possible.</c>
<l>        if (0 &lt; |Scene3DTest|)</l>
<l>            clear_scene_3d (Scene3DTest)</l>
<l>            Scene3DTest := []</l>
<l>        endif</l>
<l>        if (0 &lt; |Scene3D|)</l>
<l>            clear_scene_3d (Scene3D)</l>
<l>            Scene3D := []</l>
<l>        endif</l>
<l>        if (0 &lt; |WindowHandleBuffer|)</l>
<l>            close_window (WindowHandleBuffer)</l>
<l>            WindowHandleBuffer := []</l>
<l>        endif</l>
<l>    catch (e)</l>
<c>        * Suppress all further exceptions to return the original exception.</c>
<l>    endtry</l>
<l>    try</l>
<c>        * Restore system settings.</c>
<l>        set_system ('clip_region', ClipRegion)</l>
<l>        dev_set_preferences ('graphics_window_context_menu', WindowContextMenu)</l>
<l>        dev_set_preferences ('graphics_window_mouse_wheel', WindowMouseWheel)</l>
<l>    catch (e)</l>
<c>        * Suppress all further exceptions to return the original exception.</c>
<l>    endtry</l>
<c>    * </c>
<l>    throw (Exception)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="visualize_object_model_3d">
<abstract lang="en_US">The procedure &lt;proc:visualize_object_model_3d&gt; displays the 3D object models of ObjectModel3D in the window with the handle WindowHandle and allows to interactively modify the object poses with the mouse. The current content of the window will be kept as background.

The pose can be modified by moving the mouse while pressing a mouse button. The default settings are:

- Rotate: Left mouse button
- Zoom: Shift + Left mouse button (or Center mouse button)
- Pan: Ctrl + Left mouse button

Furthermore, it is possible to select and deselect objects, to decrease the mouse sensitivity, and to toggle the inspection mode (see the description of the generic parameter *'inspection_mode'* below):

- (De-)select object(s): Right mouse button
- Low mouse sensitivity: Alt + mouse button
- Toggle inspection mode: Ctrl + Alt + Left mouse button

Note that the selection of individual 3D object models is only available, if the number of models is not greater than 1000 (or the value passed with the generic parameter *'max_num_selectable_models'*, see below).

Set CamParam and the individual poses (in PoseIn) of the 3D object models to setup the displayed scene.
If an empty tuple is given for CamParam, &lt;proc:visualize_object_model_3d&gt; uses default camera parameters that correspond to the window size.
PoseIn can contain either multiple poses (one for each 3D object model) or one pose for all 3D object models.
If an empty tuple is given for PoseIn, &lt;proc:visualize_object_model_3d&gt; estimates a pose, such that all 3D object models are visible.

The parameter Title can be used to specify text that will be displayed in a box at the top of the window.

The parameter Label can be used to specify a list of labels, which are displayed aligned with the corresponding 3D object model. It must either contain one entry per 3D object model or it must be empty.

The parameter Information can be used to specify text that is displayed without a box at the bottom left of the window.

The output parameter PoseOut contains the possibly modified poses used for the visualization of the 3D object models. These poses can be used directly in &lt;op:disp_object_model_3d&gt; and &lt;op:render_object_model_3d&gt; or in &lt;proc:visualize_object_model_3d&gt; to start the visualization with exactly the poses that have been chosen interactively.

Further options regarding the visualization can be controlled by the parameters GenParamNames and GenParamValues:

- The visualization can be configured with a set of parameters, which is described in detail in the reference documentation of &lt;op:disp_object_model_3d&gt;.

- *'max_num_selectable_models'*:
Number of 3D Object models that can be selected and handled individually. If there are more models passed then this number, some calculations are performed differently and for reasons of efficiency, the individual selection and handling of models is not supported anymore.\
Values: *1*, *2*, ...\
Default: *1000*

- *'inspection_mode'*:
Flag that controls the initial state of the inspection mode.
If *'inspection_mode'* is set to *'standard'*, the rotation center is fixed in the center of the displayed object. In this mode, the rotation center is indicated by a vertical cross (+). This mode is  particularly well suited for getting an impression of the whole object.
If *'inspection_mode'* is set to *'surface'*, the rotation center is fixed in the center of the window and it lies on the surface of the displayed object. In this mode, the rotation center is indicated by a diagonal cross (x). This mode is particularly well suited for a detailed inspection of the object's surface. It is less suitable for the inspection of point clouds, because they do not provide surface information.
Note that the trackball itself is kept in the center of the image, regardless of the selected inspection mode. Note also that the inspection mode can be toggled interactively during the visualization with Ctrl + Alt + Left mouse button (see above).\
Values: *'standard'* or *'surface'*\
Default: *'standard'*</abstract>
<alternatives>
<item>disp_object_model_3d</item>
</alternatives>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D1, Status)
read_object_model_3d ('clamp_sloped', 'mm', [], [], ObjectModel3D2, Status)
gen_cam_par_area_scan_division (0.016, 0, 5e-6, 5e-6, 320, 240, 640, 480, CamParam)
get_cam_par_data (CamParam, 'image_width', Width)
get_cam_par_data (CamParam, 'image_height', Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
create_pose (-0.02, 0.01, .6, 110, 5, 320, 'Rp+T', 'gba', 'point', Pose1)
create_pose (0.01, 0.03, .6, 130, 315, 340, 'Rp+T', 'gba', 'point', Pose2)
visualize_object_model_3d (WindowHandle, [ObjectModel3D1, ObjectModel3D2], \
                           CamParam, [Pose1, Pose2], \
                           ['alpha', 'color_0', 'color_1', 'disp_pose'], \
                           [0.5,     'orange',  'yellow',  'true'], \
                           ['3D visualization demo'], ['pipe joint', 'clamp'], \
                           ['Use mouse to change view'], PoseOut)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_object_model_3d</item>
<item>gen_object_model_3d_from_points</item>
</predecessor>
<see_also>
<item>disp_object_model_3d</item>
</see_also>
<short lang="en_US">Display 3D object models</short>
<successor>
<item>clear_object_model_3d</item>
</successor>
<parameters>
<parameter id="CamParam">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Camera parameters of the scene.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of the generic parameters. All generic parameters of disp_object_model_3d can be passed here as well.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'alpha'</item>
<item>'attribute'</item>
<item>'color'</item>
<item>'colored'</item>
<item>'disp_background'</item>
<item>'disp_lines'</item>
<item>'disp_normals'</item>
<item>'disp_pose'</item>
<item>'inspection_mode'</item>
<item>'intensity'</item>
<item>'intensity_red'</item>
<item>'intensity_green'</item>
<item>'intensity_blue'</item>
<item>'light_position'</item>
<item>'light_ambient'</item>
<item>'light_diffuse'</item>
<item>'line_color'</item>
<item>'line_width'</item>
<item>'lut'</item>
<item>'max_num_selectable_models'</item>
<item>'normal_color'</item>
<item>'point_size'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Values of the generic parameters. All generic parameters of disp_object_model_3d can be passed here as well.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
<item>'coord_x'</item>
<item>'coord_y'</item>
<item>'coord_z'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'auto'</item>
<item>'faces'</item>
<item>'primitive'</item>
<item>'points'</item>
<item>'lines'</item>
<item>'normal_x'</item>
<item>'normal_y,'normal_z'</item>
<item>'standard'</item>
<item>'surface'</item>
</values>
</parameter>
<parameter id="Information">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed in the lower left corner of the output graphics window.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Label">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed at the position of each displayed object model.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PoseIn">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">3D poses of the objects.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="PoseOut">
<default_type>real</default_type>
<description lang="en_US">Poses of all object models that were possibly interactively changed by the user.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Title">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed in the upper left corner of the output graphics window.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window identifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="replace_legacy_preprocessing_parameters" access="local">
<interface>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure adapts the dictionary DLPreprocessParam</c>
<c>* if a legacy preprocessing parameter is set.</c>
<c>* </c>
<c>* Map legacy value set to new parameter.</c>
<l>Exception := false</l>
<l>try</l>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', 'normalization_type', NormalizationTypeExists)</l>
<c>    * </c>
<l>    if (NormalizationTypeExists)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)</l>
<l>        if (NormalizationType == 'true')</l>
<l>            NormalizationType := 'first_channel'</l>
<l>        elseif (NormalizationType == 'false')</l>
<l>            NormalizationType := 'none'</l>
<l>        endif</l>
<l>        set_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)</l>
<l>    endif</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c>* </c>
<c>* Map legacy parameter to new parameter and corresponding value.</c>
<l>Exception := false</l>
<l>try</l>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', 'contrast_normalization', LegacyNormalizationKeyExists)</l>
<l>    if (LegacyNormalizationKeyExists)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'contrast_normalization', ContrastNormalization)</l>
<c>        * Replace 'contrast_normalization' by 'normalization_type'.</c>
<l>        if (ContrastNormalization == 'false')</l>
<l>            set_dict_tuple (DLPreprocessParam, 'normalization_type', 'none')</l>
<l>        elseif (ContrastNormalization == 'true')</l>
<l>            set_dict_tuple (DLPreprocessParam, 'normalization_type', 'first_channel')</l>
<l>        endif</l>
<l>        remove_dict_key (DLPreprocessParam, 'contrast_normalization')</l>
<l>    endif</l>
<l>catch (Exception)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="replace_legacy_preprocessing_parameters">
<abstract lang="en_US">Legacy preprocessing parameters or values are replaced by their currently corresponding one.

The following parameters are replaced:
- 'contrast_normalization' is replaced by 'normalization_type'
- 'normalization_type' values 'true'/'false' are replaced by 'first_channel'/'none'</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Replace legacy preprocessing parameters or values.</short>
<parameters>
<parameter id="DLPreprocessParam"/>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_images_ocr_recognition">
<interface>
<io>
<par name="Images" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImagesPreprocessed" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure preprocesses the provided Images according to the parameters</c>
<c>* in the dictionary DLPreprocessParam for an ocr_recognition model.</c>
<c>* </c>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param (DLPreprocessParam)</l>
<c>* </c>
<c>* Get the preprocessing parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_num_channels', ImageNumChannels)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)</l>
<l>get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<l>get_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)</l>
<l>get_dict_tuple (DLPreprocessParam, 'model_type', ModelType)</l>
<c>* </c>
<c>* Check the preprocessing parameters.</c>
<l>if (ModelType != 'ocr_recognition')</l>
<l>    throw ('The only \'model_type\' value supported is\'ocr_recognition\'.')</l>
<l>endif</l>
<l>if (ImageNumChannels != 1)</l>
<l>    throw ('The only \'image_num_channels\' value supported for ocr_recognition models is 1.')</l>
<l>endif</l>
<l>if (DomainHandling != 'full_domain')</l>
<l>    throw ('The only \'domain_handling\' value supported for ocr_recognition models is \'full_domain\'.')</l>
<l>endif</l>
<l>if (NormalizationType != 'none' and NormalizationType != 'first_channel' and NormalizationType != 'all_channels')</l>
<l>    throw ('The \'normalization_type\' values supported for ocr_recognition models are \'first_channel\', \'all_channels\' and \'none\'.')</l>
<l>endif</l>
<c>* </c>
<c>* Get the image properties.</c>
<l>count_obj (Images, NumImages)</l>
<l>count_channels (Images, NumChannels)</l>
<l>get_image_type (Images, ImageTypes)</l>
<l>get_image_size (Images, InputImageWidths, InputImageHeights)</l>
<c>* </c>
<c>* Check the image properties.</c>
<l>if (NumImages == 0)</l>
<l>    throw ('Please provide some images to preprocess.')</l>
<l>endif</l>
<l>if (NumImages != regexp_test(ImageTypes,'byte|real'))</l>
<l>    throw ('Please provide only images of type \'byte\' or \'real\'.')</l>
<l>endif</l>
<l>if (NumImages != sum(NumChannels [==] 1 or NumChannels [==] 3))</l>
<l>    throw ('Please provide only 1- or 3-channels images for ocr_recognition models.')</l>
<l>endif</l>
<c>* </c>
<c>* Preprocess the images.</c>
<l>PaddingGrayval := 0.0</l>
<l>ImageRange := real(ImageRangeMax - ImageRangeMin)</l>
<l>gen_image_const (TargetImage, 'real', ImageWidth, ImageHeight)</l>
<l>overpaint_region (TargetImage, TargetImage, PaddingGrayval, 'fill')</l>
<l>for I := 0 to NumImages - 1 by 1</l>
<l>    InputImageWidth := InputImageWidths[I]</l>
<l>    InputImageHeight := InputImageHeights[I]</l>
<l>    InputImageWidthHeightRatio := InputImageWidth / real(InputImageHeight)</l>
<c>    * </c>
<l>    select_obj (Images, Image, I + 1)</l>
<l>    full_domain (Image, Image)</l>
<l>    if (NumChannels[I] == 3)</l>
<l>        rgb1_to_gray (Image, Image)</l>
<l>    endif</l>
<c>    * </c>
<l>    ZoomHeight := ImageHeight</l>
<l>    ZoomWidth := min2(ImageWidth,int(ImageHeight * InputImageWidthHeightRatio))</l>
<l>    zoom_image_size (Image, Image, ZoomWidth, ZoomHeight, 'constant')</l>
<l>    if (ImageTypes[I] == 'byte')</l>
<l>        convert_image_type (Image, Image, 'real')</l>
<l>    endif</l>
<l>    if (NormalizationType == 'first_channel' or NormalizationType == 'all_channels')</l>
<l>        min_max_gray (Image, Image, 0, GrayvalMin, GrayvalMax, Range)</l>
<l>        GrayvalRange := real(GrayvalMax - GrayvalMin)</l>
<l>        if (GrayvalRange == 0.0)</l>
<l>            Scale := 1.0</l>
<l>        else</l>
<l>            Scale := ImageRange / GrayvalRange</l>
<l>        endif</l>
<l>        Shift := -Scale * GrayvalMin + ImageRangeMin</l>
<l>        scale_image (Image, Image, Scale, Shift)</l>
<l>    elseif (NormalizationType == 'none')</l>
<l>        if (ImageTypes[I] == 'byte')</l>
<l>            scale_image (Image, Image, ImageRange / 255.0, ImageRangeMin)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<l>    overpaint_gray (TargetImage, Image)</l>
<l>    reduce_domain (TargetImage, Image, TargetImage)</l>
<l>    replace_obj (Images, TargetImage, Images, I + 1)</l>
<l>endfor</l>
<c>* </c>
<c>* Return the preprocessed images.</c>
<l>ImagesPreprocessed := Images</l>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_images_ocr_recognition">
<abstract lang="en_US">This procedure preprocesses the provided Images according to the parameters in the dictionary DLPreprocessParam for Deep OCR recognition models.

The dictionary DLPreprocessParam specifies the properties the images need for a successful model application, and it can be created using e.g., &lt;proc:create_dl_preprocess_param&gt; or &lt;proc:create_dl_preprocess_param_from_model&gt;.

This procedure supports only certain values for some of the DLPreprocessParam properties: *'image_num_channels'* must be *1*, *'domain_handling'* must be *'full_domain'* and *'normalization_type'* can be *'first_channel'*, *'all_channels'* or *'none'*.

The preprocessed images are returned in ImagesPreprocessed. It is recommended to check the output images of this procedure in order to verify that they are suitable for a successful training of a model.

Note that this procedure can only preprocess input images fulfilling the following conditions:
- Image type is equal to 'byte' or 'real'. Both image types could be combined.
- Number of channels is either *1* or *3*. The preprocessed output images will be single channel images.

If an input image differs in these points, please execute a customized preprocessing.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>OCR</item>
<item>Deep OCR</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess images for deep-learning-based training and inference of Deep OCR recognition models.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Images">
<description lang="en_US">Images to be preprocessed.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImagesPreprocessed">
<description lang="en_US">Preprocessed images.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="filter_dl_sample_instance_segmentation_masks" access="local">
<interface>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="BBoxSelectionMask" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>get_dict_param (DLSample, 'key_exists', 'mask', MaskKeyExists)</l>
<l>if (MaskKeyExists)</l>
<c>    * Only if masks exist (-&gt; instance segmentation).</c>
<l>    tuple_find (BBoxSelectionMask, 1, Indices)</l>
<l>    if (Indices == -1)</l>
<c>        * We define here that this case will result in an empty object value</c>
<c>        * for the mask key. Another option would be to remove the</c>
<c>        * key 'mask'. However, this would be an unwanted big change in the dictionary.</c>
<l>        gen_empty_obj (EmptyMasks)</l>
<l>        set_dict_object (EmptyMasks, DLSample, 'mask')</l>
<l>    else</l>
<l>        get_dict_object (Masks, DLSample, 'mask')</l>
<c>        * Remove all unused masks.</c>
<l>        select_obj (Masks, Masks, Indices + 1)</l>
<l>        set_dict_object (Masks, DLSample, 'mask')</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="filter_dl_sample_instance_segmentation_masks">
<abstract lang="en_US">Filters the instance segmentation masks of a DL sample based on a given selection.

The input dictionary will be changed. The masks given in the key 'mask' will be filtered based on the input parameter tuple BBoxSelectionMask.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Objektdetektion und Instanz-Segmentierung</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Object Detection and Instance Segmentation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Filter the instance segmentation masks of a DL sample based on a given selection.</short>
<parameters>
<parameter id="BBoxSelectionMask">
<default_type>integer</default_type>
<description lang="en_US">Selection mask as used with the operator tuple_select_mask (see documentation of tuple_select_mask).
The length of the selection mask should be equal to the number of masks in the dl sample.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_list>
<item>[0,1]</item>
</value_list>
<value_min>0</value_min>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<description lang="en_US">Input DL sample.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="convert_rect2_5to8param" access="local">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Col" base_type="ctrl" dimension="0"/>
<par name="Length1" base_type="ctrl" dimension="0"/>
<par name="Length2" base_type="ctrl" dimension="0"/>
<par name="Phi" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Col1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Col2" base_type="ctrl" dimension="0"/>
<par name="Row3" base_type="ctrl" dimension="0"/>
<par name="Col3" base_type="ctrl" dimension="0"/>
<par name="Row4" base_type="ctrl" dimension="0"/>
<par name="Col4" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure takes the parameters for a rectangle of type 'rectangle2'</c>
<c>* and returns the coordinates of the four corners.</c>
<c>* </c>
<l>Co1 := cos(Phi) * Length1</l>
<l>Co2 := cos(Phi) * Length2</l>
<l>Si1 := sin(Phi) * Length1</l>
<l>Si2 := sin(Phi) * Length2</l>
<c></c>
<l>Col1 := Co1 - Si2 + Col</l>
<l>Row1 := -Si1 - Co2 + Row</l>
<l>Col2 := -Co1 - Si2 + Col</l>
<l>Row2 := Si1 - Co2 + Row</l>
<l>Col3 := -Co1 + Si2 + Col</l>
<l>Row3 := Si1 + Co2 + Row</l>
<l>Col4 := Co1 + Si2 + Col</l>
<l>Row4 := -Si1 + Co2 + Row</l>
<c></c>
<l>return ()</l>
</body>
<docu id="convert_rect2_5to8param">
<abstract lang="en_US">This procedure takes the parameters for a tuple of rectangles of type 'rectangle2' (Row, Column, Phi, Length1, and Length2)
and returns the coordinates of the four corners for each rectangle.

Using the orientation of rectangle2, the four output corners are ordered such that for an angle of phi=0 they would be at:
- (Row1, Col1): top-right corner
- (Row2, Col2): top-left corner
- (Row3, Col3): bottom-left corner
- (Row4, Col4): bottom-right corner.</abstract>
<chapters lang="de_DE">
<item>Tools</item>
<item>Geometrie</item>
</chapters>
<chapters lang="en_US">
<item>Tools</item>
<item>Geometry</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Convert the parameters of rectangles with format rectangle2 to the coordinates of its 4 corner-points.</short>
<parameters>
<parameter id="Col"/>
<parameter id="Col1"/>
<parameter id="Col2"/>
<parameter id="Col3"/>
<parameter id="Col4"/>
<parameter id="Length1"/>
<parameter id="Length2"/>
<parameter id="Phi"/>
<parameter id="Row"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
<parameter id="Row3"/>
<parameter id="Row4"/>
</parameters>
</docu>
</procedure>
<procedure name="convert_rect2_8to5param" access="local">
<interface>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Col1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Col2" base_type="ctrl" dimension="0"/>
<par name="Row3" base_type="ctrl" dimension="0"/>
<par name="Col3" base_type="ctrl" dimension="0"/>
<par name="Row4" base_type="ctrl" dimension="0"/>
<par name="Col4" base_type="ctrl" dimension="0"/>
<par name="ForceL1LargerL2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Col" base_type="ctrl" dimension="0"/>
<par name="Length1" base_type="ctrl" dimension="0"/>
<par name="Length2" base_type="ctrl" dimension="0"/>
<par name="Phi" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure takes the corners of four-sided figures</c>
<c>* and returns the parameters of type 'rectangle2'.</c>
<c>* </c>
<c>* Calculate center row and column.</c>
<l>Row := (Row1 + Row2 + Row3 + Row4) / 4.0</l>
<l>Col := (Col1 + Col2 + Col3 + Col4) / 4.0</l>
<c>* Length1 and Length2.</c>
<l>Length1 := sqrt((Row1 - Row2) * (Row1 - Row2) + (Col1 - Col2) * (Col1 - Col2)) / 2.0</l>
<l>Length2 := sqrt((Row2 - Row3) * (Row2 - Row3) + (Col2 - Col3) * (Col2 - Col3)) / 2.0</l>
<c>* Calculate the angle phi.</c>
<l>Hor := Col1 - Col2</l>
<l>Vert := Row2 - Row1</l>
<l>if (ForceL1LargerL2)</l>
<c>    * Swap length1 and length2 if necessary.</c>
<l>    IdxSwap := find((Length2 - Length1) [&gt;] 1e-9,1)</l>
<l>    if (IdxSwap != -1)</l>
<l>        Tmp := Length1[IdxSwap]</l>
<l>        Length1[IdxSwap] := Length2[IdxSwap]</l>
<l>        Length2[IdxSwap] := Tmp</l>
<l>        Hor[IdxSwap] := Col2[IdxSwap] - Col3[IdxSwap]</l>
<l>        Vert[IdxSwap] := Row3[IdxSwap] - Row2[IdxSwap]</l>
<l>    endif</l>
<l>endif</l>
<l>Phi := atan2(Vert,Hor)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="convert_rect2_8to5param">
<abstract lang="en_US">This procedure takes the corners of four-sided figures,
assumes that they belong to rectangles, and returns the parameters of type 'rectangle2' (Row, Column, Phi, Length1, and Length2).

Thereby, for each figure the four input corners are assumed to be ordered such that for an angle of phi=0 they would be at:
- (Row1, Col1): top-right corner
- (Row2, Col2): top-left corner
- (Row3, Col3): bottom-left corner
- (Row4, Col4): bottom-right corner.

ForceL1LargerL2 determines, if the output parameters are given such that Length1 is always larger or equal to Length2 ('true') or that Length1 is half the length of the edge from corner 1 to 2.</abstract>
<chapters lang="de_DE">
<item>Tools</item>
<item>Geometrie</item>
</chapters>
<chapters lang="en_US">
<item>Tools</item>
<item>Geometry</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Convert for four-sided figures the coordinates of the 4 corner-points to the parameters of format rectangle2.</short>
<parameters>
<parameter id="Col"/>
<parameter id="Col1"/>
<parameter id="Col2"/>
<parameter id="Col3"/>
<parameter id="Col4"/>
<parameter id="ForceL1LargerL2"/>
<parameter id="Length1"/>
<parameter id="Length2"/>
<parameter id="Phi"/>
<parameter id="Row"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
<parameter id="Row3"/>
<parameter id="Row4"/>
</parameters>
</docu>
</procedure>
<procedure name="reassign_pixel_values" access="local">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ValuesToChange" base_type="ctrl" dimension="0"/>
<par name="NewValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* This procedure sets all pixels of Image</c>
<c>* with the values given in ValuesToChange to the given value NewValue.</c>
<c>* </c>
<l>gen_empty_region (RegionToChange)</l>
<l>for IndexReset := 0 to |ValuesToChange| - 1 by 1</l>
<l>    threshold (Image, RegionClass, ValuesToChange[IndexReset], ValuesToChange[IndexReset])</l>
<l>    union2 (RegionToChange, RegionClass, RegionToChange)</l>
<l>endfor</l>
<l>overpaint_region (Image, RegionToChange, NewValue, 'fill')</l>
<l>ImageOut := Image</l>
<l>return ()</l>
</body>
<docu id="reassign_pixel_values">
<abstract lang="en_US">The procedure changes all values of ValuesToChange in Image to NewValue.
</abstract>
<chapters lang="de_DE">
<item>Bild</item>
<item>Manipulation</item>
</chapters>
<chapters lang="en_US">
<item>Image</item>
<item>Manipulation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Change value of ValuesToChange in Image to NewValue.</short>
<parameters>
<parameter id="Image">
<description lang="en_US">Image to be edited.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
<parameter id="ImageOut">
<description lang="en_US">Edited image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
<parameter id="NewValue">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">All pixels with the values given in ValuesToChange are set to this value.</description>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<value_max>9999999.000000</value_max>
<value_min>0.000000</value_min>
<values>
<item>0</item>
<item>0.5</item>
<item>1</item>
<item>100</item>
</values>
</parameter>
<parameter id="ValuesToChange">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pixels with values of ValuesToChange are set to NewValue.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="remove_invalid_3d_pixels" access="local">
<interface>
<io>
<par name="ImageX" base_type="iconic" dimension="0"/>
<par name="ImageY" base_type="iconic" dimension="0"/>
<par name="ImageZ" base_type="iconic" dimension="0"/>
<par name="Domain" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DomainOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="InvalidPixelValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>DomainOut := Domain</l>
<l>ImageXOut := ImageX</l>
<l>ImageYOut := ImageY</l>
<l>ImageZOut := ImageZ</l>
<l>reduce_domain (ImageXOut, DomainOut, ImageXOut)</l>
<l>reduce_domain (ImageYOut, DomainOut, ImageYOut)</l>
<l>reduce_domain (ImageZOut, DomainOut, ImageZOut)</l>
<l>threshold (ImageXOut, RegionInvalX, InvalidPixelValue, InvalidPixelValue)</l>
<l>threshold (ImageYOut, RegionInvalY, InvalidPixelValue, InvalidPixelValue)</l>
<l>threshold (ImageZOut, RegionInvalZ, InvalidPixelValue, InvalidPixelValue)</l>
<l>intersection (RegionInvalX, RegionInvalY, RegionInvalXY)</l>
<l>intersection (RegionInvalXY, RegionInvalZ, RegionInval)</l>
<l>complement (RegionInval, RegionInvalComplement)</l>
<l>intersection (DomainOut, RegionInvalComplement, DomainOut)</l>
<l>return ()</l>
</body>
<docu id="remove_invalid_3d_pixels">
<abstract lang="en_US">Remove invalid 3D pixels from a given domain.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Remove invalid 3D pixels from a given domain.</short>
<parameters>
<parameter id="Domain">
<multivalue>false</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="DomainOut">
<multivalue>false</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="ImageX">
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageY">
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageZ">
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="InvalidPixelValue">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Value that represents an invalid pixel in all given input images.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="compute_normals_xyz" access="local">
<interface>
<io>
<par name="x" base_type="iconic" dimension="0"/>
<par name="y" base_type="iconic" dimension="0"/>
<par name="z" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="NXImage" base_type="iconic" dimension="0"/>
<par name="NYImage" base_type="iconic" dimension="0"/>
<par name="NZImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Smoothing" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* For numerical reasons we scale the input data</c>
<l>Factor := 1e6</l>
<l>scale_image (x, xScaled, Factor, 0)</l>
<l>scale_image (y, yScaled, Factor, 0)</l>
<l>scale_image (z, zScaled, Factor, 0)</l>
<c></c>
<c>* Filter for diffs in row/col direction</c>
<l>MaskRow := [2, 1, 1.0, 1, -1]</l>
<l>MaskCol := [1, 2, 1.0, -1, 1]</l>
<l>convol_image (xScaled, xDiffRow, MaskRow, 'continued')</l>
<l>convol_image (xScaled, xDiffCol, MaskCol, 'continued')</l>
<l>convol_image (yScaled, yDiffRow, MaskRow, 'continued')</l>
<l>convol_image (yScaled, yDiffCol, MaskCol, 'continued')</l>
<l>convol_image (zScaled, zDiffRow, MaskRow, 'continued')</l>
<l>convol_image (zScaled, zDiffCol, MaskCol, 'continued')</l>
<c>* </c>
<c>* Calculate normal as cross product</c>
<l>mult_image (yDiffRow, zDiffCol, ImageResult, 1.0, 0)</l>
<l>mult_image (zDiffRow, yDiffCol, ImageResult2, -1.0, 0)</l>
<l>add_image (ImageResult, ImageResult2, NXRaw, 1.0, 0)</l>
<c>* </c>
<l>mult_image (xDiffRow, zDiffCol, ImageResult, -1.0, 0)</l>
<l>mult_image (zDiffRow, xDiffCol, ImageResult2, 1.0, 0)</l>
<l>add_image (ImageResult, ImageResult2, NYRaw, 1.0, 0)</l>
<c>* </c>
<l>mult_image (xDiffRow, yDiffCol, ImageResult, 1.0, 0)</l>
<l>mult_image (yDiffRow, xDiffCol, ImageResult2, -1.0, 0)</l>
<l>add_image (ImageResult, ImageResult2, NZRaw, 1.0, 0)</l>
<c></c>
<c>* Smooth</c>
<c>* -&gt; 5 is used as it is used in surface_normals_object_model_3d - 'xyz_mapping'</c>
<l>if (Smoothing)</l>
<l>    mean_image (NXRaw, NXRaw, 5, 5)</l>
<l>    mean_image (NYRaw, NYRaw, 5, 5)</l>
<l>    mean_image (NZRaw, NZRaw, 5, 5)</l>
<l>endif</l>
<c></c>
<c>* Normalize</c>
<l>mult_image (NXRaw, NXRaw, NXSquare, 1.0, 0)</l>
<l>mult_image (NYRaw, NYRaw, NYSquare, 1.0, 0)</l>
<l>mult_image (NZRaw, NZRaw, NZSquare, 1.0, 0)</l>
<l>add_image (NXSquare, NYSquare, ImageResult1, 1.0, 0)</l>
<l>add_image (ImageResult1, NZSquare, ImageResult2, 1.0, 0)</l>
<l>sqrt_image (ImageResult2, SqrtImage)</l>
<c>* </c>
<l>div_image (NXRaw, SqrtImage, NXImage, 1.0, 0)</l>
<l>div_image (NYRaw, SqrtImage, NYImage, 1.0, 0)</l>
<l>div_image (NZRaw, SqrtImage, NZImage, 1.0, 0)</l>
<l>return ()</l>
</body>
<docu id="compute_normals_xyz">
<abstract lang="en_US">Compute 3D normals.</abstract>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Compute 3D normals.</short>
<parameters>
<parameter id="NXImage">
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="NYImage">
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="NZImage">
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Smoothing">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_list>
<item>0</item>
<item>1</item>
</value_list>
<value_max>1</value_max>
</parameter>
<parameter id="x">
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="y">
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="z">
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_open_window_fit_size">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="WidthLimit" base_type="ctrl" dimension="0"/>
<par name="HeightLimit" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure open a new graphic window</c>
<c>* such that it fits into the limits specified by WidthLimit</c>
<c>* and HeightLimit, but also maintains the correct aspect ratio</c>
<c>* given by Width and Height.</c>
<c>* </c>
<c>* If it is impossible to match the minimum and maximum extent requirements</c>
<c>* at the same time (f.e. if the image is very long but narrow),</c>
<c>* the maximum value gets a higher priority.</c>
<c>* </c>
<c>* Parse input tuple WidthLimit</c>
<l>if (|WidthLimit| == 0 or WidthLimit &lt; 0)</l>
<l>    MinWidth := 500</l>
<l>    MaxWidth := 800</l>
<l>elseif (|WidthLimit| == 1)</l>
<l>    MinWidth := 0</l>
<l>    MaxWidth := WidthLimit</l>
<l>else</l>
<l>    MinWidth := WidthLimit[0]</l>
<l>    MaxWidth := WidthLimit[1]</l>
<l>endif</l>
<c>* Parse input tuple HeightLimit</c>
<l>if (|HeightLimit| == 0 or HeightLimit &lt; 0)</l>
<l>    MinHeight := 400</l>
<l>    MaxHeight := 600</l>
<l>elseif (|HeightLimit| == 1)</l>
<l>    MinHeight := 0</l>
<l>    MaxHeight := HeightLimit</l>
<l>else</l>
<l>    MinHeight := HeightLimit[0]</l>
<l>    MaxHeight := HeightLimit[1]</l>
<l>endif</l>
<c>* </c>
<c>* Test, if window size has to be changed.</c>
<l>ResizeFactor := 1</l>
<c>* First, expand window to the minimum extents (if necessary).</c>
<l>if (MinWidth &gt; Width or MinHeight &gt; Height)</l>
<l>    ResizeFactor := max([real(MinWidth) / Width,real(MinHeight) / Height])</l>
<l>endif</l>
<l>TempWidth := Width * ResizeFactor</l>
<l>TempHeight := Height * ResizeFactor</l>
<c>* Then, shrink window to maximum extents (if necessary).</c>
<l>if (MaxWidth &lt; TempWidth or MaxHeight &lt; TempHeight)</l>
<l>    ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])</l>
<l>endif</l>
<l>WindowWidth := Width * ResizeFactor</l>
<l>WindowHeight := Height * ResizeFactor</l>
<c>* Resize window</c>
<l>dev_open_window (Row, Column, WindowWidth, WindowHeight, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>return ()</l>
</body>
<docu id="dev_open_window_fit_size">
<abstract lang="en_US">The procedure &lt;proc:dev_open_window_fit_size&gt; opens a new graphics window with a given minimum and maximum extent such that it preserves the aspect ratio of the given image size.

The position of the new graphics window is given by the parameters Row and Column, which define the position of the upper left corner of the graphics window.

The size of the new graphics window is determined such that the limits given in WidthLimit and HeightLimit are fulfilled and that the aspect ratio of the image size that is given in Width and Height is preserved. To restrict only the maximum size of the new graphics window, only one value must be passed in WidthLimit and HeightLimit, respectively. To restrict both the minimum and the maximum size, WidthLimit and HeightLimit must contain a tuple with two elements, each. The first element defines the minimum size and the second element defines the maximum size of the new graphics window.

If it is not possible to set the window size such that all limits (minimum and maximum width and height as well as the aspect ratio of the given image size) are fulfilled, the limit for the minimum window size is neglected.

If WidthLimit is empty or negative, the following default value is used: *[500,800]*.\
If HeightLimit is empty or negative, the following default value is used: *[400,600]*.</abstract>
<alternatives>
<item>dev_open_window_fit_image</item>
<item>dev_open_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">*
* Open a new graphics window with the default size limits.
dev_open_window_fit_size (0, 0, 640, 480, -1, -1, WindowHandle1)
*
* Open a new graphics window at the position (50,50) with a
* minimum size of 300 x 200 and a maximum size of 600 x 400.
* The window is intended to display a large image with a width
* of 2000 pixel and a height of 15000 pixel while preserving the
* aspect ratio. Note that in this case the minimum width is
* neglected.
dev_open_window_fit_size (50, 50, 2000, 15000, [300,600], [400,800],
                          WindowHandle2)</example>
<keywords lang="de_DE">
<item>Grafikfenster öffnen</item>
<item>Größe eines Grafikfensters setzen</item>
</keywords>
<keywords lang="en_US">
<item>open graphics window</item>
<item>set size of graphics window</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_resize_window_fit_size</item>
<item>dev_resize_window_fit_image</item>
</see_also>
<short lang="en_US">Open a new graphics window that preserves the aspect ratio of the given image size.</short>
<successor>
<item>dev_display</item>
</successor>
<parameters>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Column coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<description lang="en_US">The height of the image to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>480</item>
<item>600</item>
<item>768</item>
<item>960</item>
<item>1050</item>
<item>1200</item>
<item>1536</item>
<item>2100</item>
<item>2400</item>
<item>4800</item>
</values>
</parameter>
<parameter id="HeightLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window height.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Row coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<description lang="en_US">The width of the image to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>640</item>
<item>800</item>
<item>1024</item>
<item>1280</item>
<item>1400</item>
<item>1600</item>
<item>2048</item>
<item>2800</item>
<item>3200</item>
<item>6400</item>
</values>
</parameter>
<parameter id="WidthLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window width.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the new graphics window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_arrow_object_model_3d">
<interface>
<ic>
<par name="ArrowThickness" base_type="ctrl" dimension="0"/>
<par name="ArrowStart" base_type="ctrl" dimension="0"/>
<par name="ArrowEnd" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DArrow" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure draws an arrow that starts at the point ArrowStart and ends at ArrowEnd.</c>
<c>* </c>
<c>* Get parameters.</c>
<l>DirectionVector := ArrowEnd[0:2] - ArrowStart[0:2]</l>
<l>ArrowLength := sqrt(DirectionVector[0] * DirectionVector[0] + DirectionVector[1] * DirectionVector[1] + DirectionVector[2] * DirectionVector[2])</l>
<l>ConeRadius := 2.0 * ArrowThickness</l>
<l>ConeLength := min([2.0 * ConeRadius,ArrowLength * 0.9])</l>
<l>CylinderLength := ArrowLength - ConeLength</l>
<c>* </c>
<c>* Create cone.</c>
<l>pi := rad(180)</l>
<l>X := 0</l>
<l>Y := 0</l>
<l>Z := CylinderLength + ConeLength</l>
<l>for Index := 0 to 2 * pi by 0.1</l>
<l>    X := [X,ConeRadius * cos(Index)]</l>
<l>    Y := [Y,ConeRadius * sin(Index)]</l>
<l>    Z := [Z,CylinderLength]</l>
<l>endfor</l>
<l>gen_object_model_3d_from_points (X, Y, Z, OM3DConeTmp)</l>
<l>convex_hull_object_model_3d (OM3DConeTmp, OM3DCone)</l>
<l>clear_object_model_3d (OM3DConeTmp)</l>
<c>* </c>
<c>* Create cylinder.</c>
<l>X := []</l>
<l>Y := []</l>
<l>for Index := 0 to 2 * pi by 0.1</l>
<l>    X := [X,ArrowThickness * cos(Index)]</l>
<l>    Y := [Y,ArrowThickness * sin(Index)]</l>
<l>endfor</l>
<l>tuple_gen_const (|Y|, 0, ZZero)</l>
<l>tuple_gen_const (|Y|, CylinderLength, ZTop)</l>
<l>gen_object_model_3d_from_points ([X,X], [Y,Y], [ZZero,ZTop], OM3DCylinderTmp)</l>
<l>convex_hull_object_model_3d (OM3DCylinderTmp, OM3DCylinder)</l>
<l>clear_object_model_3d (OM3DCylinderTmp)</l>
<c>* </c>
<c>* Union cone and cylinder Create arrow.</c>
<l>union_object_model_3d ([OM3DCone,OM3DCylinder], 'points_surface', OM3DArrowTmp)</l>
<l>clear_object_model_3d (OM3DCone)</l>
<l>clear_object_model_3d (OM3DCylinder)</l>
<l>Scale := CylinderLength / ArrowLength</l>
<l>OriginX := [0, 0, 0]</l>
<l>OriginY := [0, 0, 0]</l>
<l>OriginZ := [0,CylinderLength,ArrowLength]</l>
<l>TargetX := [ArrowStart[0],ArrowStart[0] + Scale * DirectionVector[0],ArrowEnd[0]]</l>
<l>TargetY := [ArrowStart[1],ArrowStart[1] + Scale * DirectionVector[1],ArrowEnd[1]]</l>
<l>TargetZ := [ArrowStart[2],ArrowStart[2] + Scale * DirectionVector[2],ArrowEnd[2]]</l>
<l>vector_to_hom_mat3d ('rigid', OriginX, OriginY, OriginZ, TargetX, TargetY, TargetZ, HomMat3D)</l>
<l>affine_trans_object_model_3d (OM3DArrowTmp, HomMat3D, OM3DArrow)</l>
<l>clear_object_model_3d (OM3DArrowTmp)</l>
<l>return ()</l>
</body>
<docu id="gen_arrow_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="ArrowEnd">
<default_type>real</default_type>
<default_value>[0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0]</default_value>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowStart">
<default_type>real</default_type>
<default_value>[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0]</default_value>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowThickness">
<default_type>real</default_type>
<default_value>0.005</default_value>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DArrow">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_division">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with distortions modeled by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_division',Focus,Kappa,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_division">
<abstract lang="en_US">&lt;proc:gen_cam_par_area_scan_division&gt; generates the camera parameter tuple CameraParam for an area scan camera with distortions modeled by the division model.  For this, the camera parameters must be passed in Focus [m], Kappa [m^-2], Sx [m/px], Sy [m/px], Cx [px], Cy [px], ImageWidth [px], and ImageHeight [px], where we indicate the HALCON default units in brackets. For a detailed explanation of the parameters, see the reference manual chapter &lt;toc:calibration&gt;.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_cam_par_data">
<interface>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
<par name="ParamName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ParamValue" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* get_cam_par_data returns in ParamValue the value of the</c>
<c>* parameter that is given in ParamName from the tuple of</c>
<c>* camera parameters that is given in CameraParam.</c>
<c>* </c>
<c>* Get the parameter names that correspond to the</c>
<c>* elements in the input camera parameter tuple.</c>
<l>get_cam_par_names (CameraParam, CameraType, CameraParamNames)</l>
<c>* </c>
<c>* Find the index of the requested camera data and return</c>
<c>* the corresponding value.</c>
<l>ParamValue := []</l>
<l>for Index := 0 to |ParamName| - 1 by 1</l>
<l>    ParamNameInd := ParamName[Index]</l>
<l>    if (ParamNameInd == 'camera_type')</l>
<l>        ParamValue := [ParamValue,CameraType]</l>
<l>        continue</l>
<l>    endif</l>
<l>    I := find(CameraParamNames,ParamNameInd)</l>
<l>    if (I != -1)</l>
<l>        ParamValue := [ParamValue,CameraParam[I]]</l>
<l>    else</l>
<l>        throw ('Unknown camera parameter ' + ParamNameInd)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_cam_par_data">
<abstract lang="en_US">&lt;proc:get_cam_par_data&gt; returns the value ParamValue of the camera parameter ParamName from the camera parameter tuple CameraParam. The following parameter names can be queried:
- *'camera_type'*
- *'focus'*
- *'magnification'*
- *'kappa'*
- *'k1'*
- *'k2'*
- *'k3'*
- *'p1'*
- *'p2'*
- *'image_plane_dist'*
- *'tilt'*
- *'rot'*
- *'sx'*
- *'sy'*
- *'cx'*
- *'cy'*
- *'image_width'*
- *'image_height'*
- *'vx'*
- *'vy'*
- *'vz'*.

If the camera type does not support the requested value, an exception is raised.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam)
get_cam_par_data (CameraParam, 'image_width', ImageWidth)
get_cam_par_data (CameraParam, 'image_height', ImageHeight)
gen_image_const (Image, 'byte', ImageWidth, ImageHeight)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Get the value of a specified camera parameter from the camera parameter tuple.</short>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ParamName">
<default_type>string</default_type>
<default_value>'image_width'</default_value>
<description lang="en_US">Name of the camera parameter for that the value should be returned.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'camera_type'</item>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</value_list>
</parameter>
<parameter id="ParamValue">
<default_type>real</default_type>
<description lang="en_US">Value of the requested camera parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="set_cam_par_data">
<interface>
<ic>
<par name="CameraParamIn" base_type="ctrl" dimension="0"/>
<par name="ParamName" base_type="ctrl" dimension="0"/>
<par name="ParamValue" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParamOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* set_cam_par_data sets the value of the parameter that</c>
<c>* is given in ParamName in the tuple of camera parameters</c>
<c>* given in CameraParamIn. The modified camera parameters</c>
<c>* are returned in CameraParamOut.</c>
<c>* </c>
<c>* Check for consistent length of input parameters</c>
<l>if (|ParamName| != |ParamValue|)</l>
<l>    throw ('Different number of values in ParamName and ParamValue')</l>
<l>endif</l>
<c>* First, get the parameter names that correspond to the</c>
<c>* elements in the input camera parameter tuple.</c>
<l>get_cam_par_names (CameraParamIn, CameraType, CameraParamNames)</l>
<c>* </c>
<c>* Find the index of the requested camera data and return</c>
<c>* the corresponding value.</c>
<l>CameraParamOut := CameraParamIn</l>
<l>for Index := 0 to |ParamName| - 1 by 1</l>
<l>    ParamNameInd := ParamName[Index]</l>
<l>    I := find(CameraParamNames,ParamNameInd)</l>
<l>    if (I != -1)</l>
<l>        CameraParamOut[I] := ParamValue[Index]</l>
<l>    else</l>
<l>        throw ('Wrong ParamName ' + ParamNameInd)</l>
<l>    endif</l>
<c>    * Check the consistency of focus and telecentricity</c>
<l>    if (ParamNameInd == 'focus')</l>
<l>        IsTelecentric := strstr(CameraType,'telecentric') != -1 and strstr(CameraType,'image_side_telecentric') == -1</l>
<l>        if (IsTelecentric)</l>
<l>            throw ('Focus for telecentric lenses is always 0, and hence, cannot be changed.')</l>
<l>        endif</l>
<l>        if (not IsTelecentric and ParamValue[Index] == 0.0)</l>
<l>            throw ('Focus for non-telecentric lenses must not be 0.')</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="set_cam_par_data">
<abstract lang="en_US">&lt;proc:set_cam_par_data&gt; sets the value of ParamName in the camera parameter tuple CameraParamIn. The modified camera parameters  are returned in CameraParamOut. The following parameter names can be set:

- *'focus'* [m]
- *'magnification'* [-]
- *'kappa'* [m&lt;sup&gt;-2&lt;/sup&gt;]
- *'k1'* [m&lt;sup&gt;-2&lt;/sup&gt;]
- *'k2'* [m&lt;sup&gt;-4&lt;/sup&gt;]
- *'k3'* [m&lt;sup&gt;-6&lt;/sup&gt;]
- *'p1'* [m&lt;sup&gt;-1&lt;/sup&gt;]
- *'p2'* [ m&lt;sup&gt;-1&lt;/sup&gt;]
- *'image_plane_dist'* [m]
- *'tilt'* [deg]
- *'rot'* [deg]
- *'sx'* [m/px]
- *'sy'* [m/px]
- *'cx'* [px]
- *'cy'* [px]
- *'vx'* [m/scanline]
- *'vy'* [m/scanline]
- *'vz'* [m/scanline]
- *'image_width'* [px]
- *'image_height'* [px]

If the camera type does not support the requested value, an exception is raised.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam)
get_cam_par_data (CameraParam, 'sx', Sx)
get_cam_par_data (CameraParam, 'sy', Sy)
get_cam_par_data (CameraParam, 'cx', Cx)
get_cam_par_data (CameraParam, 'cy', Cy)
get_cam_par_data (CameraParam, 'image_width', ImageWidth)
get_cam_par_data (CameraParam, 'image_height', ImageHeight)
*
set_cam_par_data (CameraParam, 'sx', 2.0*Sx, CameraParam)
set_cam_par_data (CameraParam, 'sy', 2.0*Sy, CameraParam)
set_cam_par_data (CameraParam, 'cx', 0.5*Cx, CameraParam)
set_cam_par_data (CameraParam, 'cy', 0.5*Cy, CameraParam)
set_cam_par_data (CameraParam, 'image_width', 0.5*ImageWidth, CameraParam)
set_cam_par_data (CameraParam, 'image_height', 0.5*ImageHeight, CameraParam)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Set the value of a specified camera parameter in the camera parameter tuple.</short>
<parameters>
<parameter id="CameraParamIn">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="CameraParamOut">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ParamName">
<default_type>string</default_type>
<default_value>'image_width'</default_value>
<description lang="en_US">Name of the camera parameter for that the value should be set.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</value_list>
</parameter>
<parameter id="ParamValue">
<default_type>real</default_type>
<description lang="en_US">Value of the camera parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_object_models_center">
<interface>
<ic>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Center" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Compute the mean of all model centers (weighted by the diameter of the object models)</c>
<l>Diameters := gen_tuple_const(|ObjectModel3DID|,0.0)</l>
<l>for Index := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>    try</l>
<l>        get_object_model_3d_params (ObjectModel3DID[Index], 'diameter_axis_aligned_bounding_box', Diameter)</l>
<l>        get_object_model_3d_params (ObjectModel3DID[Index], 'center', C)</l>
<l>        Diameters[Index] := Diameter</l>
<l>    catch (Exception)</l>
<c>        * Object model is empty, has no center etc. -&gt; ignore it by leaving its diameter at zero</c>
<l>    endtry</l>
<l>endfor</l>
<c></c>
<l>if (sum(Diameters) &gt; 0)</l>
<c>    * Normalize Diameter to use it as weights for a weighted mean of the individual centers</c>
<l>    MD := mean(select_mask(Diameters,Diameters [&gt;] 0))</l>
<l>    if (MD &gt; 1e-10)</l>
<l>        Weight := Diameters / MD</l>
<l>    else</l>
<l>        Weight := Diameters</l>
<l>    endif</l>
<l>    SumW := sum(Weight)</l>
<l>    if (SumW &lt; 1e-10)</l>
<l>        Weight := gen_tuple_const(|Weight|,1.0)</l>
<l>        SumW := sum(Weight)</l>
<l>    endif</l>
<l>    Center := [0, 0, 0]</l>
<l>    for Index := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>        if (Diameters[Index] &gt; 0)</l>
<l>            ObjectModel3DIDSelected := ObjectModel3DID[Index]</l>
<l>            get_object_model_3d_params (ObjectModel3DIDSelected, 'center', C)</l>
<l>            Center[0] := Center[0] + C[0] * Weight[Index]</l>
<l>            Center[1] := Center[1] + C[1] * Weight[Index]</l>
<l>            Center[2] := Center[2] + C[2] * Weight[Index]</l>
<l>        endif</l>
<l>    endfor</l>
<l>    InvSum := 1.0 / SumW</l>
<l>    Center[0] := Center[0] * InvSum</l>
<l>    Center[1] := Center[1] * InvSum</l>
<l>    Center[2] := Center[2] * InvSum</l>
<l>else</l>
<l>    Center := []</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_object_models_center">
<abstract lang="en_US">&lt;proc:get_object_models_center&gt; computes the center of all given 3D object models.

The center is computed as the weighted mean of all centers of the individual 3D object models. The weighting ensures that larger 3D object models have an higher impact on the calculated center.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D, Status)
CamParam := [0.1,0,6e-6,6e-6,256,256,512,512]
dev_resize_window_fit_size (0, 0, CamParam[6]-1, CamParam[7]-1, -1, -1)
get_object_models_center (ObjectModel3D, Center)
create_pose (-Center[0], -Center[1], -Center[2], 135, 0, 0, \
             'Rp+T', 'gba', 'point', PoseIn)
determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, \
                                 PoseEstimated)
dev_get_window (WindowHandle)
disp_object_model_3d (WindowHandle, ObjectModel3D, \
                      CamParam, PoseEstimated, [], [])</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_object_model_3d</item>
</predecessor>
<see_also>
<item>determine_optimum_pose_distance</item>
<item>disp_object_model_3d</item>
</see_also>
<short lang="en_US">Compute the center of all given 3D object models.</short>
<successor>
<item>create_pose</item>
<item>determine_optimum_pose_distance</item>
</successor>
<parameters>
<parameter id="Center">
<default_type>real</default_type>
<description lang="en_US">Center of the 3D object models.</description>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="determine_optimum_pose_distance">
<interface>
<ic>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="ImageCoverage" base_type="ctrl" dimension="0"/>
<par name="PoseIn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PoseOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Determine the optimum distance of the object to obtain</c>
<c>* a reasonable visualization</c>
<c>* </c>
<l>Rows := []</l>
<l>Cols := []</l>
<l>MinMinZ := 1e30</l>
<l>BB := []</l>
<l>for Index := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>    try</l>
<l>        get_object_model_3d_params (ObjectModel3DID[Index], 'bounding_box1', CurrBB)</l>
<l>        BB := [BB,CurrBB]</l>
<l>    catch (Exception)</l>
<c>        * 3D object model is empty / has no bounding box -&gt; ignore it</c>
<l>    endtry</l>
<l>endfor</l>
<l>if (sum([abs(BB),0]) == 0.0)</l>
<l>    BB := [-abs(rand(3) * 1e-20),abs(rand(3) * 1e-20)]</l>
<l>endif</l>
<c>* Calculate diameter over all objects to be visualized</c>
<l>Seq := [0:6:|BB| - 1]</l>
<l>DXMax := max(BB[Seq + 3]) - min(BB[Seq])</l>
<l>DYMax := max(BB[Seq + 4]) - min(BB[Seq + 1])</l>
<l>DZMax := max(BB[Seq + 5]) - min(BB[Seq + 2])</l>
<l>Diameter := sqrt(DXMax * DXMax + DYMax * DYMax + DZMax * DZMax)</l>
<c>* Allow the visualization of single points or extremely small objects</c>
<l>ZAdd := 0.0</l>
<l>if (max(Diameter) &lt; 1e-10)</l>
<l>    ZAdd := 0.01</l>
<l>endif</l>
<c>* Set extremely small diameters to 1e-10 to avoid CZ == 0.0, which would lead</c>
<c>* to projection errors</c>
<l>if (min(Diameter) &lt; 1e-10)</l>
<l>    Diameter := Diameter - sgn(sgn(Diameter - 1e-10) - 1) * 1e-10</l>
<l>endif</l>
<c>* Move all points in front of the camera</c>
<l>BBX0 := BB[Seq + 0]</l>
<l>BBX1 := BB[Seq + 3]</l>
<l>BBY0 := BB[Seq + 1]</l>
<l>BBY1 := BB[Seq + 4]</l>
<l>BBZ0 := BB[Seq + 2]</l>
<l>BBZ1 := BB[Seq + 5]</l>
<l>X := [BBX0,BBX0,BBX0,BBX0,BBX1,BBX1,BBX1,BBX1]</l>
<l>Y := [BBY0,BBY0,BBY1,BBY1,BBY0,BBY0,BBY1,BBY1]</l>
<l>Z := [BBZ0,BBZ1,BBZ0,BBZ1,BBZ0,BBZ1,BBZ0,BBZ1]</l>
<l>pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>affine_trans_point_3d (HomMat3DIn, X, Y, Z, QX_In, QY_In, QZ_In)</l>
<l>pose_compose ([0, 0,-min(QZ_In) + 2 * max(Diameter),0, 0, 0, 0], PoseIn, PoseInter)</l>
<l>pose_to_hom_mat3d (PoseInter, HomMat3D)</l>
<c>* Determine the maximum extension of the projection</c>
<l>affine_trans_point_3d (HomMat3D, X, Y, Z, QX, QY, QZ)</l>
<l>project_3d_point (QX, QY, QZ, CamParam, Rows, Cols)</l>
<l>MinMinZ := min(QZ)</l>
<l>get_cam_par_data (CamParam, 'cx', Cx)</l>
<l>get_cam_par_data (CamParam, 'cy', Cy)</l>
<l>DR := Rows - Cy</l>
<l>DC := Cols - Cx</l>
<l>DR := max(DR) - min(DR)</l>
<l>DC := max(DC) - min(DC)</l>
<l>MaxDist := sqrt(DR * DR + DC * DC)</l>
<c>* </c>
<l>if (MaxDist &lt; 1e-10)</l>
<c>    * If the object has no extension in the above projection (looking along</c>
<c>    * a line), we determine the extension of the object in a rotated view</c>
<l>    hom_mat3d_rotate_local (HomMat3D, rad(90), 'x', HomMat3DRotate)</l>
<l>    affine_trans_point_3d (HomMat3DRotate, X, Y, Z, QX, QY, QZ)</l>
<l>    project_3d_point (QX, QY, QZ, CamParam, Rows, Cols)</l>
<l>    DR := Rows - Cy</l>
<l>    DC := Cols - Cx</l>
<l>    DR := max(DR) - min(DR)</l>
<l>    DC := max(DC) - min(DC)</l>
<l>    MaxDist := max([MaxDist,sqrt(DR * DR + DC * DC)])</l>
<l>endif</l>
<c>* </c>
<l>get_cam_par_data (CamParam, 'image_width', ImageWidth)</l>
<l>get_cam_par_data (CamParam, 'image_height', ImageHeight)</l>
<l>MinImageSize := min([ImageWidth,ImageHeight])</l>
<c>* </c>
<l>Z := PoseInter[2]</l>
<l>Zs := MinMinZ</l>
<l>ZDiff := Z - Zs</l>
<l>ScaleZ := MaxDist / (0.5 * MinImageSize * ImageCoverage * 2.0)</l>
<l>ZNew := ScaleZ * Zs + ZDiff + ZAdd</l>
<l>PoseOut := replace(PoseInter,2,ZNew)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="determine_optimum_pose_distance">
<abstract lang="en_US">&lt;proc:determine_optimum_pose_distance&gt; determines the optimum translation in z direction to obtain a reasonable visualization of the given 3D object models, e.g., with &lt;op:disp_object_model_3d&gt;.

Based on the given camera parameters (CamParam), which also define the size of the image into which the 3D object models are to be projected and the requested image coverage, the necessary translation of the 3D object models in z direction, i.e., the third element of the pose, is calculated.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D, Status)
CamParam := [0.1,0,6e-6,6e-6,256,256,512,512]
dev_resize_window_fit_size (0, 0, CamParam[6]-1, CamParam[7]-1, -1, -1)
get_object_models_center (ObjectModel3D, Center)
create_pose (-Center[0], -Center[1], -Center[2], 135, 0, 0, \
             'Rp+T', 'gba', 'point', PoseIn)
determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, \
                                 PoseEstimated)
dev_get_window (WindowHandle)
disp_object_model_3d (WindowHandle, ObjectModel3D, \
                      CamParam, PoseEstimated, [], [])</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>get_object_models_center</item>
<item>create_pose</item>
</predecessor>
<short lang="en_US">Determine the optimum distance of the object to obtain a reasonable visualization</short>
<successor>
<item>disp_object_model_3d</item>
<item>render_object_model_3d</item>
</successor>
<parameters>
<parameter id="CamParam">
<default_type>real</default_type>
<description lang="en_US">Camera parameters of the scene.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageCoverage">
<default_type>real</default_type>
<default_value>0.9</default_value>
<description lang="en_US">Desired image coverage of the 3D object models to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PoseIn">
<default_type>real</default_type>
<description lang="en_US">3D pose of the objects.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="PoseOut">
<default_type>real</default_type>
<description lang="en_US">Pose with adapted translation in z direction.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_trackball_center_fixed" access="local">
<interface>
<ic>
<par name="SelectedObject" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterRow" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterCol" base_type="ctrl" dimension="0"/>
<par name="TrackballRadiusPixel" base_type="ctrl" dimension="0"/>
<par name="Scene3D" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TBCenter" base_type="ctrl" dimension="0"/>
<par name="TBSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Determine the trackball center for the fixed trackball</c>
<l>NumModels := |ObjectModel3DID|</l>
<l>get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>get_cam_par_data (CamParam, 'image_height', Height)</l>
<c>* </c>
<c>* Project the selected objects</c>
<l>SelectPose := []</l>
<l>for Index1 := 0 to |SelectedObject| - 1 by 1</l>
<l>    SelectPose := [SelectPose,gen_tuple_const(7,SelectedObject[Index1])]</l>
<l>    if (SelectedObject[Index1] == 0)</l>
<l>        set_scene_3d_instance_param (Scene3D, Index1, 'visible', 'false')</l>
<l>    endif</l>
<l>endfor</l>
<l>set_scene_3d_param (Scene3D, 'depth_persistence', 'true')</l>
<l>display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>set_scene_3d_param (Scene3D, 'visible', 'true')</l>
<c>* </c>
<c>* determine the depth of the object point that appears closest to the trackball</c>
<c>* center</c>
<l>gen_region_points (RegionCenter, TrackballCenterRow, TrackballCenterCol)</l>
<l>distance_transform (RegionCenter, DistanceImage, 'chamfer-3-4-unnormalized', 'false', Width, Height)</l>
<l>get_domain (DistanceImage, Domain)</l>
<l>get_region_points (Domain, Rows, Columns)</l>
<l>get_grayval (DistanceImage, Rows, Columns, Grayval)</l>
<l>tuple_sort_index (Grayval, IndicesG)</l>
<l>get_display_scene_3d_info (WindowHandleBuffer, Scene3D, subset(Rows,IndicesG), subset(Columns,IndicesG), 'depth', Value)</l>
<l>tuple_find (sgn(Value), 1, Pos)</l>
<c>* </c>
<l>set_scene_3d_param (Scene3D, 'depth_persistence', 'false')</l>
<c>* </c>
<c>* </c>
<c>* set TBCenter</c>
<l>if (Pos != -1)</l>
<c>    * if the object is visible in the image</c>
<l>    TBCenter := [0, 0,Value[Pos[0]]]</l>
<l>else</l>
<c>    * if the object is not visible in the image, set the z coordinate to -1</c>
<c>    * to indicate, that the previous z value should be used instead</c>
<l>    TBCenter := [0, 0, -1]</l>
<l>endif</l>
<c>* </c>
<l>if (max(SelectedObject) != 0)</l>
<l>    TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>else</l>
<l>    TBCenter := []</l>
<l>    TBSize := 0</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_trackball_center_fixed">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface').</short>
<parameters>
<parameter id="CamParam"/>
<parameter id="GenParamName"/>
<parameter id="GenParamValue"/>
<parameter id="ObjectModel3DID"/>
<parameter id="Poses"/>
<parameter id="Scene3D"/>
<parameter id="SelectedObject"/>
<parameter id="TBCenter"/>
<parameter id="TBSize"/>
<parameter id="TrackballCenterCol"/>
<parameter id="TrackballCenterRow"/>
<parameter id="TrackballRadiusPixel"/>
<parameter id="WindowHandleBuffer"/>
</parameters>
</docu>
</procedure>
<procedure name="disp_message">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="String" base_type="ctrl" dimension="0"/>
<par name="CoordSystem" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Box" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays text in a graphics window.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The WindowHandle of the graphics window, where</c>
<c>*    the message should be displayed.</c>
<c>* String: A tuple of strings containing the text messages to be displayed.</c>
<c>* CoordSystem: If set to 'window', the text position is given</c>
<c>*    with respect to the window coordinate system.</c>
<c>*    If set to 'image', image coordinates are used.</c>
<c>*    (This may be useful in zoomed images.)</c>
<c>* Row: The row coordinate of the desired text position.</c>
<c>*    You can pass a single value or a tuple of values.</c>
<c>*    See the explanation below.</c>
<c>*    Default: 12.</c>
<c>* Column: The column coordinate of the desired text position.</c>
<c>*    You can pass a single value or a tuple of values.</c>
<c>*    See the explanation below.</c>
<c>*    Default: 12.</c>
<c>* Color: defines the color of the text as string.</c>
<c>*    If set to [] or '' the currently set color is used.</c>
<c>*    If a tuple of strings is passed, the colors are used cyclically</c>
<c>*    for every text position defined by Row and Column,</c>
<c>*    or every new text line in case of |Row| == |Column| == 1.</c>
<c>* Box: A tuple controlling a possible box surrounding the text.</c>
<c>*    Its entries:</c>
<c>*    - Box[0]: Controls the box and its color. Possible values:</c>
<c>*      -- 'true' (Default): An orange box is displayed.</c>
<c>*      -- 'false': No box is displayed.</c>
<c>*      -- color string: A box is displayed in the given color, e.g., 'white', '#FF00CC'.</c>
<c>*    - Box[1] (Optional): Controls the shadow of the box. Possible values:</c>
<c>*      -- 'true' (Default): A shadow is displayed in</c>
<c>*                darker orange if Box[0] is not a color and in 'white' otherwise.</c>
<c>*      -- 'false': No shadow is displayed.</c>
<c>*      -- color string: A shadow is displayed in the given color, e.g., 'white', '#FF00CC'.</c>
<c>* </c>
<c>* It is possible to display multiple text strings in a single call.</c>
<c>* In this case, some restrictions apply on the</c>
<c>* parameters String, Row, and Column:</c>
<c>* They can only have either 1 entry or n entries.</c>
<c>* Behavior in the different cases:</c>
<c>*    - Multiple text positions are specified, i.e.,</c>
<c>*        - |Row| == n, |Column| == n</c>
<c>*        - |Row| == n, |Column| == 1</c>
<c>*        - |Row| == 1, |Column| == n</c>
<c>*      In this case we distinguish:</c>
<c>*        - |String| == n: Each element of String is displayed</c>
<c>*                         at the corresponding position.</c>
<c>*        - |String| == 1: String is displayed n times</c>
<c>*                         at the corresponding positions.</c>
<c>*    - Exactly one text position is specified,</c>
<c>*       i.e., |Row| == |Column| == 1:</c>
<c>*       Each element of String is display in a new textline.</c>
<c>* </c>
<c>* </c>
<c>* Convert the parameters for disp_text.</c>
<l>if (Row == [] or Column == [])</l>
<l>    return ()</l>
<l>endif</l>
<l>if (Row == -1)</l>
<l>    Row := 12</l>
<l>endif</l>
<l>if (Column == -1)</l>
<l>    Column := 12</l>
<l>endif</l>
<c>* </c>
<c>* Convert the parameter Box to generic parameters.</c>
<l>GenParamName := []</l>
<l>GenParamValue := []</l>
<l>if (|Box| &gt; 0)</l>
<l>    if (Box[0] == 'false')</l>
<c>        * Display no box</c>
<l>        GenParamName := [GenParamName,'box']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[0] != 'true')</l>
<c>        * Set a color other than the default.</c>
<l>        GenParamName := [GenParamName,'box_color']</l>
<l>        GenParamValue := [GenParamValue,Box[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>if (|Box| &gt; 1)</l>
<l>    if (Box[1] == 'false')</l>
<c>        * Display no shadow.</c>
<l>        GenParamName := [GenParamName,'shadow']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[1] != 'true')</l>
<c>        * Set a shadow color other than the default.</c>
<l>        GenParamName := [GenParamName,'shadow_color']</l>
<l>        GenParamValue := [GenParamValue,Box[1]]</l>
<l>    endif</l>
<l>endif</l>
<c>* Restore default CoordSystem behavior.</c>
<l>if (CoordSystem != 'window')</l>
<l>    CoordSystem := 'image'</l>
<l>endif</l>
<c>* </c>
<l>if (Color == '')</l>
<c>    * disp_text does not accept an empty string for Color.</c>
<l>    Color := []</l>
<l>endif</l>
<c>* </c>
<l>disp_text (WindowHandle, String, CoordSystem, Row, Column, Color, GenParamName, GenParamValue)</l>
<l>return ()</l>
</body>
<docu id="disp_message">
<abstract lang="en_US">This procedure displays text in a graphics window WindowHandle at the specified positions (Row,Column).

If only a single position is defined, one text line is displayed for each element of String. Also, '\n' will be interpreted as a newline character, i.e., a line break is performed.

If multiple positions are defined, only a single string or one string for each position is allowed in String. In this case, line breaks have to be forced with '\n'.
See also the inline documentation.

The position of the text may be specified in window coordinates (CoordSystem = *'window'*) or in image coordinates (CoordSystem = *'image'*), which is useful when using zoomed images.

In addition to supplying (Row, Column) coordinates, it is also possible to pass predefined values to Row and Column to display the text at a fixed position in the window (only if CoordSystem = *'window'*).

The parameter Color also accepts tuples of values. In that case, the specified colors are used cyclically for every new text position or for every new textline if a single position is used. If set to *[]* or *''* the currently set color is used.

Box: A tuple controlling a possible box surrounding the text. Its entries:
   - Box[0]: Controls the box and its color. Possible values:
      - *'true'* (default): An orange box is displayed.
      - *'false'*: No box is displayed.
      - color string: A box is displayed in the given color, e.g., *'white'*, *'#FF00CC'*.
   - Box[1] (Optional): Controls the shadow of the box. Possible values:
      - *'true'* (default): A shadow is displayed in darker orange if Box[0] is not a color and in *'white'* otherwise.
      - *'false'*: No shadow is displayed.
      - color string: A shadow is displayed in the given color, e.g., *'white'*, *'#FF00CC'*.</abstract>
<alternatives>
<item>disp_text</item>
<item>write_string</item>
<item>disp_continue_message</item>
</alternatives>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
disp_message (WindowHandle, ['Hello','world!'], 'window', 12, 12, ['black','blue'], 'true')
disp_message (WindowHandle, ['Hello','world!'], 'window', 12, 120, 'white', ['blue','false'])
Angle := [0,90,180,270]
Row := 200 - sin(rad(Angle))*100
Column := 250 + cos(rad(Angle))*100
Color := ['green','red','red','red']
disp_message (WindowHandle, Angle+' deg', 'window', Row, Column, Color, 'false')
gen_cross_contour_xld (Cross, 200, 250, 200, 0)</example>
<keywords lang="de_DE">
<item>Meldung anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display message</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>set_display_font</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>write_string</item>
<item>disp_continue_message</item>
</see_also>
<short>This procedure writes a text message.</short>
<short lang="en_US">Write one or multiple text messages.</short>
<successor>
<item>disp_continue_message</item>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="Box">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', the text is written within an orange box.
If set to' false', no box is displayed.
If set to a color string (e.g. 'white', '#FF00CC', etc.), the text is written in a box of that color. Optionally, a second value controls the appearance of a box shadow.</description>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
<item>'white'</item>
<item>'red'</item>
<item>'forest green'</item>
<item>'black'</item>
<item>'blue'</item>
</value_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the color of the text as string. If set to [], or '' the currently set color is used. If a tuple of strings is passed, the colors are used cyclically for each new position or textline.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>''</item>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>12</default_value>
<description lang="en_US">The horizontal text alignment or the column coordinate of the desired text position. -1 is mapped to 12.</description>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>10</item>
<item>12</item>
<item>20</item>
<item>30</item>
<item>'center'</item>
<item>'left'</item>
<item>'right'</item>
</values>
</parameter>
<parameter id="CoordSystem">
<default_type>string</default_type>
<default_value>'window'</default_value>
<description lang="en_US">If set to 'window', the text position is given with respect to the window coordinate system. If set to 'image', image coordinates are used (This may be useful in zoomed images).</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'window'</item>
<item>'image'</item>
</value_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>12</default_value>
<description lang="en_US">The vertical text alignment or the row coordinate of the desired text position. -1 is mapped to 12.</description>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>10</item>
<item>12</item>
<item>20</item>
<item>30</item>
<item>'bottom'</item>
<item>'center'</item>
<item>'top'</item>
</values>
</parameter>
<parameter id="String">
<default_type>string</default_type>
<description lang="en_US">A tuple of strings containing the text message to be displayed. Each value of the tuple will be displayed in a single line.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the graphics window, where the message should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_trackball_center" access="local">
<interface>
<ic>
<par name="SelectedObject" base_type="ctrl" dimension="0"/>
<par name="TrackballRadiusPixel" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TBCenter" base_type="ctrl" dimension="0"/>
<par name="TBSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>NumModels := |ObjectModel3D|</l>
<l>TBCenter[0] := 0</l>
<l>TBCenter[1] := 0</l>
<l>TBCenter[2] := 0</l>
<l>Diameter := gen_tuple_const(|ObjectModel3D|,0.0)</l>
<l>for Index := 0 to |ObjectModel3D| - 1 by 1</l>
<l>    try</l>
<l>        get_object_model_3d_params (ObjectModel3D[Index], 'center', Center)</l>
<l>        get_object_model_3d_params (ObjectModel3D[Index], 'diameter_axis_aligned_bounding_box', CurrDiameter)</l>
<l>        Diameter[Index] := CurrDiameter</l>
<l>    catch (Exception)</l>
<c>        * 3D object model is empty or otherwise malformed -&gt; ignore</c>
<l>    endtry</l>
<l>endfor</l>
<c>* Normalize Diameter to use it as weights for a weighted mean of the individual centers</c>
<l>MD := mean(Diameter)</l>
<l>if (MD &gt; 1e-10)</l>
<l>    Weight := Diameter / MD</l>
<l>else</l>
<l>    Weight := Diameter</l>
<l>endif</l>
<l>SumW := sum(select_mask(Weight,abs(sgn(SelectedObject))))</l>
<l>if (SumW &lt; 1e-10)</l>
<l>    Weight := gen_tuple_const(|Weight|,1.0)</l>
<l>    SumW := sum(select_mask(Weight,abs(sgn(SelectedObject))))</l>
<l>endif</l>
<l>if (SumW &lt; 1e-10)</l>
<l>    SumW := 1.0</l>
<l>endif</l>
<l>for Index := 0 to NumModels - 1 by 1</l>
<l>    if (SelectedObject[Index] and Diameter[Index] &gt; 0)</l>
<l>        PoseSelected := Poses[Index * 7:Index * 7 + 6]</l>
<l>        pose_to_hom_mat3d (PoseSelected, HomMat3D)</l>
<l>        get_object_model_3d_params (ObjectModel3D[Index], 'center', Center)</l>
<l>        affine_trans_point_3d (HomMat3D, Center[0], Center[1], Center[2], TBCenterCamX, TBCenterCamY, TBCenterCamZ)</l>
<l>        TBCenter[0] := TBCenter[0] + TBCenterCamX * Weight[Index]</l>
<l>        TBCenter[1] := TBCenter[1] + TBCenterCamY * Weight[Index]</l>
<l>        TBCenter[2] := TBCenter[2] + TBCenterCamZ * Weight[Index]</l>
<l>    endif</l>
<l>endfor</l>
<l>if (max(SelectedObject) != 0)</l>
<l>    InvSum := 1.0 / SumW</l>
<l>    TBCenter[0] := TBCenter[0] * InvSum</l>
<l>    TBCenter[1] := TBCenter[1] * InvSum</l>
<l>    TBCenter[2] := TBCenter[2] * InvSum</l>
<l>    TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>else</l>
<l>    TBCenter := []</l>
<l>    TBSize := 0</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_trackball_center">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the center of the virtual trackback that is used to move the camera.</short>
<parameters>
<parameter id="ObjectModel3D"/>
<parameter id="Poses"/>
<parameter id="SelectedObject"/>
<parameter id="TBCenter"/>
<parameter id="TBSize"/>
<parameter id="TrackballRadiusPixel"/>
</parameters>
</docu>
</procedure>
<procedure name="dump_image_output">
<interface>
<io>
<par name="BackgroundImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="Scene3D" base_type="ctrl" dimension="0"/>
<par name="AlphaOrig" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="ColorImage" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
<par name="Labels" base_type="ctrl" dimension="0"/>
<par name="VisualizeTrackball" base_type="ctrl" dimension="0"/>
<par name="DisplayContinueButton" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterRow" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterCol" base_type="ctrl" dimension="0"/>
<par name="TrackballRadiusPixel" base_type="ctrl" dimension="0"/>
<par name="SelectedObject" base_type="ctrl" dimension="0"/>
<par name="VisualizeRotationCenter" base_type="ctrl" dimension="0"/>
<par name="RotationCenter" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>global tuple gAlphaDeselected</l>
<l>global tuple gTerminationButtonLabel</l>
<l>global tuple gDispObjOffset</l>
<l>global tuple gLabelsDecor</l>
<l>global tuple gUsesOpenGL</l>
<c>* </c>
<c>* Display background image</c>
<l>clear_window (WindowHandleBuffer)</l>
<l>if (ColorImage)</l>
<l>    disp_color (BackgroundImage, WindowHandleBuffer)</l>
<l>else</l>
<l>    disp_image (BackgroundImage, WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<c>* Display objects</c>
<l>if (sum(SelectedObject) == |SelectedObject|)</l>
<l>    if (gUsesOpenGL == 'true')</l>
<l>        try</l>
<l>            display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 5185 or Exception[0] == 5188 or Exception[0] == 5187)</l>
<l>                gUsesOpenGL := 'false'</l>
<l>            else</l>
<l>                throw (Exception)</l>
<l>            endif</l>
<l>        endtry</l>
<l>    endif</l>
<l>    if (gUsesOpenGL == 'false')</l>
<c>        * * NO OpenGL, use fallback</c>
<l>        disp_object_model_no_opengl (ModelContours, ObjectModel3DID, GenParamName, GenParamValue, WindowHandleBuffer, CamParam, Poses)</l>
<l>    endif</l>
<l>else</l>
<l>    for Index := 0 to |AlphaOrig| - 1 by 1</l>
<l>        if (SelectedObject[Index] == 1)</l>
<l>            set_scene_3d_instance_param (Scene3D, Index, 'alpha', AlphaOrig[Index])</l>
<l>        else</l>
<l>            set_scene_3d_instance_param (Scene3D, Index, 'alpha', gAlphaDeselected)</l>
<l>        endif</l>
<l>    endfor</l>
<l>    try</l>
<l>        if (gUsesOpenGL == 'false')</l>
<l>            throw ([])</l>
<l>        endif</l>
<l>        display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>    catch (Exception1)</l>
<c>        * * NO OpenGL, use fallback</c>
<l>        DeselectedIdx := find(SelectedObject,0)</l>
<l>        if (DeselectedIdx != -1)</l>
<l>            DeselectedName := 'color_' + DeselectedIdx</l>
<l>            DeselectedValue := gen_tuple_const(|DeselectedName|,'gray')</l>
<l>        endif</l>
<l>        disp_object_model_no_opengl (ModelContours, ObjectModel3DID, [GenParamName,DeselectedName], [GenParamValue,DeselectedValue], WindowHandleBuffer, CamParam, Poses)</l>
<l>    endtry</l>
<l>    for Index := 0 to |AlphaOrig| - 1 by 1</l>
<l>        set_scene_3d_instance_param (Scene3D, Index, 'alpha', AlphaOrig[Index])</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Display labels</c>
<l>if (Labels != [])</l>
<l>    set_color (WindowHandleBuffer, gLabelsDecor[0])</l>
<l>    for Index := 0 to |ObjectModel3DID| - 1 by 1</l>
<c>        * Project the center point of the current model</c>
<l>        Pose := Poses[Index * 7:Index * 7 + 6]</l>
<l>        pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>        try</l>
<l>            get_object_model_3d_params (ObjectModel3DID[Index], 'center', Center)</l>
<l>            affine_trans_point_3d (HomMat3D, Center[0], Center[1], Center[2], CenterCamX, CenterCamY, CenterCamZ)</l>
<l>            project_3d_point (CenterCamX, CenterCamY, CenterCamZ, CamParam, CenterRow, CenterCol)</l>
<l>            Label := Labels[Index]</l>
<l>            if (Label != '')</l>
<c>                * Work around the fact that get_string_extents() does not handle newlines as we want</c>
<l>                tuple_split (Label, '\n', Sublabels)</l>
<l>                get_string_extents (WindowHandleBuffer, Sublabels[0], Ascent, Descent, TextWidth, TextHeight)</l>
<l>                for Index2 := 1 to |Sublabels| - 1 by 1</l>
<l>                    get_string_extents (WindowHandleBuffer, Sublabels[Index2], Ascent, Descent, TextWidth2, TextHeight2)</l>
<l>                    TextHeight := TextHeight + TextHeight2</l>
<l>                    TextWidth := max2(TextWidth,TextWidth2)</l>
<l>                endfor</l>
<l>                disp_message (WindowHandleBuffer, Label, 'window', CenterRow - TextHeight / 2 + gDispObjOffset[0], CenterCol - TextWidth / 2 + gDispObjOffset[1], [], gLabelsDecor[1])</l>
<l>            endif</l>
<l>        catch (Exception)</l>
<c>            * The 3D object model might not have a center because it is empty</c>
<c>            * -&gt; do not display any label</c>
<l>        endtry</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Visualize the trackball if desired</c>
<l>if (VisualizeTrackball)</l>
<l>    set_line_width (WindowHandleBuffer, 1)</l>
<l>    gen_ellipse_contour_xld (TrackballContour, TrackballCenterRow, TrackballCenterCol, 0, TrackballRadiusPixel, TrackballRadiusPixel, 0, 6.28318, 'positive', 1.5)</l>
<l>    set_color (WindowHandleBuffer, 'dim gray')</l>
<l>    disp_xld (TrackballContour, WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<c>* Visualize the rotation center if desired</c>
<l>if (VisualizeRotationCenter != 0 and |RotationCenter| == 3)</l>
<l>    if (RotationCenter[2] &lt; 1e-10)</l>
<l>        RotationCenter[2] := 1e-10</l>
<l>    endif</l>
<l>    project_3d_point (RotationCenter[0], RotationCenter[1], RotationCenter[2], CamParam, RotCenterRow, RotCenterCol)</l>
<l>    Orientation := rad(90)</l>
<l>    if (VisualizeRotationCenter == 1)</l>
<l>        Orientation := rad(45)</l>
<l>    endif</l>
<l>    gen_cross_contour_xld (CrossRotCenter, RotCenterRow, RotCenterCol, TrackballRadiusPixel / 25.0, Orientation)</l>
<l>    set_line_width (WindowHandleBuffer, 3)</l>
<l>    query_color (WindowHandleBuffer, Colors)</l>
<l>    set_color (WindowHandleBuffer, 'light gray')</l>
<l>    disp_xld (CrossRotCenter, WindowHandleBuffer)</l>
<l>    set_line_width (WindowHandleBuffer, 1)</l>
<l>    set_color (WindowHandleBuffer, 'dim gray')</l>
<l>    disp_xld (CrossRotCenter, WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<c>* Display title</c>
<l>disp_title_and_information (WindowHandleBuffer, Title, Information)</l>
<c>* </c>
<c>* Display the 'Exit' button</c>
<l>if (DisplayContinueButton == 'true')</l>
<l>    disp_continue_button (WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dump_image_output">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Render 3D object models in a buffer window.</short>
<parameters>
<parameter id="AlphaOrig"/>
<parameter id="BackgroundImage">
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="CamParam"/>
<parameter id="ColorImage">
<sem_type>string</sem_type>
</parameter>
<parameter id="DisplayContinueButton"/>
<parameter id="GenParamName">
<sem_type>string</sem_type>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Information">
<sem_type>string</sem_type>
</parameter>
<parameter id="Labels">
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Poses">
<sem_type>pose</sem_type>
</parameter>
<parameter id="RotationCenter"/>
<parameter id="Scene3D"/>
<parameter id="SelectedObject">
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
</parameter>
<parameter id="Title">
<sem_type>string</sem_type>
</parameter>
<parameter id="TrackballCenterCol">
<sem_type>real</sem_type>
</parameter>
<parameter id="TrackballCenterRow">
<sem_type>real</sem_type>
</parameter>
<parameter id="TrackballRadiusPixel">
<sem_type>real</sem_type>
</parameter>
<parameter id="VisualizeRotationCenter"/>
<parameter id="VisualizeTrackball">
<sem_type>real</sem_type>
</parameter>
<parameter id="WindowHandleBuffer">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="analyze_graph_event" access="local">
<interface>
<io>
<par name="BackgroundImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="MouseMapping" base_type="ctrl" dimension="0"/>
<par name="Button" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="VirtualTrackball" base_type="ctrl" dimension="0"/>
<par name="TrackballSize" base_type="ctrl" dimension="0"/>
<par name="SelectedObjectIn" base_type="ctrl" dimension="0"/>
<par name="Scene3D" base_type="ctrl" dimension="0"/>
<par name="AlphaOrig" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Labels" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="PosesIn" base_type="ctrl" dimension="0"/>
<par name="ButtonHoldIn" base_type="ctrl" dimension="0"/>
<par name="TBCenter" base_type="ctrl" dimension="0"/>
<par name="TBSize" base_type="ctrl" dimension="0"/>
<par name="WindowCenteredRotationlIn" base_type="ctrl" dimension="0"/>
<par name="MaxNumModels" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PosesOut" base_type="ctrl" dimension="0"/>
<par name="SelectedObjectOut" base_type="ctrl" dimension="0"/>
<par name="ButtonHoldOut" base_type="ctrl" dimension="0"/>
<par name="WindowCenteredRotationOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure reflects</c>
<c>* - the pose change that was introduced by the user by</c>
<c>*   moving the mouse</c>
<c>* - the selection of a single object</c>
<c>* </c>
<l>global tuple gIsSinglePose</l>
<c>* </c>
<l>ButtonHoldOut := ButtonHoldIn</l>
<l>PosesOut := PosesIn</l>
<l>SelectedObjectOut := SelectedObjectIn</l>
<l>WindowCenteredRotationOut := WindowCenteredRotationlIn</l>
<l>VisualizeTB := max(SelectedObjectOut) != 0</l>
<l>InvLog2 := 1.0 / log(2)</l>
<c>* </c>
<l>if (Button == MouseMapping[6])</l>
<l>    if (ButtonHoldOut)</l>
<l>        return ()</l>
<l>    endif</l>
<c>    * Ctrl (16) + Alt (32) + left mouse button (1) =&gt; Toggle rotation center position</c>
<c>    * If WindowCenteredRotation is not 1, set it to 1, otherwise, set it to 2</c>
<l>    count_seconds (Seconds)</l>
<l>    if (WindowCenteredRotationOut == 1)</l>
<l>        WindowCenteredRotationOut := 2</l>
<l>    else</l>
<l>        WindowCenteredRotationOut := 1</l>
<l>    endif</l>
<l>    ButtonHoldOut := true</l>
<l>    return ()</l>
<l>endif</l>
<l>if (Button == MouseMapping[5] and |ObjectModel3DID| &lt;= MaxNumModels)</l>
<l>    if (ButtonHoldOut)</l>
<l>        return ()</l>
<l>    endif</l>
<c>    * Ctrl (16) + left mouse button (1) =&gt; Select an object</c>
<l>    try</l>
<l>        set_scene_3d_param (Scene3D, 'object_index_persistence', 'true')</l>
<l>        display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>        get_display_scene_3d_info (WindowHandleBuffer, Scene3D, Row, Column, 'object_index', ModelIndex)</l>
<l>        set_scene_3d_param (Scene3D, 'object_index_persistence', 'false')</l>
<l>    catch (Exception1)</l>
<c>        * * NO OpenGL, no selection possible</c>
<l>        return ()</l>
<l>    endtry</l>
<l>    if (ModelIndex == -1)</l>
<c>        * Background click:</c>
<l>        if (sum(SelectedObjectOut) == |SelectedObjectOut|)</l>
<c>            * If all objects are already selected, deselect all</c>
<l>            SelectedObjectOut := gen_tuple_const(|ObjectModel3DID|,0)</l>
<l>        else</l>
<c>            * Otherwise select all</c>
<l>            SelectedObjectOut := gen_tuple_const(|ObjectModel3DID|,1)</l>
<l>        endif</l>
<l>    else</l>
<c>        * Object click:</c>
<l>        SelectedObjectOut[ModelIndex] := not SelectedObjectOut[ModelIndex]</l>
<l>    endif</l>
<l>    ButtonHoldOut := true</l>
<l>else</l>
<c>    * Change the pose</c>
<l>    hom_mat3d_identity (HomMat3DIdentity)</l>
<l>    NumModels := |ObjectModel3DID|</l>
<l>    get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>    get_cam_par_data (CamParam, 'image_height', Height)</l>
<l>    MinImageSize := min([Width,Height])</l>
<l>    TrackballRadiusPixel := TrackballSize * MinImageSize / 2.0</l>
<c>    * Set trackball fixed in the center of the window</c>
<l>    TrackballCenterRow := Height / 2</l>
<l>    TrackballCenterCol := Width / 2</l>
<l>    if (|ObjectModel3DID| &lt; MaxNumModels)</l>
<l>        if (WindowCenteredRotationOut == 1)</l>
<l>            get_trackball_center_fixed (SelectedObjectIn, TrackballCenterRow, TrackballCenterCol, TrackballRadiusPixel, Scene3D, ObjectModel3DID, PosesIn, WindowHandleBuffer, CamParam, GenParamName, GenParamValue, TBCenter, TBSize)</l>
<l>        else</l>
<l>            get_trackball_center (SelectedObjectIn, TrackballRadiusPixel, ObjectModel3DID, PosesIn, TBCenter, TBSize)</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (min(SelectedObjectOut) == 0 and max(SelectedObjectOut) == 1)</l>
<c>        * At this point, multiple objects do not necessary have the same</c>
<c>        * pose any more. Consequently, we have to return a tuple of poses</c>
<c>        * as output of visualize_object_model_3d</c>
<l>        gIsSinglePose := false</l>
<l>    endif</l>
<l>    count_channels (BackgroundImage, NumChannels)</l>
<l>    ColorImage := NumChannels == 3</l>
<c>    * Alt (32) =&gt; lower sensitivity</c>
<l>    tuple_rsh (Button, 5, BAnd)</l>
<l>    if (BAnd % 2)</l>
<l>        SensFactor := 0.1</l>
<l>    else</l>
<l>        SensFactor := 1.0</l>
<l>    endif</l>
<l>    IsButtonTrans := MouseMapping[0] == Button or (32 + MouseMapping[0]) == Button</l>
<l>    IsButtonRot := MouseMapping[1] == Button or (32 + MouseMapping[1]) == Button</l>
<l>    IsButtonDist := MouseMapping[2] == Button or (32 + MouseMapping[2]) == Button or MouseMapping[3] == Button or (32 + MouseMapping[3]) == Button or MouseMapping[4] == Button or (32 + MouseMapping[4]) == Button</l>
<l>    if (IsButtonTrans)</l>
<c>        * Translate in XY-direction</c>
<l>        MRow1 := Row</l>
<l>        MCol1 := Column</l>
<l>        while (IsButtonTrans)</l>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, Row, Column, ButtonLoop)</l>
<l>                IsButtonTrans := ButtonLoop == Button</l>
<l>                MRow2 := MRow1 + (Row - MRow1) * SensFactor</l>
<l>                MCol2 := MCol1 + (Column - MCol1) * SensFactor</l>
<l>                get_line_of_sight (MRow1, MCol1, CamParam, PX, PY, PZ, QX1, QY1, QZ1)</l>
<l>                get_line_of_sight (MRow2, MCol2, CamParam, PX, PY, PZ, QX2, QY2, QZ2)</l>
<l>                Len := sqrt(QX1 * QX1 + QY1 * QY1 + QZ1 * QZ1)</l>
<l>                Dist := sqrt(TBCenter[0] * TBCenter[0] + TBCenter[1] * TBCenter[1] + TBCenter[2] * TBCenter[2])</l>
<l>                Translate := [QX2 - QX1,QY2 - QY1,QZ2 - QZ1] * Dist / Len</l>
<l>                PosesOut := []</l>
<l>                if (NumModels &lt;= MaxNumModels)</l>
<l>                    for Index := 0 to NumModels - 1 by 1</l>
<l>                        PoseIn := PosesIn[Index * 7:Index * 7 + 6]</l>
<l>                        if (SelectedObjectOut[Index])</l>
<l>                            pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, Translate[0], Translate[1], Translate[2], HomMat3DOut)</l>
<l>                            hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                            set_scene_3d_instance_pose (Scene3D, Index, PoseOut)</l>
<l>                        else</l>
<l>                            PoseOut := PoseIn</l>
<l>                        endif</l>
<l>                        PosesOut := [PosesOut,PoseOut]</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    tuple_find (SelectedObjectOut, 1, Indices)</l>
<l>                    PoseIn := PosesIn[Indices[0] * 7:Indices[0] * 7 + 6]</l>
<l>                    pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                    hom_mat3d_translate (HomMat3DIn, Translate[0], Translate[1], Translate[2], HomMat3DOut)</l>
<l>                    hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                    Sequence := [0:NumModels * 7 - 1]</l>
<l>                    tuple_mod (Sequence, 7, Mod)</l>
<l>                    SequenceReal := [0:1.0 / 7.0:NumModels - (1.0 / 7.0)]</l>
<l>                    Sequence2Int := int(SequenceReal)</l>
<l>                    tuple_select (SelectedObjectOut, Sequence2Int, Selected)</l>
<l>                    InvSelected := 1 - Selected</l>
<l>                    tuple_select (PoseOut, Mod, PosesOut)</l>
<l>                    PosesOut := PosesOut * Selected + PosesIn * InvSelected</l>
<l>                    set_scene_3d_instance_pose (Scene3D, [0:NumModels - 1], PosesOut)</l>
<l>                endif</l>
<l>                dump_image_output (BackgroundImage, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3DID, GenParamName, GenParamValue, CamParam, PosesOut, ColorImage, Title, Information, Labels, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObjectOut, WindowCenteredRotationOut == 1, TBCenter)</l>
<l>                dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>                dev_set_window (WindowHandle)</l>
<l>                dev_display (ImageDump)</l>
<c>                * </c>
<l>                MRow1 := Row</l>
<l>                MCol1 := Column</l>
<l>                PosesIn := PosesOut</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>    elseif (IsButtonDist)</l>
<c>        * Change the Z distance</c>
<l>        MRow1 := Row</l>
<l>        while (IsButtonDist)</l>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, Row, Column, ButtonLoop)</l>
<l>                IsButtonDist := ButtonLoop == Button</l>
<l>                MRow2 := Row</l>
<l>                DRow := MRow2 - MRow1</l>
<l>                Dist := sqrt(TBCenter[0] * TBCenter[0] + TBCenter[1] * TBCenter[1] + TBCenter[2] * TBCenter[2])</l>
<l>                TranslateZ := -Dist * DRow * 0.003 * SensFactor</l>
<l>                TBCenter[2] := TBCenter[2] + TranslateZ</l>
<l>                PosesOut := []</l>
<l>                if (NumModels &lt;= MaxNumModels)</l>
<l>                    for Index := 0 to NumModels - 1 by 1</l>
<l>                        PoseIn := PosesIn[Index * 7:Index * 7 + 6]</l>
<l>                        if (SelectedObjectOut[Index])</l>
<c>                            * Transform the whole scene or selected object only</c>
<l>                            pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, 0, 0, TranslateZ, HomMat3DOut)</l>
<l>                            hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                            set_scene_3d_instance_pose (Scene3D, Index, PoseOut)</l>
<l>                        else</l>
<l>                            PoseOut := PoseIn</l>
<l>                        endif</l>
<l>                        PosesOut := [PosesOut,PoseOut]</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    tuple_find (SelectedObjectOut, 1, Indices)</l>
<l>                    PoseIn := PosesIn[Indices[0] * 7:Indices[0] * 7 + 6]</l>
<l>                    pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                    hom_mat3d_translate (HomMat3DIn, 0, 0, TranslateZ, HomMat3DOut)</l>
<l>                    hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                    Sequence := [0:NumModels * 7 - 1]</l>
<l>                    tuple_mod (Sequence, 7, Mod)</l>
<l>                    SequenceReal := [0:1.0 / 7.0:NumModels - (1.0 / 7.0)]</l>
<l>                    Sequence2Int := int(SequenceReal)</l>
<l>                    tuple_select (SelectedObjectOut, Sequence2Int, Selected)</l>
<l>                    InvSelected := 1 - Selected</l>
<l>                    tuple_select (PoseOut, Mod, PosesOut)</l>
<l>                    PosesOut := PosesOut * Selected + PosesIn * InvSelected</l>
<l>                    set_scene_3d_instance_pose (Scene3D, [0:NumModels - 1], PosesOut)</l>
<l>                endif</l>
<l>                dump_image_output (BackgroundImage, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3DID, GenParamName, GenParamValue, CamParam, PosesOut, ColorImage, Title, Information, Labels, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObjectOut, WindowCenteredRotationOut, TBCenter)</l>
<l>                dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>                dev_set_window (WindowHandle)</l>
<l>                dev_display (ImageDump)</l>
<c>                * </c>
<l>                MRow1 := Row</l>
<l>                PosesIn := PosesOut</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>    elseif (IsButtonRot)</l>
<c>        * Rotate the object</c>
<l>        MRow1 := Row</l>
<l>        MCol1 := Column</l>
<l>        while (IsButtonRot)</l>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, Row, Column, ButtonLoop)</l>
<l>                IsButtonRot := ButtonLoop == Button</l>
<l>                MRow2 := Row</l>
<l>                MCol2 := Column</l>
<c>                * Transform the pixel coordinates to relative image coordinates</c>
<l>                MX1 := (TrackballCenterCol - MCol1) / (0.5 * MinImageSize)</l>
<l>                MY1 := (TrackballCenterRow - MRow1) / (0.5 * MinImageSize)</l>
<l>                MX2 := (TrackballCenterCol - MCol2) / (0.5 * MinImageSize)</l>
<l>                MY2 := (TrackballCenterRow - MRow2) / (0.5 * MinImageSize)</l>
<c>                * Compute the quaternion rotation that corresponds to the mouse</c>
<c>                * movement</c>
<l>                trackball (MX1, MY1, MX2, MY2, VirtualTrackball, TrackballSize, SensFactor, RelQuaternion)</l>
<c>                * Transform the quaternion to a rotation matrix</c>
<l>                quat_to_hom_mat3d (RelQuaternion, HomMat3DRotRel)</l>
<l>                PosesOut := []</l>
<l>                if (NumModels &lt;= MaxNumModels)</l>
<l>                    for Index := 0 to NumModels - 1 by 1</l>
<l>                        PoseIn := PosesIn[Index * 7:Index * 7 + 6]</l>
<l>                        if (SelectedObjectOut[Index])</l>
<c>                            * Transform the whole scene or selected object only</c>
<l>                            pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, -TBCenter[0], -TBCenter[1], -TBCenter[2], HomMat3DIn)</l>
<l>                            hom_mat3d_compose (HomMat3DRotRel, HomMat3DIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, TBCenter[0], TBCenter[1], TBCenter[2], HomMat3DOut)</l>
<l>                            hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                            set_scene_3d_instance_pose (Scene3D, Index, PoseOut)</l>
<l>                        else</l>
<l>                            PoseOut := PoseIn</l>
<l>                        endif</l>
<l>                        PosesOut := [PosesOut,PoseOut]</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    tuple_find (SelectedObjectOut, 1, Indices)</l>
<l>                    PoseIn := PosesIn[Indices[0] * 7:Indices[0] * 7 + 6]</l>
<l>                    pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                    hom_mat3d_translate (HomMat3DIn, -TBCenter[0], -TBCenter[1], -TBCenter[2], HomMat3DInTmp1)</l>
<l>                    hom_mat3d_compose (HomMat3DRotRel, HomMat3DInTmp1, HomMat3DInTmp)</l>
<l>                    hom_mat3d_translate (HomMat3DInTmp, TBCenter[0], TBCenter[1], TBCenter[2], HomMat3DOut)</l>
<l>                    hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                    Sequence := [0:NumModels * 7 - 1]</l>
<l>                    tuple_mod (Sequence, 7, Mod)</l>
<l>                    SequenceReal := [0:1.0 / 7.0:NumModels - (1.0 / 7.0)]</l>
<l>                    Sequence2Int := int(SequenceReal)</l>
<l>                    tuple_select (SelectedObjectOut, Sequence2Int, Selected)</l>
<l>                    InvSelected := 1 - Selected</l>
<l>                    tuple_select (PoseOut, Mod, PosesOut)</l>
<l>                    PosesOut2 := PosesOut * Selected + PosesIn * InvSelected</l>
<l>                    PosesOut := PosesOut2</l>
<l>                    set_scene_3d_instance_pose (Scene3D, [0:NumModels - 1], PosesOut)</l>
<l>                endif</l>
<l>                dump_image_output (BackgroundImage, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3DID, GenParamName, GenParamValue, CamParam, PosesOut, ColorImage, Title, Information, Labels, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObjectOut, WindowCenteredRotationOut, TBCenter)</l>
<l>                dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>                dev_set_window (WindowHandle)</l>
<l>                dev_display (ImageDump)</l>
<c>                * </c>
<l>                MRow1 := Row</l>
<l>                MCol1 := Column</l>
<l>                PosesIn := PosesOut</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>    endif</l>
<l>    PosesOut := PosesIn</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="analyze_graph_event">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Reflect the pose change that was introduced by the user by moving the mouse</short>
<parameters>
<parameter id="AlphaOrig"/>
<parameter id="BackgroundImage"/>
<parameter id="Button"/>
<parameter id="ButtonHoldIn"/>
<parameter id="ButtonHoldOut"/>
<parameter id="CamParam"/>
<parameter id="Column"/>
<parameter id="GenParamName"/>
<parameter id="GenParamValue"/>
<parameter id="Information"/>
<parameter id="Labels"/>
<parameter id="MaxNumModels"/>
<parameter id="MouseMapping"/>
<parameter id="ObjectModel3DID"/>
<parameter id="PosesIn"/>
<parameter id="PosesOut"/>
<parameter id="Row"/>
<parameter id="Scene3D"/>
<parameter id="SelectedObjectIn"/>
<parameter id="SelectedObjectOut"/>
<parameter id="TBCenter"/>
<parameter id="TBSize"/>
<parameter id="Title"/>
<parameter id="TrackballSize"/>
<parameter id="VirtualTrackball"/>
<parameter id="WindowCenteredRotationOut"/>
<parameter id="WindowCenteredRotationlIn"/>
<parameter id="WindowHandle"/>
<parameter id="WindowHandleBuffer"/>
</parameters>
</docu>
</procedure>
<procedure name="get_cam_par_names">
<interface>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraType" base_type="ctrl" dimension="0"/>
<par name="ParamNames" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* get_cam_par_names returns for each element in the camera</c>
<c>* parameter tuple that is passed in CameraParam the name</c>
<c>* of the respective camera parameter. The parameter names</c>
<c>* are returned in ParamNames. Additionally, the camera</c>
<c>* type is returned in CameraType. Alternatively, instead of</c>
<c>* the camera parameters, the camera type can be passed in</c>
<c>* CameraParam in form of one of the following strings:</c>
<c>*   - 'area_scan_division'</c>
<c>*   - 'area_scan_polynomial'</c>
<c>*   - 'area_scan_tilt_division'</c>
<c>*   - 'area_scan_tilt_polynomial'</c>
<c>*   - 'area_scan_telecentric_division'</c>
<c>*   - 'area_scan_telecentric_polynomial'</c>
<c>*   - 'area_scan_tilt_bilateral_telecentric_division'</c>
<c>*   - 'area_scan_tilt_bilateral_telecentric_polynomial'</c>
<c>*   - 'area_scan_tilt_object_side_telecentric_division'</c>
<c>*   - 'area_scan_tilt_object_side_telecentric_polynomial'</c>
<c>*   - 'area_scan_hypercentric_division'</c>
<c>*   - 'area_scan_hypercentric_polynomial'</c>
<c>*   - 'line_scan_division'</c>
<c>*   - 'line_scan_polynomial'</c>
<c>*   - 'line_scan_telecentric_division'</c>
<c>*   - 'line_scan_telecentric_polynomial'</c>
<c>* </c>
<l>CameraParamAreaScanDivision := ['focus', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTelecentricDivision := ['magnification', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTelecentricPolynomial := ['magnification', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTiltDivision := ['focus', 'kappa', 'image_plane_dist', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTiltPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'image_plane_dist', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanImageSideTelecentricTiltDivision := ['focus', 'kappa', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanImageSideTelecentricTiltPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltDivision := ['magnification', 'kappa', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltPolynomial := ['magnification', 'k1', 'k2', 'k3', 'p1', 'p2', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanObjectSideTelecentricTiltDivision := ['magnification', 'kappa', 'image_plane_dist', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanObjectSideTelecentricTiltPolynomial := ['magnification', 'k1', 'k2', 'k3', 'p1', 'p2', 'image_plane_dist', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanHypercentricDivision := ['focus', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanHypercentricPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamLinesScanDivision := ['focus', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz']</l>
<l>CameraParamLinesScanPolynomial := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz']</l>
<l>CameraParamLinesScanTelecentricDivision := ['magnification', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz']</l>
<l>CameraParamLinesScanTelecentricPolynomial := ['magnification', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz']</l>
<c>* Legacy parameter names</c>
<l>CameraParamAreaScanTiltDivisionLegacy := ['focus', 'kappa', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTiltPolynomialLegacy := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTelecentricDivisionLegacy := ['focus', 'kappa', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanTelecentricPolynomialLegacy := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy := ['focus', 'kappa', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy := ['focus', 'k1', 'k2', 'k3', 'p1', 'p2', 'tilt', 'rot', 'sx', 'sy', 'cx', 'cy', 'image_width', 'image_height']</l>
<c>* </c>
<c>* If the camera type is passed in CameraParam</c>
<l>if (|CameraParam| == 1)</l>
<l>    if (is_string(CameraParam[0]))</l>
<l>        CameraType := CameraParam[0]</l>
<l>        if (CameraType == 'area_scan_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanDivision]</l>
<l>        elseif (CameraType == 'area_scan_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanTelecentricDivision]</l>
<l>        elseif (CameraType == 'area_scan_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanTelecentricPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_tilt_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanTiltDivision]</l>
<l>        elseif (CameraType == 'area_scan_tilt_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanTiltPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_tilt_image_side_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltDivision]</l>
<l>        elseif (CameraType == 'area_scan_tilt_image_side_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltDivision]</l>
<l>        elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_tilt_object_side_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltDivision]</l>
<l>        elseif (CameraType == 'area_scan_tilt_object_side_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltPolynomial]</l>
<l>        elseif (CameraType == 'area_scan_hypercentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanHypercentricDivision]</l>
<l>        elseif (CameraType == 'area_scan_hypercentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamAreaScanHypercentricPolynomial]</l>
<l>        elseif (CameraType == 'line_scan_division' or CameraType == 'line_scan')</l>
<l>            ParamNames := ['camera_type',CameraParamLinesScanDivision]</l>
<l>        elseif (CameraType == 'line_scan_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamLinesScanPolynomial]</l>
<l>        elseif (CameraType == 'line_scan_telecentric_division')</l>
<l>            ParamNames := ['camera_type',CameraParamLinesScanTelecentricDivision]</l>
<l>        elseif (CameraType == 'line_scan_telecentric_polynomial')</l>
<l>            ParamNames := ['camera_type',CameraParamLinesScanTelecentricPolynomial]</l>
<l>        else</l>
<l>            throw ('Unknown camera type \'' + CameraType + '\' passed in CameraParam.')</l>
<l>        endif</l>
<l>        return ()</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* If the camera parameters are passed in CameraParam</c>
<l>if (not is_string(CameraParam[0]))</l>
<c>    * Format of camera parameters for HALCON 12 and earlier</c>
<l>    switch (|CameraParam|)</l>
<c>        * </c>
<c>        * Area Scan</c>
<l>    case 8:</l>
<c>        * CameraType: 'area_scan_division' or 'area_scan_telecentric_division'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanDivision</l>
<l>            CameraType := 'area_scan_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanTelecentricDivisionLegacy</l>
<l>            CameraType := 'area_scan_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 10:</l>
<c>        * CameraType: 'area_scan_tilt_division' or 'area_scan_telecentric_tilt_division'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanTiltDivisionLegacy</l>
<l>            CameraType := 'area_scan_tilt_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy</l>
<l>            CameraType := 'area_scan_tilt_bilateral_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 12:</l>
<c>        * CameraType: 'area_scan_polynomial' or 'area_scan_telecentric_polynomial'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanPolynomial</l>
<l>            CameraType := 'area_scan_polynomial'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanTelecentricPolynomialLegacy</l>
<l>            CameraType := 'area_scan_telecentric_polynomial'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 14:</l>
<c>        * CameraType: 'area_scan_tilt_polynomial' or 'area_scan_telecentric_tilt_polynomial'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanTiltPolynomialLegacy</l>
<l>            CameraType := 'area_scan_tilt_polynomial'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy</l>
<l>            CameraType := 'area_scan_tilt_bilateral_telecentric_polynomial'</l>
<l>        endif</l>
<l>        break</l>
<c>        * </c>
<c>        * Line Scan</c>
<l>    case 11:</l>
<c>        * CameraType: 'line_scan' or 'line_scan_telecentric'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamLinesScanDivision</l>
<l>            CameraType := 'line_scan_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamLinesScanTelecentricDivision</l>
<l>            CameraType := 'line_scan_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    default:</l>
<l>        throw ('Wrong number of values in CameraParam.')</l>
<l>    endswitch</l>
<l>else</l>
<c>    * Format of camera parameters since HALCON 13</c>
<l>    CameraType := CameraParam[0]</l>
<l>    if (CameraType == 'area_scan_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanDivision]</l>
<l>    elseif (CameraType == 'area_scan_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_division')</l>
<l>        if (|CameraParam| != 11)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 15)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_division')</l>
<l>        if (|CameraParam| != 11)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 15)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_hypercentric_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanHypercentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_hypercentric_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanHypercentricPolynomial]</l>
<l>    elseif (CameraType == 'line_scan_division' or CameraType == 'line_scan')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanDivision]</l>
<l>    elseif (CameraType == 'line_scan_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanPolynomial]</l>
<l>    elseif (CameraType == 'line_scan_telecentric_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'line_scan_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScanTelecentricPolynomial]</l>
<l>    else</l>
<l>        throw ('Unknown camera type in CameraParam.')</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_cam_par_names">
<abstract lang="en_US">&lt;proc:get_cam_par_names&gt; returns the names ParamNames of the camera parameters for each element of CameraParam. The parameter names are returned in ParamNames. Additionally, the camera type is returned in CameraType.

Alternatively, instead of the camera parameters, the camera type can be passed in CameraParam in form of one of the following strings:
   - *'area_scan_division'*
   - *'area_scan_polynomial'*
   - *'area_scan_tilt_division'*
   - *'area_scan_tilt_polynomial'*
   - *'area_scan_telecentric_division'*
   - *'area_scan_telecentric_polynomial'*
   - *'area_scan_tilt_bilateral_telecentric_division'*
   - *'area_scan_tilt_bilateral_telecentric_polynomial'*
   - *'area_scan_tilt_object_side_telecentric_division'*
   - *'area_scan_tilt_object_side_telecentric_polynomial'*
   - *'area_scan_hypercentric_division'*
   - *'area_scan_hypercentric_polynomial'*
   - *'line_scan_division'*
   - *'line_scan_polynomial'*
   - *'line_scan_telecentric_division'*
   - *'line_scan_telecentric_polynomial'*</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam)
get_cam_par_names (CameraParam, CameraType, ParamNames)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_hypercentric_division</item>
<item>gen_cam_par_area_scan_hypercentric_polynomial</item>
<item>gen_cam_par_line_scan_division</item>
<item>gen_cam_par_line_scan_polynomial</item>
<item>gen_cam_par_line_scan_telecentric_division</item>
<item>gen_cam_par_line_scan_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Get the names of the parameters in a camera parameter tuple.</short>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple or camera type.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'area_scan_division'</item>
<item>'area_scan_polynomial'</item>
<item>'area_scan_tilt_division'</item>
<item>'area_scan_tilt_polynomial'</item>
<item>'area_scan_telecentric_division'</item>
<item>'area_scan_telecentric_polynomial'</item>
<item>'area_scan_tilt_bilateral_telecentric_division'</item>
<item>'area_scan_tilt_bilateral_telecentric_polynomial'</item>
<item>'area_scan_tilt_object_side_telecentric_division'</item>
<item>'area_scan_tilt_object_side_telecentric_polynomial'</item>
<item>'area_scan_tilt_image_side_telecentric_division'</item>
<item>'area_scan_tilt_image_side_telecentric_polynomial'</item>
<item>'area_scan_hypercentric_division'</item>
<item>'area_scan_hypercentric_polynomial'</item>
<item>'line_scan_division'</item>
<item>'line_scan_polynomial'</item>
<item>'line_scan_telecentric_division'</item>
<item>'line_scan_telecentric_polynomial'</item>
</values>
</parameter>
<parameter id="CameraType">
<default_type>string</default_type>
<description lang="en_US">The camera type that is described by CameraParam.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'area_scan_division'</item>
<item>'area_scan_polynomial'</item>
<item>'area_scan_tilt_division'</item>
<item>'area_scan_tilt_polynomial'</item>
<item>'area_scan_telecentric_division'</item>
<item>'area_scan_telecentric_polynomial'</item>
<item>'area_scan_tilt_bilateral_telecentric_division'</item>
<item>'area_scan_tilt_bilateral_telecentric_polynomial'</item>
<item>'area_scan_tilt_object_side_telecentric_division'</item>
<item>'area_scan_tilt_object_side_telecentric_polynomial'</item>
<item>'line_scan_division'</item>
<item>'line_scan_polynomial'</item>
<item>'line_scan_telecentric_division'</item>
<item>'line_scan_telecentric_polynomial'</item>
</value_list>
</parameter>
<parameter id="ParamNames">
<default_type>string</default_type>
<description lang="en_US">Parameter names of the camera parameter tuple or camera type passed in CameraParam.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_object_model_no_opengl">
<interface>
<oo>
<par name="ModelContours" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="PosesOut" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure allows to use project_object_model_3d to simulate a disp_object_model_3d</c>
<c>* call for small objects. Large objects are sampled down to display.</c>
<l>Idx := find(GenParamName,'point_size')</l>
<l>if (|Idx| and Idx != -1)</l>
<l>    CustomParamName := 'point_size'</l>
<l>    CustomParamValue := GenParamValue[Idx]</l>
<l>    if (CustomParamValue == 1)</l>
<l>        CustomParamValue := 0</l>
<l>    endif</l>
<l>else</l>
<l>    CustomParamName := []</l>
<l>    CustomParamValue := []</l>
<l>endif</l>
<l>get_font (WindowHandleBuffer, Font)</l>
<l>tuple_find (GenParamName, 'disp_background', IndicesDispBackGround)</l>
<l>if (IndicesDispBackGround != -1)</l>
<l>    tuple_find (GenParamName[IndicesDispBackGround], 'false', Indices)</l>
<l>    if (Indices != -1)</l>
<l>        clear_window (WindowHandleBuffer)</l>
<l>    endif</l>
<l>endif</l>
<l>set_display_font (WindowHandleBuffer, 11, 'mono', 'false', 'false')</l>
<l>get_cam_par_data (CamParam, 'image_width', ImageWidth)</l>
<l>disp_message (WindowHandleBuffer, 'OpenGL missing!', 'image', 5, ImageWidth - 130, 'red', 'false')</l>
<l>set_font (WindowHandleBuffer, Font)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_polygons', HasPolygons)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_triangles', HasTri)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_points', HasPoints)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_lines', HasLines)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'num_points', NumPoints)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_primitive_data', IsPrimitive)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'center', Center)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'diameter', Diameter)</l>
<l>get_system ('opengl_hidden_surface_removal_enable', OpenGlHiddenSurface)</l>
<l>set_system ('opengl_hidden_surface_removal_enable', 'false')</l>
<c>* Sort the objects by inverse z</c>
<l>CenterX := Center[[0:3:|Center| - 1]]</l>
<l>CenterY := Center[[0:3:|Center| - 1] + 1]</l>
<l>CenterZ := Center[[0:3:|Center| - 1] + 2]</l>
<l>PosObjectsZ := []</l>
<l>if (|PosesOut| &gt; 7)</l>
<l>    for I := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>        Pose := PosesOut[I * 7:I * 7 + 6]</l>
<l>        pose_to_hom_mat3d (Pose, HomMat3DObj)</l>
<l>        affine_trans_point_3d (HomMat3DObj, CenterX[I], CenterY[I], CenterZ[I], PosObjCenterX, PosObjCenterY, PosObjCenterZ)</l>
<l>        PosObjectsZ := [PosObjectsZ,PosObjCenterZ]</l>
<l>    endfor</l>
<l>else</l>
<l>    Pose := PosesOut[0:6]</l>
<l>    pose_to_hom_mat3d (Pose, HomMat3DObj)</l>
<l>    affine_trans_point_3d (HomMat3DObj, CenterX, CenterY, CenterZ, PosObjectsX, PosObjectsY, PosObjectsZ)</l>
<l>endif</l>
<l>Idx := inverse(sort_index(PosObjectsZ))</l>
<l>Color := 'white'</l>
<l>set_color (WindowHandleBuffer, Color)</l>
<l>if (|GenParamName| &gt; 0)</l>
<l>    tuple_find (GenParamName, 'colored', Indices1)</l>
<l>    tuple_find (GenParamName, 'color', Indices2)</l>
<l>    if (Indices1[0] != -1)</l>
<l>        if (GenParamValue[Indices1[0]] == 3)</l>
<l>            Color := ['red', 'green', 'blue']</l>
<l>        elseif (GenParamValue[Indices1[0]] == 6)</l>
<l>            Color := ['red', 'green', 'blue', 'cyan', 'magenta', 'yellow']</l>
<l>        elseif (GenParamValue[Indices1[0]] == 12)</l>
<l>            Color := ['red', 'green', 'blue', 'cyan', 'magenta', 'yellow', 'coral', 'slate blue', 'spring green', 'orange red', 'pink', 'gold']</l>
<l>        endif</l>
<l>    elseif (Indices2[0] != -1)</l>
<l>        Color := GenParamValue[Indices2[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>for J := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>    I := Idx[J]</l>
<l>    if (HasPolygons[I] == 'true' or HasTri[I] == 'true' or HasPoints[I] == 'true' or HasLines[I] == 'true')</l>
<l>        if (|GenParamName| &gt; 0)</l>
<l>            tuple_find (GenParamName, 'color_' + I, Indices3)</l>
<l>            if (Indices3[0] != -1)</l>
<l>                set_color (WindowHandleBuffer, GenParamValue[Indices3[0]])</l>
<l>            else</l>
<l>                set_color (WindowHandleBuffer, Color[I % |Color|])</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (|PosesOut| &gt;= I * 7 + 6)</l>
<l>            Pose := PosesOut[I * 7:I * 7 + 6]</l>
<l>        else</l>
<l>            Pose := PosesOut[0:6]</l>
<l>        endif</l>
<l>        if (NumPoints[I] &lt; 10000)</l>
<l>            project_object_model_3d (ModelContours, ObjectModel3DID[I], CamParam, Pose, CustomParamName, CustomParamValue)</l>
<l>            disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>        else</l>
<l>            pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>            sample_object_model_3d (ObjectModel3DID[I], 'fast', 0.01 * Diameter[I], [], [], SampledObjectModel3D)</l>
<l>            project_object_model_3d (ModelContours, SampledObjectModel3D, CamParam, Pose, 'point_size', 1)</l>
<l>            get_object_model_3d_params (SampledObjectModel3D, 'point_coord_x', X)</l>
<l>            get_object_model_3d_params (SampledObjectModel3D, 'point_coord_y', Y)</l>
<l>            get_object_model_3d_params (SampledObjectModel3D, 'point_coord_z', Z)</l>
<l>            pose_to_hom_mat3d (Pose, HomMat3D1)</l>
<l>            affine_trans_point_3d (HomMat3D1, X, Y, Z, Qx, Qy, Qz)</l>
<l>            project_3d_point (Qx, Qy, Qz, CamParam, Row, Column)</l>
<l>            disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>            clear_object_model_3d (SampledObjectModel3D)</l>
<l>        endif</l>
<l>    else</l>
<l>        if (|GenParamName| &gt; 0)</l>
<l>            tuple_find (GenParamName, 'color_' + I, Indices3)</l>
<l>            if (Indices3[0] != -1)</l>
<l>                set_color (WindowHandleBuffer, GenParamValue[Indices3[0]])</l>
<l>            else</l>
<l>                set_color (WindowHandleBuffer, Color[I % |Color|])</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (|PosesOut| &gt;= I * 7 + 6)</l>
<l>            Pose := PosesOut[I * 7:I * 7 + 6]</l>
<l>        else</l>
<l>            Pose := PosesOut[0:6]</l>
<l>        endif</l>
<l>        if (IsPrimitive[I] == 'true')</l>
<l>            try</l>
<l>                convex_hull_object_model_3d (ObjectModel3DID[I], ObjectModel3DConvexHull)</l>
<l>                if (NumPoints[I] &lt; 10000)</l>
<l>                    project_object_model_3d (ModelContours, ObjectModel3DConvexHull, CamParam, Pose, CustomParamName, CustomParamValue)</l>
<l>                    disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>                else</l>
<l>                    pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>                    sample_object_model_3d (ObjectModel3DConvexHull, 'fast', 0.01 * Diameter[I], [], [], SampledObjectModel3D)</l>
<l>                    project_object_model_3d (ModelContours, SampledObjectModel3D, CamParam, Pose, 'point_size', 1)</l>
<l>                    disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>                    clear_object_model_3d (SampledObjectModel3D)</l>
<l>                endif</l>
<l>                clear_object_model_3d (ObjectModel3DConvexHull)</l>
<l>            catch (Exception)</l>
<l>            endtry</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>set_system ('opengl_hidden_surface_removal_enable', OpenGlHiddenSurface)</l>
<l>return ()</l>
</body>
<docu id="disp_object_model_no_opengl">
<abstract lang="en_US">Can replace &lt;op:disp_object_model_3d&gt; if there is no OpenGL available.
Projects a model contour and displays this instead of the OpenGL view.

If you have no correct pose or no camera parameters use the &lt;proc:disp_object_model_3d_safe&gt; instead. For the supported generic parameters  are all which are supported by &lt;op:project_object_model_3d&gt;. Additionally, it supports the value *color_i* with i in [0,1,2,...] for GenParamName.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Replace disp_object_model_3d if there is no OpenGL available.</short>
<parameters>
<parameter id="CamParam">
<sem_type>calib_data</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<description lang="en_US">Supports similar parameters as disp_object_model_3d.</description>
<sem_type>any</sem_type>
</parameter>
<parameter id="GenParamValue">
<description lang="en_US">Supports similar parameters as disp_object_model_3d.</description>
<sem_type>any</sem_type>
</parameter>
<parameter id="ModelContours">
<description lang="en_US">Contour of the last object model,</description>
<multivalue>false</multivalue>
<sem_type>xld_cont</sem_type>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<description lang="en_US">The 3D object model to display</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PosesOut">
<sem_type>pose</sem_type>
</parameter>
<parameter id="WindowHandleBuffer">
<default_type>integer</default_type>
<description lang="en_US">Window Handle</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_title_and_information" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<l>global tuple gInfoDecor</l>
<l>global tuple gInfoPos</l>
<l>global tuple gTitlePos</l>
<l>global tuple gTitleDecor</l>
<c>* </c>
<l>get_window_extents (WindowHandle, WinRow, WinColumn, WinWidth, WinHeight)</l>
<l>Title := split('' + Title + '','\n')</l>
<l>NumTitleLines := |Title|</l>
<l>if (NumTitleLines &gt; 0)</l>
<l>    Row := 12</l>
<l>    if (gTitlePos == 'UpperLeft')</l>
<l>        Column := 12</l>
<l>    elseif (gTitlePos == 'UpperCenter')</l>
<l>        max_line_width (WindowHandle, Title, TextWidth)</l>
<l>        Column := WinWidth / 2 - TextWidth / 2</l>
<l>    elseif (gTitlePos == 'UpperRight')</l>
<l>        if (gTitleDecor[1] == 'true')</l>
<l>            max_line_width (WindowHandle, Title + '  ', TextWidth)</l>
<l>        else</l>
<l>            max_line_width (WindowHandle, Title, TextWidth)</l>
<l>        endif</l>
<l>        Column := WinWidth - TextWidth - 10</l>
<l>    else</l>
<c>        * Unknown position!</c>
<l>        stop ()</l>
<l>    endif</l>
<l>    disp_message (WindowHandle, Title, 'window', Row, Column, gTitleDecor[0], gTitleDecor[1])</l>
<l>endif</l>
<l>Information := split('' + Information + '','\n')</l>
<l>NumInfoLines := |Information|</l>
<l>if (NumInfoLines &gt; 0)</l>
<l>    if (gInfoPos == 'UpperLeft')</l>
<l>        Row := 12</l>
<l>        Column := 12</l>
<l>    elseif (gInfoPos == 'UpperRight')</l>
<l>        if (gInfoDecor[1] == 'true')</l>
<l>            max_line_width (WindowHandle, Information + '  ', TextWidth)</l>
<l>        else</l>
<l>            max_line_width (WindowHandle, Information, TextWidth)</l>
<l>        endif</l>
<l>        Row := 12</l>
<l>        Column := WinWidth - TextWidth - 12</l>
<l>    elseif (gInfoPos == 'LowerLeft')</l>
<l>        get_string_extents (WindowHandle, Information, Ascent, Descent, Width, Height)</l>
<l>        Row := WinHeight - (max2(0,NumInfoLines - 1) * (Ascent + Descent) + Height) - 12</l>
<l>        Column := 12</l>
<l>    else</l>
<c>        * Unknown position!</c>
<l>        stop ()</l>
<l>    endif</l>
<l>    disp_message (WindowHandle, Information, 'window', Row, Column, gInfoDecor[0], gInfoDecor[1])</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="disp_title_and_information">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Information"/>
<parameter id="Title"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="disp_continue_button">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays a 'Continue' text button</c>
<c>* in the lower right corner of the screen.</c>
<c>* It uses the procedure disp_message.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window, where the text shall be displayed</c>
<c>* </c>
<c>* Use the continue message set in the global variable gTerminationButtonLabel.</c>
<c>* If this variable is not defined, set a standard text instead.</c>
<l>global tuple gTerminationButtonLabel</l>
<l>try</l>
<l>    ContinueMessage := gTerminationButtonLabel</l>
<l>catch (Exception)</l>
<l>    ContinueMessage := 'Continue'</l>
<l>endtry</l>
<c>* Display the continue button</c>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>get_string_extents (WindowHandle, ' ' + ContinueMessage + ' ', Ascent, Descent, TextWidth, TextHeight)</l>
<l>disp_text_button (WindowHandle, ContinueMessage, 'window', Height - TextHeight - 22, Width - TextWidth - 12, 'black', '#f28f26')</l>
<l>return ()</l>
</body>
<docu id="disp_continue_button">
<abstract lang="en_US">Displays a continue button at the lower right corner.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display a continue button.</short>
<parameters>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle in which the button should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="trackball" access="local">
<interface>
<ic>
<par name="MX1" base_type="ctrl" dimension="0"/>
<par name="MY1" base_type="ctrl" dimension="0"/>
<par name="MX2" base_type="ctrl" dimension="0"/>
<par name="MY2" base_type="ctrl" dimension="0"/>
<par name="VirtualTrackball" base_type="ctrl" dimension="0"/>
<par name="TrackballSize" base_type="ctrl" dimension="0"/>
<par name="SensFactor" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="QuatRotation" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Compute the 3D rotation from the mouse movement</c>
<c>* </c>
<l>if (MX1 == MX2 and MY1 == MY2)</l>
<l>    QuatRotation := [1, 0, 0, 0]</l>
<l>    return ()</l>
<l>endif</l>
<c>* Project the image point onto the trackball</c>
<l>project_point_on_trackball (MX1, MY1, VirtualTrackball, TrackballSize, P1)</l>
<l>project_point_on_trackball (MX2, MY2, VirtualTrackball, TrackballSize, P2)</l>
<c>* The cross product of the projected points defines the rotation axis</c>
<l>tuple_vector_cross_product (P1, P2, RotAxis)</l>
<c>* Compute the rotation angle</c>
<l>D := P2 - P1</l>
<l>T := sqrt(sum(D * D)) / (2.0 * TrackballSize)</l>
<l>if (T &gt; 1.0)</l>
<l>    T := 1.0</l>
<l>endif</l>
<l>if (T &lt; -1.0)</l>
<l>    T := -1.0</l>
<l>endif</l>
<l>RotAngle := 2.0 * asin(T) * SensFactor</l>
<l>Len := sqrt(sum(RotAxis * RotAxis))</l>
<l>if (Len &gt; 0.0)</l>
<l>    RotAxis := RotAxis / Len</l>
<l>endif</l>
<l>axis_angle_to_quat (RotAxis[0], RotAxis[1], RotAxis[2], RotAngle, QuatRotation)</l>
<l>return ()</l>
</body>
<docu id="trackball">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Compute the 3D rotation from the mouse movement</short>
<parameters>
<parameter id="MX1"/>
<parameter id="MX2"/>
<parameter id="MY1"/>
<parameter id="MY2"/>
<parameter id="QuatRotation"/>
<parameter id="SensFactor"/>
<parameter id="TrackballSize"/>
<parameter id="VirtualTrackball"/>
</parameters>
</docu>
</procedure>
<procedure name="max_line_width" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Lines" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MaxWidth" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>MaxWidth := 0</l>
<l>for Index := 0 to |Lines| - 1 by 1</l>
<l>    get_string_extents (WindowHandle, Lines[Index], Ascent, Descent, LineWidth, LineHeight)</l>
<l>    MaxWidth := max([LineWidth,MaxWidth])</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="max_line_width">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get string extends of several lines.</short>
<parameters>
<parameter id="Lines"/>
<parameter id="MaxWidth"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="disp_text_button">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="String" base_type="ctrl" dimension="0"/>
<par name="CoordSystem" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="TextColor" base_type="ctrl" dimension="0"/>
<par name="ButtonColor" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays text in a graphics window.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The WindowHandle of the graphics window, where</c>
<c>*    the message should be displayed</c>
<c>* String: A tuple of strings containing the text message to be displayed</c>
<c>* CoordSystem: If set to 'window', the text position is given</c>
<c>*    with respect to the window coordinate system.</c>
<c>*    If set to 'image', image coordinates are used.</c>
<c>*    (This may be useful in zoomed images.)</c>
<c>* Row: The row coordinate of the desired text position</c>
<c>*    If set to -1, a default value of 12 is used.</c>
<c>* Column: The column coordinate of the desired text position</c>
<c>*    If set to -1, a default value of 12 is used.</c>
<c>* Color: defines the color of the text as string.</c>
<c>*    If set to [], '' or 'auto' the currently set color is used.</c>
<c>*    If a tuple of strings is passed, the colors are used cyclically</c>
<c>*    for each new textline.</c>
<c>* ButtonColor: Must be set to a color string (e.g. 'white', '#FF00CC', etc.).</c>
<c>*              The text is written in a box of that color.</c>
<c>* </c>
<c>* Prepare window.</c>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>get_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>get_window_extents (WindowHandle, RowWin, ColumnWin, WidthWin, HeightWin)</l>
<l>set_part (WindowHandle, 0, 0, HeightWin - 1, WidthWin - 1)</l>
<c>* </c>
<c>* Default settings.</c>
<l>if (Row == -1)</l>
<l>    Row := 12</l>
<l>endif</l>
<l>if (Column == -1)</l>
<l>    Column := 12</l>
<l>endif</l>
<l>if (TextColor == [])</l>
<l>    TextColor := ''</l>
<l>endif</l>
<c>* </c>
<l>try</l>
<l>    color_string_to_rgb (ButtonColor, RGB)</l>
<l>catch (Exception)</l>
<l>    Exception := 'Wrong value of control parameter ButtonColor (must be a valid color string)'</l>
<l>    throw (Exception)</l>
<l>endtry</l>
<l>Fac := 0.4</l>
<l>RGBL := RGB + int((255.0 - RGB) * Fac + 0.5)</l>
<l>RGBD := RGB - int(RGB * Fac + 0.5)</l>
<l>ButtonColorBorderL := '#' + sum('' + RGBL$'02x')</l>
<l>ButtonColorBorderD := '#' + sum('' + RGBD$'02x')</l>
<c>* </c>
<l>String := split('' + String + '','\n')</l>
<c>* </c>
<c>* Estimate extensions of text depending on font size.</c>
<l>get_font_extents (WindowHandle, MaxAscent, MaxDescent, MaxWidth, MaxHeight)</l>
<l>if (CoordSystem == 'window')</l>
<l>    R1 := Row</l>
<l>    C1 := Column</l>
<l>else</l>
<c>    * Transform image to window coordinates.</c>
<l>    FactorRow := 1. * HeightWin / (Row2Part - Row1Part + 1)</l>
<l>    FactorColumn := 1. * WidthWin / (Column2Part - Column1Part + 1)</l>
<l>    R1 := (Row - Row1Part + 0.5) * FactorRow</l>
<l>    C1 := (Column - Column1Part + 0.5) * FactorColumn</l>
<l>endif</l>
<c>* </c>
<c>* Display text box depending on text size.</c>
<c>* </c>
<c>* Calculate box extents.</c>
<l>String := ' ' + String + ' '</l>
<l>Width := []</l>
<l>for Index := 0 to |String| - 1 by 1</l>
<l>    get_string_extents (WindowHandle, String[Index], Ascent, Descent, W, H)</l>
<l>    Width := [Width,W]</l>
<l>endfor</l>
<l>FrameHeight := MaxHeight * |String|</l>
<l>FrameWidth := max([0,Width])</l>
<l>R2 := R1 + FrameHeight</l>
<l>C2 := C1 + FrameWidth</l>
<c>* Display rectangles.</c>
<l>get_system ('clip_region', ClipRegion)</l>
<l>set_system ('clip_region', 'false')</l>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>set_draw (WindowHandle, 'fill')</l>
<l>BorderWidth := 2</l>
<l>gen_region_polygon_filled (UpperLeft, [R1 - BorderWidth,R1 - BorderWidth,R1,R2,R2 + BorderWidth], [C1 - BorderWidth,C2 + BorderWidth,C2,C1,C1 - BorderWidth])</l>
<l>gen_region_polygon_filled (LowerRight, [R2 + BorderWidth,R1 - BorderWidth,R1,R2,R2 + BorderWidth], [C2 + BorderWidth,C2 + BorderWidth,C2,C1,C1 - BorderWidth])</l>
<l>gen_rectangle1 (Rectangle, R1, C1, R2, C2)</l>
<l>set_color (WindowHandle, ButtonColorBorderL)</l>
<l>disp_obj (UpperLeft, WindowHandle)</l>
<l>set_color (WindowHandle, ButtonColorBorderD)</l>
<l>disp_obj (LowerRight, WindowHandle)</l>
<l>set_color (WindowHandle, ButtonColor)</l>
<l>disp_obj (Rectangle, WindowHandle)</l>
<l>set_draw (WindowHandle, DrawMode)</l>
<l>set_system ('clip_region', ClipRegion)</l>
<c>* Write text.</c>
<l>for Index := 0 to |String| - 1 by 1</l>
<l>    CurrentColor := TextColor[Index % |TextColor|]</l>
<l>    if (CurrentColor != '' and CurrentColor != 'auto')</l>
<l>        set_color (WindowHandle, CurrentColor)</l>
<l>    else</l>
<l>        set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>    endif</l>
<l>    Row := R1 + MaxHeight * Index</l>
<l>    disp_text (WindowHandle, String[Index], 'window', Row, C1, CurrentColor, 'box', 'false')</l>
<l>endfor</l>
<c>* Reset changed window settings.</c>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>set_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>return ()</l>
</body>
<docu id="disp_text_button">
<abstract lang="en_US">This procedure displays text in a graphics window WindowHandle at the position (Row,Column).
If String is a tuple, one text line is displayed for each entry. Also, '\n' will be interpreted as a newline character, i.e., a line break is performed. Empty strings (or empty parts before or after a newline) are ignored. To write empty lines, use a whitespace character.

The position of the text may be specified in window coordinates (CoordSystem = *'window'*) or in image coordinates (CoordSystem = *'image'*), which is useful when using zoomed images.

The parameter TextColor also accepts tuples of values. In that case, the specified colors are used cyclically for every new textline.</abstract>
<alternatives>
<item>write_string</item>
<item>disp_continue_message</item>
</alternatives>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
disp_text_button (WindowHandle, ['Hello','World!'], 'window', 200, 200, ['black','blue'], 'white')</example>
<keywords lang="de_DE">
<item>Meldung anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display message</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>set_display_font</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>write_string</item>
<item>disp_continue_message</item>
</see_also>
<short>This procedure writes a text message.</short>
<short lang="en_US">Display a text message.</short>
<successor>
<item>disp_continue_message</item>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="ButtonColor">
<default_type>string</default_type>
<default_value>'gray'</default_value>
<description lang="en_US">If set to 'true', the text is written within a white box.</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'gray'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The column coordinate of the desired text position. If set to -1, a default value of 12 is used.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[10,12,20,30,40,50,60,70,80,90,100,200,300,400,500,1000]</item>
</values>
</parameter>
<parameter id="CoordSystem">
<default_type>string</default_type>
<default_value>'window'</default_value>
<description lang="en_US">If set to 'window', the text position is given with respect to the window coordinate system. If set to 'image', image coordinates are used (This may be useful in zoomed images).</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'window'</item>
<item>'image'</item>
</value_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The row coordinate of the desired text position. If set to -1, a default value of 12 is used.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[10,12,20,30,40,50,60,70,80,90,100,200,300,400,500,1000]</item>
</values>
</parameter>
<parameter id="String">
<default_type>string</default_type>
<default_value>'Text'</default_value>
<description lang="en_US">A tuple of strings containing the text message to be displayed. Each value of the tuple will be displayed in a single line.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="TextColor">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the color of the text as string. If set to [], or '' the currently set color is used. If a tuple of strings is passed, the colors are used cyclically for each new textline.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'white'</item>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the graphics window, where the message should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="project_point_on_trackball" access="local">
<interface>
<ic>
<par name="X" base_type="ctrl" dimension="0"/>
<par name="Y" base_type="ctrl" dimension="0"/>
<par name="VirtualTrackball" base_type="ctrl" dimension="0"/>
<par name="TrackballSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="V" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>if (VirtualTrackball == 'shoemake')</l>
<c>    * Virtual Trackball according to Shoemake</c>
<l>    R := sqrt(X * X + Y * Y)</l>
<l>    if (R &lt;= TrackballSize)</l>
<l>        XP := X</l>
<l>        YP := Y</l>
<l>        ZP := sqrt(TrackballSize * TrackballSize - R * R)</l>
<l>    else</l>
<l>        XP := X * TrackballSize / R</l>
<l>        YP := Y * TrackballSize / R</l>
<l>        ZP := 0</l>
<l>    endif</l>
<l>else</l>
<c>    * Virtual Trackball according to Bell</c>
<l>    R := sqrt(X * X + Y * Y)</l>
<l>    if (R &lt;= TrackballSize * 0.70710678)</l>
<l>        XP := X</l>
<l>        YP := Y</l>
<l>        ZP := sqrt(TrackballSize * TrackballSize - R * R)</l>
<l>    else</l>
<l>        XP := X</l>
<l>        YP := Y</l>
<l>        ZP := 0.6 * TrackballSize * TrackballSize / R</l>
<l>    endif</l>
<l>endif</l>
<l>V := [XP,YP,ZP]</l>
<l>return ()</l>
</body>
<docu id="project_point_on_trackball">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Project an image point onto the trackball</short>
<parameters>
<parameter id="TrackballSize"/>
<parameter id="V"/>
<parameter id="VirtualTrackball"/>
<parameter id="X"/>
<parameter id="Y"/>
</parameters>
</docu>
</procedure>
<procedure name="tuple_vector_cross_product">
<interface>
<ic>
<par name="V1" base_type="ctrl" dimension="0"/>
<par name="V2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="VC" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* The caller must ensure that the length of both input vectors is 3</c>
<l>VC := V1[1] * V2[2] - V1[2] * V2[1]</l>
<l>VC := [VC,V1[2] * V2[0] - V1[0] * V2[2]]</l>
<l>VC := [VC,V1[0] * V2[1] - V1[1] * V2[0]]</l>
<l>return ()</l>
</body>
<docu id="tuple_vector_cross_product">
<abstract lang="en_US">Calculates the cross product of two vectors of length 3.</abstract>
<chapters lang="de_DE">
<item>Tupel</item>
<item>Arithmetik</item>
</chapters>
<chapters lang="en_US">
<item>Tuple</item>
<item>Arithmetic</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate the cross product of two vectors of length 3.</short>
<parameters>
<parameter id="V1">
<default_type>real</default_type>
<description lang="en_US">First Vector</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="V2">
<default_type>real</default_type>
<description lang="en_US">Second vector.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="VC">
<default_type>real</default_type>
<description lang="en_US">Resulting vector.</description>
<mixed_type>optional</mixed_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="color_string_to_rgb">
<interface>
<ic>
<par name="Color" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RGB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>open_window (0, 0, 1, 1, 0, 'buffer', '', WindowHandleBuffer)</l>
<l>set_part (WindowHandleBuffer, 0, 0, -1, -1)</l>
<l>gen_rectangle1 (Rectangle, 0, 0, 0, 0)</l>
<l>try</l>
<l>    set_color (WindowHandleBuffer, Color)</l>
<l>catch (Exception)</l>
<l>    Exception := 'Wrong value of control parameter Color (must be a valid color string)'</l>
<l>    throw (Exception)</l>
<l>endtry</l>
<l>disp_obj (Rectangle, WindowHandleBuffer)</l>
<l>dump_window_image (Image, WindowHandleBuffer)</l>
<l>close_window (WindowHandleBuffer)</l>
<l>get_grayval (Image, 0, 0, RGB)</l>
<l>RGB := RGB + [0, 0, 0]</l>
<l>return ()</l>
</body>
<docu id="color_string_to_rgb">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Parameter</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Parameters</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Color"/>
<parameter id="RGB"/>
</parameters>
</docu>
</procedure>
<procedure name="check_dl_preprocess_param_COPY_1">
<interface>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<c>* This procedure checks a dictionary with parameters for DL preprocessing.</c>
<c></c>
<l>CheckParams := true</l>
<c>* If check_params is set to false, do not check anything.</c>
<l>get_dict_param (DLPreprocessParam, 'key_exists', 'check_params', KeyExists)</l>
<l>if (KeyExists)</l>
<l>    get_dict_tuple (DLPreprocessParam, 'check_params', CheckParams)</l>
<l>    if (not CheckParams)</l>
<l>        return ()</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>try</l>
<l>    get_dict_tuple (DLPreprocessParam, 'model_type', DLModelType)</l>
<l>catch (Exception)</l>
<l>    throw ('DLPreprocessParam needs the parameter: \'' + 'model_type' + '\'')</l>
<l>endtry</l>
<c></c>
<c>* Check for correct model type.</c>
<l>SupportedModelTypes := ['3d_gripping_point_detection', 'anomaly_detection', 'classification', 'detection', 'gc_anomaly_detection', 'ocr_recognition', 'segmentation']</l>
<l>tuple_find (SupportedModelTypes, DLModelType, Index)</l>
<l>if ((Index == -1) or (Index == []))</l>
<l>    throw ('Only models of type \'3d_gripping_point_detection\', \'anomaly_detection\', \'classification\', \'detection\', \'gc_anomaly_detection\', \'ocr_recognition\' or \'segmentation\' are supported')</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<c>* Parameter names that are required.</c>
<c>* General parameters.</c>
<l>ParamNamesGeneral := ['model_type', 'image_width', 'image_height', 'image_num_channels', 'image_range_min', 'image_range_max', 'normalization_type', 'domain_handling']</l>
<c>* Segmentation specific parameters.</c>
<l>ParamNamesSegmentation := ['ignore_class_ids', 'set_background_id', 'class_ids_background']</l>
<c>* Detection specific parameters.</c>
<l>ParamNamesDetectionOptional := ['instance_type', 'ignore_direction', 'class_ids_no_orientation', 'instance_segmentation']</l>
<c>* Optional preprocessing parameters.</c>
<l>ParamNamesPreprocessingOptional := ['mean_values_normalization', 'deviation_values_normalization', 'check_params', 'augmentation']</l>
<c>* 3D Gripping Point Detection specific parameters.</c>
<l>ParamNames3DGrippingPointsOptional := ['min_z', 'max_z', 'normal_image_width', 'normal_image_height']</l>
<c>* All parameters</c>
<l>ParamNamesAll := [ParamNamesGeneral,ParamNamesSegmentation,ParamNamesDetectionOptional,ParamNames3DGrippingPointsOptional,ParamNamesPreprocessingOptional]</l>
<l>ParamNames := ParamNamesGeneral</l>
<l>if (DLModelType == 'segmentation')</l>
<c>    * Extend ParamNames for models of type segmentation.</c>
<l>    ParamNames := [ParamNames,ParamNamesSegmentation]</l>
<l>endif</l>
<c></c>
<c>* Check if legacy parameter exist.</c>
<c>* Otherwise map it to the legal parameter.</c>
<l>replace_legacy_preprocessing_parameters_COPY_1 (DLPreprocessParam)</l>
<c></c>
<c>* Check that all necessary parameters are included.</c>
<c></c>
<l>get_dict_param (DLPreprocessParam, 'key_exists', ParamNames, KeysExists)</l>
<l>if (sum(KeysExists [==] 0) &gt; 0)</l>
<l>    for I := 0 to |KeysExists| by 1</l>
<l>        Exists := KeysExists[I]</l>
<l>        if (not Exists)</l>
<l>            throw ('DLPreprocessParam needs the parameter: \'' + ParamNames[I] + '\'')</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<c>* Check the keys provided.</c>
<l>get_dict_param (DLPreprocessParam, 'keys', [], InputKeys)</l>
<l>for I := 0 to |InputKeys| - 1 by 1</l>
<l>    Key := InputKeys[I]</l>
<l>    get_dict_tuple (DLPreprocessParam, Key, Value)</l>
<c>    * Check that the key is known.</c>
<l>    tuple_find (ParamNamesAll, Key, Indices)</l>
<l>    if (Indices == -1)</l>
<l>        throw ('Unknown key for DLPreprocessParam: \'' + InputKeys[I] + '\'')</l>
<l>        return ()</l>
<l>    endif</l>
<c>    * Set expected values and types.</c>
<l>    ValidValues := []</l>
<l>    ValidTypes := []</l>
<l>    if (Key == 'normalization_type')</l>
<l>        ValidValues := ['all_channels', 'first_channel', 'constant_values', 'none']</l>
<l>    elseif (Key == 'domain_handling')</l>
<l>        if (DLModelType == 'anomaly_detection')</l>
<l>            ValidValues := ['full_domain', 'crop_domain', 'keep_domain']</l>
<l>        elseif (DLModelType == '3d_gripping_point_detection')</l>
<l>            ValidValues := ['full_domain', 'crop_domain', 'keep_domain']</l>
<l>        else</l>
<l>            ValidValues := ['full_domain', 'crop_domain']</l>
<l>        endif</l>
<l>    elseif (Key == 'model_type')</l>
<l>        ValidValues := ['3d_gripping_point_detection', 'anomaly_detection', 'classification', 'detection', 'gc_anomaly_detection', 'ocr_recognition', 'segmentation']</l>
<l>    elseif (Key == 'augmentation')</l>
<l>        ValidValues := ['true', 'false']</l>
<l>    elseif (Key == 'set_background_id')</l>
<l>        ValidTypes := 'int'</l>
<l>    elseif (Key == 'class_ids_background')</l>
<l>        ValidTypes := 'int'</l>
<l>    endif</l>
<c>    * Check that type is valid.</c>
<l>    if (|ValidTypes| &gt; 0)</l>
<l>        for V := 0 to |ValidTypes| - 1 by 1</l>
<l>            T := ValidTypes[V]</l>
<l>            if (T == 'int')</l>
<l>                tuple_is_int (Value, IsInt)</l>
<l>                if (not IsInt)</l>
<l>                    ValidTypes := '\'' + ValidTypes + '\''</l>
<l>                    if (|ValidTypes| &lt; 2)</l>
<l>                        ValidTypesListing := ValidTypes</l>
<l>                    else</l>
<l>                        ValidTypesListing := sum(ValidTypes[0:max2(0,|ValidTypes| - 2)] + ', ' + ValidTypes[|ValidTypes| - 1])</l>
<l>                    endif</l>
<l>                    throw ('The value given in the key \'' + Key + '\' of DLPreprocessParam is invalid. Valid types are: ' + ValidTypesListing + '. The given value was \'' + Value + '\'.')</l>
<l>                    return ()</l>
<l>                endif</l>
<l>            else</l>
<l>                throw ('Internal error. Unknown valid type.')</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * Check that value is valid.</c>
<l>    if (|ValidValues| &gt; 0)</l>
<l>        tuple_find_first (ValidValues, Value, Index)</l>
<l>        if (Index == -1)</l>
<l>            ValidValues := '\'' + ValidValues + '\''</l>
<l>            if (|ValidValues| &lt; 2)</l>
<l>                ValidValueListing := ValidValues</l>
<l>            else</l>
<l>                EmptyStrings := gen_tuple_const(|ValidValues| - 2,'')</l>
<l>                ValidValueListing := sum(ValidValues[0:max2(0,|ValidValues| - 2)] + ', ' + [EmptyStrings,ValidValues[|ValidValues| - 1]])</l>
<l>            endif</l>
<l>            throw ('The value given in the key \'' + Key + '\' of DLPreprocessParam is invalid. Valid values are: ' + ValidValueListing + '. The given value was \'' + Value + '\'.')</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c>* Check the correct setting of ImageRangeMin and ImageRangeMax.</c>
<l>if (DLModelType == 'classification' or DLModelType == 'detection')</l>
<c>    * Check ImageRangeMin and ImageRangeMax.</c>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', 'image_range_min', ImageRangeMinExists)</l>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', 'image_range_max', ImageRangeMaxExists)</l>
<c>    * If they are present, check that they are set correctly.</c>
<l>    if (ImageRangeMinExists)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)</l>
<l>        if (ImageRangeMin != -127)</l>
<l>            throw ('For model type ' + DLModelType + ' ImageRangeMin has to be -127.')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (ImageRangeMaxExists)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)</l>
<l>        if (ImageRangeMax != 128)</l>
<l>            throw ('For model type ' + DLModelType + ' ImageRangeMax has to be 128.')</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>* Check segmentation specific parameters.</c>
<l>if (DLModelType == 'segmentation')</l>
<c>    * Check if detection specific parameters are set.</c>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', ParamNamesDetectionOptional, KeysExists)</l>
<c>    * If they are present, check that they are [].</c>
<l>    for IndexParam := 0 to |ParamNamesDetectionOptional| - 1 by 1</l>
<l>        if (KeysExists[IndexParam])</l>
<l>            get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[IndexParam], Value)</l>
<l>            if (Value != [])</l>
<l>                throw ('The preprocessing parameter \'' + ParamNamesDetectionOptional[IndexParam] + '\' was set to ' + Value + ' but for segmentation it should be set to [], as it is not used for this method.')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Check 'set_background_id'.</c>
<l>    get_dict_tuple (DLPreprocessParam, 'set_background_id', SetBackgroundID)</l>
<l>    if (|SetBackgroundID| &gt; 1)</l>
<l>        throw ('Only one class_id as \'set_background_id\' allowed.')</l>
<l>    endif</l>
<c>    * Check 'class_ids_background'.</c>
<l>    get_dict_tuple (DLPreprocessParam, 'class_ids_background', ClassIDsBackground)</l>
<l>    if ((|SetBackgroundID| &gt; 0 and not (|ClassIDsBackground| &gt; 0)) or (|ClassIDsBackground| &gt; 0 and not (|SetBackgroundID| &gt; 0)))</l>
<l>        throw ('Both keys \'set_background_id\' and \'class_ids_background\' are required.')</l>
<l>    endif</l>
<c>    * Check that 'class_ids_background' and 'set_background_id' are disjoint.</c>
<l>    if (|SetBackgroundID| &gt; 0)</l>
<l>        tuple_intersection (SetBackgroundID, ClassIDsBackground, Intersection)</l>
<l>        if (|Intersection|)</l>
<l>            throw ('Class IDs in \'set_background_id\' and \'class_ids_background\' need to be disjoint.')</l>
<l>        endif</l>
<l>    endif</l>
<c>    * Check 'ignore_class_ids'.</c>
<l>    get_dict_tuple (DLPreprocessParam, 'ignore_class_ids', IgnoreClassIDs)</l>
<l>    KnownClasses := [SetBackgroundID,ClassIDsBackground]</l>
<l>    for I := 0 to |IgnoreClassIDs| - 1 by 1</l>
<l>        IgnoreClassID := IgnoreClassIDs[I]</l>
<l>        tuple_find_first (KnownClasses, IgnoreClassID, Index)</l>
<l>        if (|Index| &gt; 0 and Index != -1)</l>
<l>            throw ('The given \'ignore_class_ids\' must not be included in the \'class_ids_background\' or \'set_background_id\'.')</l>
<l>        endif</l>
<l>    endfor</l>
<l>elseif (DLModelType == 'detection')</l>
<c>    * Check if segmentation specific parameters are set.</c>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', ParamNamesSegmentation, KeysExists)</l>
<c>    * If they are present, check that they are [].</c>
<l>    for IndexParam := 0 to |ParamNamesSegmentation| - 1 by 1</l>
<l>        if (KeysExists[IndexParam])</l>
<l>            get_dict_tuple (DLPreprocessParam, ParamNamesSegmentation[IndexParam], Value)</l>
<l>            if (Value != [])</l>
<l>                throw ('The preprocessing parameter \'' + ParamNamesSegmentation[IndexParam] + '\' was set to ' + Value + ' but for detection it should be set to [], as it is not used for this method.')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Check optional parameters.</c>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', ParamNamesDetectionOptional, OptionalKeysExist)</l>
<l>    if (OptionalKeysExist[0])</l>
<c>        * Check 'instance_type'.</c>
<l>        get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[0], InstanceType)</l>
<l>        if (find(['rectangle1', 'rectangle2', 'mask'],InstanceType) == -1)</l>
<l>            throw ('Invalid generic parameter for \'instance_type\': ' + InstanceType + ', only \'rectangle1\' and \'rectangle2\' are allowed')</l>
<l>        endif</l>
<l>    endif</l>
<c>    * If instance_segmentation is set we might overwrite the instance_type for the preprocessing.</c>
<l>    if (OptionalKeysExist[3])</l>
<l>        get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[3], IsInstanceSegmentation)</l>
<l>        if (find([true, false, 'true', 'false'],IsInstanceSegmentation) == -1)</l>
<l>            throw ('Invalid generic parameter for \'instance_segmentation\': ' + IsInstanceSegmentation + ', only true, false, \'true\' and \'false\' are allowed')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (OptionalKeysExist[1])</l>
<c>        * Check 'ignore_direction'.</c>
<l>        get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[1], IgnoreDirection)</l>
<l>        if (find([true, false],IgnoreDirection) == -1)</l>
<l>            throw ('Invalid generic parameter for \'ignore_direction\': ' + IgnoreDirection + ', only true and false are allowed')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (OptionalKeysExist[2])</l>
<c>        * Check 'class_ids_no_orientation'.</c>
<l>        get_dict_tuple (DLPreprocessParam, ParamNamesDetectionOptional[2], ClassIDsNoOrientation)</l>
<l>        tuple_sem_type_elem (ClassIDsNoOrientation, SemTypes)</l>
<l>        if (ClassIDsNoOrientation != [] and sum(SemTypes [==] 'integer') != |ClassIDsNoOrientation|)</l>
<l>            throw ('Invalid generic parameter for \'class_ids_no_orientation\': ' + ClassIDsNoOrientation + ', only integers are allowed')</l>
<l>        else</l>
<l>            if (ClassIDsNoOrientation != [] and sum(ClassIDsNoOrientation [&gt;=] 0) != |ClassIDsNoOrientation|)</l>
<l>                throw ('Invalid generic parameter for \'class_ids_no_orientation\': ' + ClassIDsNoOrientation + ', only non-negative integers are allowed')</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="check_dl_preprocess_param_COPY_1">
<abstract lang="en_US">This procedure checks the content of the parameter dictionary DLPreprocessParam.

If DLPreprocessParam contains a key 'check_params' with value false, the procedure returns without checking any parameter.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Check the content of the parameter dictionary DLPreprocessParam.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Parameter dictionary to check.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_augmentation_data_COPY_1">
<interface>
<ic>
<par name="DLSample" base_type="ctrl" dimension="0"/>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure preprocesses the provided DLSample image for augmentation purposes.</c>
<c></c>
<c>* Check the validity of the preprocessing parameters.</c>
<l>check_dl_preprocess_param_COPY_1 (DLPreprocessParam)</l>
<c></c>
<c>* Get the required preprocessing parameters.</c>
<l>ImageWidth := DLPreprocessParam.image_width</l>
<l>ImageHeight := DLPreprocessParam.image_height</l>
<l>ImageNumChannels := DLPreprocessParam.image_num_channels</l>
<l>ModelType := DLPreprocessParam.model_type</l>
<c></c>
<c>* Determine whether the preprocessing is required or not.</c>
<l>get_dict_param (DLPreprocessParam, 'key_exists', 'augmentation', AugmentationKeyExists)</l>
<l>if (not AugmentationKeyExists)</l>
<l>    return ()</l>
<l>endif</l>
<l>if (DLPreprocessParam.augmentation != 'true')</l>
<l>    return ()</l>
<l>endif</l>
<l>if (ModelType != 'ocr_recognition')</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<c>* Get the input image and its properties.</c>
<l>get_dict_param (DLSample, 'key_exists', 'image', ImageKeyExists)</l>
<l>if (not ImageKeyExists)</l>
<l>    throw ('The sample to process needs to include an image.')</l>
<l>endif</l>
<l>InputImage := DLSample.image</l>
<l>count_obj (InputImage, NumImages)</l>
<l>if (NumImages != 1)</l>
<l>    throw ('The sample to process needs to include exactly 1 image.')</l>
<l>endif</l>
<l>count_channels (InputImage, NumChannels)</l>
<l>get_image_type (InputImage, ImageType)</l>
<l>get_image_size (InputImage, InputImageWidth, InputImageHeight)</l>
<c></c>
<c>* Execute model specific preprocessing.</c>
<l>if (ModelType == 'ocr_recognition')</l>
<l>    if (ImageNumChannels != 1)</l>
<l>        throw ('The only \'image_num_channels\' value supported for ocr_recognition models is 1.')</l>
<l>    endif</l>
<l>    if (regexp_test(ImageType,'byte|real') != 1)</l>
<l>        throw ('Please provide only images of type \'byte\' or \'real\' for ocr_recognition models.')</l>
<l>    endif</l>
<l>    if (sum(NumChannels [==] 1 or NumChannels [==] 3) != 1)</l>
<l>        throw ('Please provide only 1- or 3-channels images for ocr_recognition models.')</l>
<l>    endif</l>
<c></c>
<l>    full_domain (InputImage, ImageHighRes)</l>
<l>    if (NumChannels == 3)</l>
<l>        rgb1_to_gray (ImageHighRes, ImageHighRes)</l>
<l>    endif</l>
<l>    InputImageWidthHeightRatio := InputImageWidth / real(InputImageHeight)</l>
<l>    ZoomHeight := min2(InputImageHeight,2 * ImageHeight)</l>
<l>    ZoomWidth := int(ZoomHeight * InputImageWidthHeightRatio)</l>
<l>    HasPadding := int(ImageHeight * InputImageWidthHeightRatio) &lt; ImageWidth</l>
<l>    if (ZoomHeight &gt; ImageHeight or HasPadding)</l>
<l>        zoom_image_size (ImageHighRes, ImageHighRes, ZoomWidth, ZoomHeight, 'constant')</l>
<l>        DLSample.augmentation_data := dict{}</l>
<l>        DLSample.augmentation_data.image_high_res := ImageHighRes</l>
<l>        DLSample.augmentation_data.preprocess_params := DLPreprocessParam</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_augmentation_data_COPY_1">
<abstract lang="en_US">This procedure preprocesses data from DLSample for augmentation purposes, according to the parameters in the dictionary DLPreprocessParam.

The resulting data is stored in DLSample in the dictionary field 'augmentation_data'. The dictionary 'augmentation_data' is used by &lt;proc:augment_dl_samples&gt;.

The dictionary DLPreprocessParam specifies the properties the images need for a successful model application, and it can be created using e.g., &lt;proc:create_dl_preprocess_param&gt; or &lt;proc:create_dl_preprocess_param_from_model&gt;.

This procedure works only if the preprocessing parameter 'augmentation_data' is set to 'true'.

The procedure supports only the model type 'ocr_recognition'.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess the provided DLSample image for augmentation purposes.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLSample">
<default_type>integer</default_type>
<description lang="en_US">DLSample dictionary.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_model_images_COPY_1">
<interface>
<io>
<par name="Images" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImagesPreprocessed" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<c>* This procedure preprocesses the provided Images according to the parameters in</c>
<c>* the dictionary DLPreprocessParam. Note that depending on the images, additional</c>
<c>* preprocessing steps might be beneficial.</c>
<c></c>
<c>* Validate the preprocessing parameters.</c>
<l>check_dl_preprocess_param_COPY_1 (DLPreprocessParam)</l>
<c></c>
<c>* Get the preprocessing parameters.</c>
<l>get_dict_tuple (DLPreprocessParam, 'image_width', ImageWidth)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_height', ImageHeight)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_num_channels', ImageNumChannels)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_min', ImageRangeMin)</l>
<l>get_dict_tuple (DLPreprocessParam, 'image_range_max', ImageRangeMax)</l>
<l>get_dict_tuple (DLPreprocessParam, 'domain_handling', DomainHandling)</l>
<l>get_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)</l>
<l>get_dict_tuple (DLPreprocessParam, 'model_type', ModelType)</l>
<c></c>
<c>* Validate the type of the input images.</c>
<l>count_obj (Images, NumImages)</l>
<l>if (NumImages == 0)</l>
<l>    throw ('Please provide some images to preprocess.')</l>
<l>endif</l>
<l>get_image_type (Images, Type)</l>
<l>tuple_regexp_test (Type, 'byte|int|real', NumMatches)</l>
<l>if (NumMatches != NumImages)</l>
<l>    throw ('Please provide only images of type \'byte\', \'int1\', \'int2\', \'uint2\', \'int4\', \'int8\', or \'real\'.')</l>
<l>endif</l>
<c></c>
<c></c>
<c>* Validate the number channels of the input images.</c>
<l>count_channels (Images, InputNumChannels)</l>
<l>OutputNumChannels := gen_tuple_const(NumImages,ImageNumChannels)</l>
<c>* Only for 'image_num_channels' 1 and 3 combinations of 1- and 3-channel images are allowed.</c>
<l>if (ImageNumChannels == 1 or ImageNumChannels == 3)</l>
<l>    NumChannels1 := gen_tuple_const(NumImages,1)</l>
<l>    NumChannels3 := gen_tuple_const(NumImages,3)</l>
<l>    AreInputNumChannels1 := InputNumChannels [==] NumChannels1</l>
<l>    AreInputNumChannels3 := InputNumChannels [==] NumChannels3</l>
<l>    AreInputNumChannels1Or3 := AreInputNumChannels1 + AreInputNumChannels3</l>
<l>    ValidNumChannels := AreInputNumChannels1Or3 == NumChannels1</l>
<l>    ValidNumChannelsText := 'Valid numbers of channels for the specified model are 1 or 3.'</l>
<l>else</l>
<l>    ValidNumChannels := InputNumChannels == OutputNumChannels</l>
<l>    ValidNumChannelsText := 'Valid number of channels for the specified model is ' + ImageNumChannels + '.'</l>
<l>endif</l>
<l>if (not ValidNumChannels)</l>
<l>    throw ('Please provide images with a valid number of channels. ' + ValidNumChannelsText)</l>
<l>endif</l>
<c>* Preprocess the images.</c>
<c></c>
<c>* For models of type '3d_gripping_point_detection', the preprocessing steps need to be performed on full</c>
<c>* domain images while the domains are preserved and set back into the images after the preprocessing.</c>
<l>PreserveDomain := false</l>
<c></c>
<c></c>
<c>* Apply the domain to the images.</c>
<l>if (DomainHandling == 'full_domain')</l>
<l>    full_domain (Images, Images)</l>
<l>endif</l>
<c></c>
<c>* Zoom preserved domains before zooming the images.</c>
<c></c>
<l>if (regexp_test(Type,'int1|int4|int8') == 0)</l>
<l>    zoom_image_size (Images, Images, ImageWidth, ImageHeight, 'constant')</l>
<l>    convert_image_type (Images, Images, 'real')</l>
<l>endif</l>
<c></c>
<l>if (NormalizationType == 'all_channels')</l>
<l>elseif (NormalizationType == 'none')</l>
<l>    tuple_find (Type, 'byte', Indices)</l>
<l>    if (Indices != -1)</l>
<c>        * Shift the gray values from [0-255] to the expected range for byte images.</c>
<l>        RescaleRange := (ImageRangeMax - ImageRangeMin) / 255.0</l>
<l>        select_obj (Images, ImageSelected, Indices + 1)</l>
<l>        scale_image (ImageSelected, ImageSelected, RescaleRange, ImageRangeMin)</l>
<l>        replace_obj (Images, ImageSelected, Images, Indices + 1)</l>
<l>    endif</l>
<l>elseif (NormalizationType != 'none')</l>
<l>    throw ('Unsupported parameter value for \'normalization_type\'')</l>
<l>endif</l>
<c></c>
<c>* Ensure that the number of channels of the resulting images is consistent with the</c>
<c>* number of channels of the given model. The only exceptions that are adapted below</c>
<c>* are combinations of 1- and 3-channel images if ImageNumChannels is either 1 or 3.</c>
<l>if (ImageNumChannels == 1 or ImageNumChannels == 3)</l>
<l>    count_channels (Images, CurrentNumChannels)</l>
<l>    tuple_find (CurrentNumChannels [!=] OutputNumChannels, 1, DiffNumChannelsIndices)</l>
<l>endif</l>
<c></c>
<c>* In case the image domains were preserved, they need to be set back into the images.</c>
<c></c>
<c>* Write preprocessed images to output variable.</c>
<l>ImagesPreprocessed := Images</l>
<c></c>
<l>return ()</l>
</body>
<docu id="preprocess_dl_model_images_COPY_1">
<abstract lang="en_US">This procedure preprocesses the provided Images according to the parameters in the dictionary DLPreprocessParam.

The dictionary DLPreprocessParam specifies the properties the images need for a successful model application.

The preprocessed images are returned in ImagesPreprocessed.

The dictionary DLPreprocessParam can be created using e.g., &lt;proc:create_dl_preprocess_param&gt; or &lt;proc:create_dl_preprocess_param_from_model&gt;.

Note that depending on the dataset, additional customized preprocessing steps might be beneficial, but they have to be done before this procedure is called.

It is recommended to check the output images of this procedure in order to verify that they are suitable for a successful training of a model. For example, if defects on the images are no longer discernible after zooming, it might help to increase the image dimensions.

Note that this procedure can only preprocess input images fulfilling the following conditions:
- Image type is equal to 'byte', 'int1', 'int2', 'uint2', 'int4', 'int8' or 'real'.&lt;br/&gt;
   Different image types could be combined if the other conditions are met.
- Number of channels is equal to the parameter *'image_num_channels'* in DLPreprocessParam.&lt;br/&gt;
   Special cases:
   - *'image_num_channels'* is either *1* or *3*: For each case, both 1- and 3-channel images will also be supported and their output adapted if required.
   - *'normalization_type'* is *'constant_values'* and any of the parameters 'mean_values_normalization' or 'deviation_values_normalization' was not specified: Only 1- or 3-channel images will be supported if *'image_num_channels'* is *1* or *3*.
   - *'normalization_type'* is 'none': It is expected that images of type 'real' and 'int' already have gray values in the range [ImageRangeMin,ImageRangeMax].

If an input image differs in these points, please execute a customized preprocessing.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Preprocess images for deep-learning-based training and inference.</short>
<parameters>
<parameter id="DLPreprocessParam">
<default_type>integer</default_type>
<description lang="en_US">Dictionary containing the preprocessing parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dict</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Images">
<description lang="en_US">Images to be preprocessed.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImagesPreprocessed">
<description lang="en_US">Preprocessed images.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="replace_legacy_preprocessing_parameters_COPY_1">
<interface>
<ic>
<par name="DLPreprocessParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<c>* This procedure adapts the dictionary DLPreprocessParam</c>
<c>* if a legacy preprocessing parameter is set.</c>
<c></c>
<c>* Map legacy value set to new parameter.</c>
<l>Exception := false</l>
<l>try</l>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', 'normalization_type', NormalizationTypeExists)</l>
<c></c>
<l>    if (NormalizationTypeExists)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)</l>
<l>        if (NormalizationType == 'true')</l>
<l>            NormalizationType := 'first_channel'</l>
<l>        elseif (NormalizationType == 'false')</l>
<l>            NormalizationType := 'none'</l>
<l>        endif</l>
<l>        set_dict_tuple (DLPreprocessParam, 'normalization_type', NormalizationType)</l>
<l>    endif</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c></c>
<c>* Map legacy parameter to new parameter and corresponding value.</c>
<l>Exception := false</l>
<l>try</l>
<l>    get_dict_param (DLPreprocessParam, 'key_exists', 'contrast_normalization', LegacyNormalizationKeyExists)</l>
<l>    if (LegacyNormalizationKeyExists)</l>
<l>        get_dict_tuple (DLPreprocessParam, 'contrast_normalization', ContrastNormalization)</l>
<c>        * Replace 'contrast_normalization' by 'normalization_type'.</c>
<l>        if (ContrastNormalization == 'false')</l>
<l>            set_dict_tuple (DLPreprocessParam, 'normalization_type', 'none')</l>
<l>        elseif (ContrastNormalization == 'true')</l>
<l>            set_dict_tuple (DLPreprocessParam, 'normalization_type', 'first_channel')</l>
<l>        endif</l>
<l>        remove_dict_key (DLPreprocessParam, 'contrast_normalization')</l>
<l>    endif</l>
<l>catch (Exception)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="replace_legacy_preprocessing_parameters_COPY_1">
<abstract lang="en_US">Legacy preprocessing parameters or values are replaced by their currently corresponding one.

The following parameters are replaced:
- 'contrast_normalization' is replaced by 'normalization_type'
- 'normalization_type' values 'true'/'false' are replaced by 'first_channel'/'none'</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Modell</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Model</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Replace legacy preprocessing parameters or values.</short>
<parameters>
<parameter id="DLPreprocessParam"/>
</parameters>
</docu>
</procedure>
</hdevelop>
